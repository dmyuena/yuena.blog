<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/yuena.blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/yuena.blog/images/yuena.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/yuena.blog/images/yuena.ico">
  <link rel="mask-icon" href="/yuena.blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/yuena.blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-flat-top.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dmyuena.github.io","root":"/yuena.blog/","images":"/yuena.blog/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/yuena.blog/js/config.js"></script>

    <meta name="description" content="第一章：简介STM32 F103 C8T6STM32各系列型号">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32_基于标准库">
<meta property="og:url" content="https://dmyuena.github.io/yuena.blog/2024/02/25/STM32-%E5%9F%BA%E4%BA%8E%E6%A0%87%E5%87%86%E5%BA%93/index.html">
<meta property="og:site_name" content="YueNa&#39;s Blog">
<meta property="og:description" content="第一章：简介STM32 F103 C8T6STM32各系列型号">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185139596.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185058105.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185614055.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185514132.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185311644.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424121610971.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424121734880.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185725699.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128192252479.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128200951991.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424145315979.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128211940014.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128194611354.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128193738985.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128193849237.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128204534853.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424150523430.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231129203415365.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231129203559092.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/b7cc12c256aaa7d4b210618c9df2cee5.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508125558309.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/3-1%20LED%E9%97%AA%E7%83%81.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231129215659059.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/3-4%20%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6LED.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/3-5%20%E5%85%89%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A7%E5%88%B6%E8%9C%82%E9%B8%A3%E5%99%A8.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130180641058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/4-1%20OLED%E6%98%BE%E7%A4%BA%E5%B1%8F.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130183409493.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423183926095.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130202514617.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-30%20203823.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130205519044.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130204921149.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/5-1%20%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423130848486.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423131425294.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423132610399.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423155711392.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423160827731.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423163404013.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423165340586.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423172532746.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423173716573.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423173752958.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423175242890.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423180636503.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423180658568.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423180715769.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423180609837.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423183618467.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423192333488.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424104143811.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424104245002.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424110749304.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424111359139.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424124425256.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424124809576.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424111637501.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424112224572.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424112133537.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424112152000.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424113329965.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424121508183.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424114010835.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424123639218.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424125625732.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424181523055.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424182022272.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424175158358.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425131618033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424173652102.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425140042547.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425140111015.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425134501762.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425141057721.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425151506773.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425151749337.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425152145297.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425153812321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425154223350.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425155245130.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507103320957.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507104834480.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507105821854.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507110709893.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507110933873.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507111336195.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507123517760.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507125249980.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507125816989.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507140319955.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507141151398.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507160039811.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507145539871.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507145653336.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507150528702.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507150743416.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507162511368.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507160456765.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507181403346.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507181617814.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507181819508.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507181937806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507183549401.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507183628869.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508121303965.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508122825421.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508131539041.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508130213549.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508132757906.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508132603924.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508134526296.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508142101896.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508150323202.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508151532800.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508152340082.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508163058093.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508175628888.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508175702958.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508180134158.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508180212982.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509102828117.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509103049131.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509105119664.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509111851243.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509112340952.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509112353643.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509112413965.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509113017480.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509113036596.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509114451650.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509120635494.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509145941452.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509150932982.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509153401592.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509154655238.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509154735194.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509160541578.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509170757130.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509171948093.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509180157367.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509180726199.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509182353362.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509183334141.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509174135947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517172247035.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517173409952.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517175123674.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517173653353.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517174210728.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517174429606.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522113214966.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522113434869.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522114748963.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522114802443.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522114812361.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522115214696.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522115607783.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522120543506.png">
<meta property="article:published_time" content="2024-02-25T14:10:36.000Z">
<meta property="article:modified_time" content="2024-06-25T14:16:27.183Z">
<meta property="article:author" content="chouzhen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185139596.png">


<link rel="canonical" href="https://dmyuena.github.io/yuena.blog/2024/02/25/STM32-%E5%9F%BA%E4%BA%8E%E6%A0%87%E5%87%86%E5%BA%93/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dmyuena.github.io/yuena.blog/2024/02/25/STM32-%E5%9F%BA%E4%BA%8E%E6%A0%87%E5%87%86%E5%BA%93/","path":"2024/02/25/STM32-基于标准库/","title":"STM32_基于标准库"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>STM32_基于标准库 | YueNa's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/yuena.blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/yuena.blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">YueNa's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">秋窗犹曙色,落木更天风</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/yuena.blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/yuena.blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">第一章：简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32-F103-C8T6"><span class="nav-number">1.1.</span> <span class="nav-text">STM32 F103 C8T6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32%E5%90%84%E7%B3%BB%E5%88%97%E5%9E%8B%E5%8F%B7"><span class="nav-number">1.2.</span> <span class="nav-text">STM32各系列型号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.3.</span> <span class="nav-text">命名规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM"><span class="nav-number">1.4.</span> <span class="nav-text">ARM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%87%E4%B8%8A%E8%B5%84%E6%BA%90%EF%BC%88%E5%A4%96%E8%AE%BE%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">片上资源（外设）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%84%9A%E5%AE%9A%E4%B9%89"><span class="nav-number">1.6.</span> <span class="nav-text">引脚定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.</span> <span class="nav-text">系统结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">第二章：新建工程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">STM32的三种开发方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">新建工程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%B7%A5%E7%A8%8B%E5%BF%85%E8%A6%81%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.1.</span> <span class="nav-text">添加工程必要文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%A4%B4%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="nav-number">2.2.2.</span> <span class="nav-text">添加头文件路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0main%E5%87%BD%E6%95%B0%EF%BC%88%E5%9C%A8user%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%EF%BC%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">添加main函数（在user文件夹中）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E7%BA%BF"><span class="nav-number">2.2.4.</span> <span class="nav-text">接线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%B0%83%E8%AF%95%E5%99%A8"><span class="nav-number">2.2.5.</span> <span class="nav-text">配置调试器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%83%A7%E5%BD%95"><span class="nav-number">2.2.6.</span> <span class="nav-text">编译烧录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%82%B9%E7%81%AF"><span class="nav-number">2.2.7.</span> <span class="nav-text">用寄存器点灯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.8.</span> <span class="nav-text">添加库函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%E2%80%94%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">拓展—模块化编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AGPIO"><span class="nav-number">3.</span> <span class="nav-text">第三章：GPIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%8F%A3"><span class="nav-number">3.1.1.</span> <span class="nav-text">通用输入输出口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.2.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GPIO%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.3.</span> <span class="nav-text">GPIO模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">推挽输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">开漏输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E7%94%A8"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">复用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E6%8E%A7GPIO%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.2.</span> <span class="nav-text">操控GPIO基本步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84RCC%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">常用的RCC库函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8GPIO%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.2.</span> <span class="nav-text">常用GPIO库函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LED%E9%97%AA%E7%83%81"><span class="nav-number">3.3.</span> <span class="nav-text">LED闪烁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LED%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="nav-number">3.4.</span> <span class="nav-text">LED流水灯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="nav-number">3.5.</span> <span class="nav-text">蜂鸣器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6LED"><span class="nav-number">3.6.</span> <span class="nav-text">按键控制LED</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%89%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A7%E5%88%B6%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="nav-number">3.7.</span> <span class="nav-text">光敏传感器控制蜂鸣器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9AOLED%E6%98%BE%E7%A4%BA%E5%B1%8F%E2%80%94%E8%B0%83%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">第四章：OLED显示屏—调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UP%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84OLED%E8%B0%83%E8%AF%95%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">UP自己写的OLED调试函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kile5-%E8%87%AA%E5%B8%A6%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-number">4.2.</span> <span class="nav-text">Kile5 自带调试工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9AEXTI-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="nav-number">5.</span> <span class="nav-text">第五章：EXTI 外部中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32%E4%B8%AD%E6%96%AD"><span class="nav-number">5.1.</span> <span class="nav-text">STM32中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EXTI%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="nav-number">5.2.</span> <span class="nav-text">EXTI外部中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">旋转编码器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1"><span class="nav-number">5.4.</span> <span class="nav-text">对射式红外传感器计次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE%EF%BC%9A%EF%BC%88%E5%8F%82%E8%80%83%E4%B8%8A%E5%9B%BE%E7%9A%84EXTI%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-number">5.4.1.</span> <span class="nav-text">外部中断配置：（参考上图的EXTI基本结构）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.</span> <span class="nav-text">库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AFIO%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.1.</span> <span class="nav-text">AFIO的库函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXTI%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.2.</span> <span class="nav-text">EXTI库函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NVIC%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.3.</span> <span class="nav-text">NVIC库函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E2%80%94-%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.4.</span> <span class="nav-text">启动文件—&gt;中断函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">5.4.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%AC%A1"><span class="nav-number">5.5.</span> <span class="nav-text">旋转编码器计次</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9ATIM%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD"><span class="nav-number">6.</span> <span class="nav-text">第六章：TIM定时中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">6.1.</span> <span class="nav-text">定时器简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text">定时器类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">6.2.1.</span> <span class="nav-text">基本定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">6.2.2.</span> <span class="nav-text">通用定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">6.2.3.</span> <span class="nav-text">高级定时器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.</span> <span class="nav-text">定时器中断基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%88%86%E9%A2%91%E5%99%A8%E6%97%B6%E5%BA%8F%EF%BC%88%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0%EF%BC%89"><span class="nav-number">6.3.1.</span> <span class="nav-text">预分频器时序（回炉重造）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%B6%E5%BA%8F"><span class="nav-number">6.4.</span> <span class="nav-text">计数器时序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%A0%E9%A2%84%E8%A3%85%E6%97%B6%E5%BA%8F"><span class="nav-number">6.4.1.</span> <span class="nav-text">计数器无预装时序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%9C%89%E9%A2%84%E8%A3%85%E6%97%B6%E5%BA%8F"><span class="nav-number">6.4.2.</span> <span class="nav-text">计数器有预装时序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RCC-%E6%97%B6%E9%92%9F%E6%A0%91"><span class="nav-number">6.4.3.</span> <span class="nav-text">RCC 时钟树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0%EF%BC%89"><span class="nav-number">6.5.</span> <span class="nav-text">定时器初始化（回炉重造）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">6.6.</span> <span class="nav-text">定时器 库函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD-timer-c"><span class="nav-number">6.7.</span> <span class="nav-text">定时器定时中断 timer.c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F"><span class="nav-number">6.8.</span> <span class="nav-text">定时器外部时钟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E5%8A%9F%E8%83%BD%EF%BC%88OC%EF%BC%89"><span class="nav-number">6.9.</span> <span class="nav-text">定时器输出比较功能（OC）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84-%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83-%E9%80%9A%E9%81%93"><span class="nav-number">6.9.1.</span> <span class="nav-text">通用定时器的 输出比较 通道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">6.9.1.1.</span> <span class="nav-text">输出模式控制器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-PWM%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">6.9.1.2.</span> <span class="nav-text">输出 PWM的基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PWM%E5%8F%82%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="nav-number">6.9.1.3.</span> <span class="nav-text">PWM参数计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E9%A2%91%E7%8E%87-%E5%92%8C-%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="nav-number">6.9.1.4.</span> <span class="nav-text">程序计算频率 和 占空比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84-%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83-%E9%80%9A%E9%81%93%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">6.9.2.</span> <span class="nav-text">高级定时器的 输出比较 通道（了解）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32-%E5%8F%AF-%E7%94%B1-PWM-%E9%A9%B1%E5%8A%A8%E7%9A%84-%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87"><span class="nav-number">6.10.</span> <span class="nav-text">STM32 可 由 PWM 驱动的 外部设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%88%B5%E6%9C%BA"><span class="nav-number">6.10.1.</span> <span class="nav-text">舵机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA"><span class="nav-number">6.10.2.</span> <span class="nav-text">直流电机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PWM-%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.11.</span> <span class="nav-text">PWM 初始化 基本步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PWM-%E9%A9%B1%E5%8A%A8LED%E5%91%BC%E5%90%B8%E7%81%AF"><span class="nav-number">6.12.</span> <span class="nav-text">PWM 驱动LED呼吸灯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PWM-%E9%A9%B1%E5%8A%A8%E8%88%B5%E6%9C%BA"><span class="nav-number">6.13.</span> <span class="nav-text">PWM 驱动舵机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PWM-%E9%A9%B1%E5%8A%A8%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA"><span class="nav-number">6.14.</span> <span class="nav-text">PWM 驱动直流电机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIM%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%EF%BC%88IC%EF%BC%89"><span class="nav-number">6.15.</span> <span class="nav-text">TIM输入捕获（IC）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E9%87%8F%E9%A2%91%E7%8E%87%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">6.15.1.</span> <span class="nav-text">测量频率的几种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F%E6%B5%8B%E9%A2%91%E7%8E%87"><span class="nav-number">6.15.2.</span> <span class="nav-text">输入捕获模式测频率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IC-%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7-%E7%9A%84-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.15.2.1.</span> <span class="nav-text">IC(输入捕获 的 初始化)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5PWM%E4%BD%9C%E4%B8%BA%E4%BF%A1%E5%8F%B7%E6%BA%90%EF%BC%8C%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%B5%8B%E8%AF%95%E9%A2%91%E7%8E%87"><span class="nav-number">6.15.2.2.</span> <span class="nav-text">以PWM作为信号源，输入捕获测试频率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PWMI%E6%A8%A1%E5%BC%8F%E6%B5%8B%E9%A2%91%E7%8E%87%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="nav-number">6.15.3.</span> <span class="nav-text">PWMI模式测频率占空比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIM%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.16.</span> <span class="nav-text">TIM编码器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.16.1.</span> <span class="nav-text">编码器接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">6.16.2.</span> <span class="nav-text">正交编码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.16.3.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.16.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9AADC%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">第七章：ADC模数转换器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">7.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.1.1.</span> <span class="nav-text">规则组的转换模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">7.1.2.</span> <span class="nav-text">触发控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="nav-number">7.1.3.</span> <span class="nav-text">数据对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="nav-number">7.1.4.</span> <span class="nav-text">转换时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%A1%E5%87%86"><span class="nav-number">7.1.5.</span> <span class="nav-text">校准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF"><span class="nav-number">7.1.6.</span> <span class="nav-text">硬件电路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AD%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="nav-number">7.2.</span> <span class="nav-text">AD初始化步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AD%E5%8D%95%E9%80%9A%E9%81%93-%E7%94%B5%E4%BD%8D%E5%99%A8"><span class="nav-number">7.3.</span> <span class="nav-text">AD单通道(电位器)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AD%E5%A4%9A%E9%80%9A%E9%81%93"><span class="nav-number">7.4.</span> <span class="nav-text">AD多通道</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ADMA%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E5%AD%98%E5%8F%96%EF%BC%88%E6%90%AC%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">第八章：DMA直接存储器存取（搬数据）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">8.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%83%8F"><span class="nav-number">8.2.</span> <span class="nav-text">存储器映像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA-%E6%A1%86%E5%9B%BE%EF%BC%8C%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">8.3.</span> <span class="nav-text">DMA 框图，结构图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6%E5%AF%B9%E9%BD%90"><span class="nav-number">8.4.</span> <span class="nav-text">数据宽度对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="nav-number">8.5.</span> <span class="nav-text">DMA初始化步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90-DMA"><span class="nav-number">8.6.</span> <span class="nav-text">数据转运 + DMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADC%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F-DMA"><span class="nav-number">8.7.</span> <span class="nav-text">ADC扫描模式 + DMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E4%BA%AE%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">8.8.</span> <span class="nav-text">存储器地址，常量和变亮，结构体访问寄存器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9AUSART%E4%B8%B2%E5%8F%A3"><span class="nav-number">9.</span> <span class="nav-text">第九章：USART串口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.1.</span> <span class="nav-text">通信接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="nav-number">9.2.</span> <span class="nav-text">串口通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-1"><span class="nav-number">9.2.1.</span> <span class="nav-text">硬件电路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86%EF%BC%88%E5%B8%B8%E7%94%A8%E7%9A%84%EF%BC%89"><span class="nav-number">9.2.2.</span> <span class="nav-text">电平标准（常用的）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%EF%BC%8C%E5%AD%97%E8%8A%82%EF%BC%8C%E5%AD%97%E9%95%BF%EF%BC%8C%E4%BD%8D"><span class="nav-number">9.2.3.</span> <span class="nav-text">字，字节，字长，位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%82%E6%95%B0%E5%8F%8A%E6%97%B6%E5%BA%8F"><span class="nav-number">9.2.4.</span> <span class="nav-text">串口参数及时序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USART"><span class="nav-number">9.3.</span> <span class="nav-text">USART</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-1"><span class="nav-number">9.3.1.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E4%BD%8D"><span class="nav-number">9.3.2.</span> <span class="nav-text">校验位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E4%BD%8D"><span class="nav-number">9.3.3.</span> <span class="nav-text">停止位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%B7%E5%A7%8B%E4%BD%8D%E4%BE%A6%E6%B5%8B"><span class="nav-number">9.3.4.</span> <span class="nav-text">起始位侦测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%A1%E7%AE%97"><span class="nav-number">9.3.5.</span> <span class="nav-text">波特率计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.3.6.</span> <span class="nav-text">数据模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="nav-number">9.4.</span> <span class="nav-text">串口发送数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E7%BA%BF%E5%9B%BE"><span class="nav-number">9.4.1.</span> <span class="nav-text">接线图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">9.4.2.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.4.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">9.5.</span> <span class="nav-text">串口接收数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">9.6.</span> <span class="nav-text">串口收发数据包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HEX%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">9.6.1.</span> <span class="nav-text">HEX数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">9.6.2.</span> <span class="nav-text">文本数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">9.6.3.</span> <span class="nav-text">状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6HEX%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%88%E5%9B%BA%E5%AE%9A%E5%8C%85%E9%95%BF%EF%BC%89"><span class="nav-number">9.6.4.</span> <span class="nav-text">接收HEX数据包（固定包长）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%88%E4%B8%8D%E5%9B%BA%E5%AE%9A%E5%8C%85%E9%95%BF%EF%BC%89"><span class="nav-number">9.6.5.</span> <span class="nav-text">接收文本数据包（不固定包长）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91HEX%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">9.7.</span> <span class="nav-text">串口收发HEX数据包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">9.8.</span> <span class="nav-text">串口收发文本数据包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9AI2C%E9%80%9A%E4%BF%A1"><span class="nav-number">10.</span> <span class="nav-text">第十章：I2C通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="nav-number">10.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-2"><span class="nav-number">10.2.</span> <span class="nav-text">硬件电路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80"><span class="nav-number">10.3.</span> <span class="nav-text">设备地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I2C%E6%97%B6%E5%BA%8F%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83"><span class="nav-number">10.4.</span> <span class="nav-text">I2C时序基本单元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%B7%E5%A7%8B%E6%9D%A1%E4%BB%B6"><span class="nav-number">10.4.1.</span> <span class="nav-text">起始条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="nav-number">10.4.2.</span> <span class="nav-text">终止条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%88%E4%B8%BB%E6%9C%BA%EF%BC%89"><span class="nav-number">10.4.3.</span> <span class="nav-text">发送一个字节（主机）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%88%E4%B8%BB%E6%9C%BA%EF%BC%89"><span class="nav-number">10.4.4.</span> <span class="nav-text">接收一个字节（主机）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94"><span class="nav-number">10.4.5.</span> <span class="nav-text">发送应答</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E5%BA%94%E7%AD%94"><span class="nav-number">10.4.6.</span> <span class="nav-text">接收应答</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I2C%E6%97%B6%E5%BA%8F"><span class="nav-number">10.5.</span> <span class="nav-text">I2C时序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E5%86%99"><span class="nav-number">10.5.1.</span> <span class="nav-text">指定地址写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E5%9C%B0%E5%9D%80%E8%AF%BB"><span class="nav-number">10.5.2.</span> <span class="nav-text">当前地址读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E8%AF%BB"><span class="nav-number">10.5.3.</span> <span class="nav-text">指定地址读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MPU6050%EF%BC%88%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0%EF%BC%89"><span class="nav-number">10.6.</span> <span class="nav-text">MPU6050（回炉重造）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="nav-number">10.6.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MPU6050%E5%8F%82%E6%95%B0"><span class="nav-number">10.6.2.</span> <span class="nav-text">MPU6050参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6I2C%E8%AF%BB%E5%86%99MPU6050"><span class="nav-number">10.7.</span> <span class="nav-text">软件I2C读写MPU6050</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I2C%E9%80%9A%E4%BF%A1%E5%A4%96%E8%AE%BE"><span class="nav-number">10.8.</span> <span class="nav-text">I2C通信外设</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">10.8.1.</span> <span class="nav-text">硬件结构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E6%9C%BA-%E5%8F%91%E9%80%81-%E6%8E%A5%E6%94%B6-%E6%B5%81%E7%A8%8B"><span class="nav-number">10.8.2.</span> <span class="nav-text">主机 发送&amp;接收 流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6I2C%E8%AF%BB%E5%86%99MPU6050%EF%BC%88HLCZ%EF%BC%89"><span class="nav-number">10.9.</span> <span class="nav-text">硬件I2C读写MPU6050（HLCZ）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9ASPI%E9%80%9A%E4%BF%A1"><span class="nav-number">11.</span> <span class="nav-text">第十一章：SPI通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="nav-number">11.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-3"><span class="nav-number">11.2.</span> <span class="nav-text">硬件电路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-number">11.3.</span> <span class="nav-text">移位示意图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPI%E6%97%B6%E5%BA%8F"><span class="nav-number">11.4.</span> <span class="nav-text">SPI时序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%B7%E5%A7%8B%E6%9D%A1%E4%BB%B6-1"><span class="nav-number">11.4.1.</span> <span class="nav-text">起始条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-1"><span class="nav-number">11.4.2.</span> <span class="nav-text">终止条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI%E6%97%B6%E5%BA%8F%E5%8D%95%E5%85%83%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="nav-number">11.4.3.</span> <span class="nav-text">SPI时序单元，交换一个字节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F0"><span class="nav-number">11.4.3.1.</span> <span class="nav-text">模式0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F1"><span class="nav-number">11.4.3.2.</span> <span class="nav-text">模式1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F2"><span class="nav-number">11.4.3.3.</span> <span class="nav-text">模式2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F3"><span class="nav-number">11.4.3.4.</span> <span class="nav-text">模式3</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E5%86%99-1"><span class="nav-number">11.4.4.</span> <span class="nav-text">指定地址写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E8%AF%BB-1"><span class="nav-number">11.4.5.</span> <span class="nav-text">指定地址读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#W25Q64"><span class="nav-number">11.5.</span> <span class="nav-text">W25Q64</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-4"><span class="nav-number">11.5.1.</span> <span class="nav-text">硬件电路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flash%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">11.5.2.</span> <span class="nav-text">Flash使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6SPI%E8%AF%BB%E5%86%99W25Q64"><span class="nav-number">11.6.</span> <span class="nav-text">软件SPI读写W25Q64</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPI%E9%80%9A%E4%BF%A1%E5%A4%96%E8%AE%BE"><span class="nav-number">11.7.</span> <span class="nav-text">SPI通信外设</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6SPI%E8%AF%BB%E5%86%99W25Q64"><span class="nav-number">11.8.</span> <span class="nav-text">硬件SPI读写W25Q64</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A-RTC%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F"><span class="nav-number">12.</span> <span class="nav-text">第十二章： RTC实时时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Unix%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-number">12.1.</span> <span class="nav-text">Unix时间戳</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GMT-UTC"><span class="nav-number">12.2.</span> <span class="nav-text">GMT&#x2F;UTC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2-time-h"><span class="nav-number">12.3.</span> <span class="nav-text">时间戳转换 time.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BKP%E5%A4%87%E4%BB%BD%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">12.4.</span> <span class="nav-text">BKP备份寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RTC%E7%AE%80%E4%BB%8B"><span class="nav-number">12.5.</span> <span class="nav-text">RTC简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">12.6.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%A4%87%E4%BB%BD%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">12.7.</span> <span class="nav-text">读写备份寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F"><span class="nav-number">12.8.</span> <span class="nav-text">实时时钟</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9APWR%E7%94%B5%E6%BA%90%E6%8E%A7%E5%88%B6"><span class="nav-number">13.</span> <span class="nav-text">第十三章：PWR电源控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="nav-number">13.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.2.</span> <span class="nav-text">低功耗模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%A1%E7%9C%A0%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.2.1.</span> <span class="nav-text">睡眠模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.2.2.</span> <span class="nav-text">停机模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%85%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.2.3.</span> <span class="nav-text">待机模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%91"><span class="nav-number">13.3.</span> <span class="nav-text">修改主频</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9D%A1%E7%9C%A0%E6%A8%A1%E5%BC%8F-%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91"><span class="nav-number">13.4.</span> <span class="nav-text">睡眠模式+串口收发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1"><span class="nav-number">13.5.</span> <span class="nav-text">停止模式+对射式红外传感器计次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%85%E6%9C%BA%E6%A8%A1%E5%BC%8F-%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F"><span class="nav-number">13.6.</span> <span class="nav-text">待机模式+实时时钟</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="nav-number">14.</span> <span class="nav-text">第十四章：看门狗</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IWDG"><span class="nav-number">14.1.</span> <span class="nav-text">IWDG</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="nav-number">14.1.1.</span> <span class="nav-text">超时时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IWDG%E9%94%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">14.1.2.</span> <span class="nav-text">IWDG键寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F"><span class="nav-number">14.1.3.</span> <span class="nav-text">程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WWDG"><span class="nav-number">14.2.</span> <span class="nav-text">WWDG</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%89%B9%E6%80%A7"><span class="nav-number">14.2.1.</span> <span class="nav-text">工作特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4-1"><span class="nav-number">14.2.2.</span> <span class="nav-text">超时时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F-1"><span class="nav-number">14.2.3.</span> <span class="nav-text">程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IWWG-%E5%92%8C-WWDG-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">14.3.</span> <span class="nav-text">IWWG 和 WWDG 的比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9AFlash%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8%E9%97%AA%E5%AD%98"><span class="nav-number">15.</span> <span class="nav-text">第十五章：Flash程序存储器闪存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-2"><span class="nav-number">15.1.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%A6%E9%99%A4%E5%92%8C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">15.2.</span> <span class="nav-text">擦除和编程的基本步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FPEC%E7%9A%84%E8%A7%A3%E9%94%81%E5%92%8C%E5%8A%A0%E9%94%81"><span class="nav-number">15.2.1.</span> <span class="nav-text">FPEC的解锁和加锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">15.2.2.</span> <span class="nav-text">使用指针访问存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8%E7%BC%96%E7%A8%8B"><span class="nav-number">15.2.3.</span> <span class="nav-text">程序存储器编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E6%93%A6%E9%99%A4"><span class="nav-number">15.2.4.</span> <span class="nav-text">程序存储器页擦除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8%E5%85%A8%E6%93%A6%E9%99%A4"><span class="nav-number">15.2.5.</span> <span class="nav-text">程序存储器全擦除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82"><span class="nav-number">15.2.6.</span> <span class="nav-text">选项字节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82%E7%BC%96%E7%A8%8B"><span class="nav-number">15.2.6.1.</span> <span class="nav-text">选项字节编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82%E6%93%A6%E9%99%A4"><span class="nav-number">15.2.6.2.</span> <span class="nav-text">选项字节擦除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%99%A8%E4%BB%B6%E7%94%B5%E5%AD%90%E7%AD%BE%E5%90%8D"><span class="nav-number">15.2.7.</span> <span class="nav-text">器件电子签名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%86%85%E9%83%A8FLASH%E7%A8%8B%E5%BA%8F"><span class="nav-number">15.3.</span> <span class="nav-text">读写内部FLASH程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32-ST-Link-Utility"><span class="nav-number">15.4.</span> <span class="nav-text">STM32 ST-Link Utility</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chouzhen"
      src="/yuena.blog/images/yuena.gif">
  <p class="site-author-name" itemprop="name">chouzhen</p>
  <div class="site-description" itemprop="description">YueNa的博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/yuena.blog/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dmyuena" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dmyuena" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2237076291@qq.com" title="E-Mail → mailto:2237076291@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title">
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="ttps://xbww38261.xyz/" title="ttps:&#x2F;&#x2F;xbww38261.xyz&#x2F;" rel="noopener" target="_blank">梯子</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://jycblog.gitee.io/#indexCard" title="https:&#x2F;&#x2F;jycblog.gitee.io&#x2F;#indexCard" rel="noopener" target="_blank">一言</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://dhndzwxj.vercel.app/" title="https:&#x2F;&#x2F;dhndzwxj.vercel.app&#x2F;" rel="noopener" target="_blank">揭晓</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://namic00.github.io/" title="https:&#x2F;&#x2F;namic00.github.io&#x2F;" rel="noopener" target="_blank">C/C</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dmyuena.github.io/yuena.blog/2024/02/25/STM32-%E5%9F%BA%E4%BA%8E%E6%A0%87%E5%87%86%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yuena.blog/images/yuena.gif">
      <meta itemprop="name" content="chouzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YueNa's Blog">
      <meta itemprop="description" content="YueNa的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="STM32_基于标准库 | YueNa's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STM32_基于标准库
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-25 22:10:36" itemprop="dateCreated datePublished" datetime="2024-02-25T22:10:36+08:00">2024-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-25 22:16:27" itemprop="dateModified" datetime="2024-06-25T22:16:27+08:00">2024-06-25</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>120k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:49</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="第一章：简介"><a href="#第一章：简介" class="headerlink" title="第一章：简介"></a>第一章：简介</h1><h2 id="STM32-F103-C8T6"><a href="#STM32-F103-C8T6" class="headerlink" title="STM32 F103 C8T6"></a>STM32 F103 C8T6</h2><h2 id="STM32各系列型号"><a href="#STM32各系列型号" class="headerlink" title="STM32各系列型号"></a>STM32各系列型号</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185139596.png" alt="image-20231128185139596" style="zoom:50%;" />

<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185058105.png" alt="image-20231128185058105" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185614055.png" alt="image-20231128185614055" style="zoom:50%;" />

<h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><p>STM32&#x3D;ARM内核+外围电路</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185514132.png" alt="image-20231128185514132" style="zoom:50%;" />

<h2 id="片上资源（外设）"><a href="#片上资源（外设）" class="headerlink" title="片上资源（外设）"></a>片上资源（外设）</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185311644.png" alt="image-20231128185311644" style="zoom:50%;" />

<blockquote>
<p>本型号单片机，后面四个没有</p>
</blockquote>
<h2 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424121610971.png" alt="image-20240424121610971"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424121734880.png" alt="image-20240424121734880"></p>
<h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128185725699.png" alt="image-20231128185725699" style="zoom:50%;" />



<h1 id="第二章：新建工程"><a href="#第二章：新建工程" class="headerlink" title="第二章：新建工程"></a>第二章：新建工程</h1><h2 id="STM32的三种开发方式"><a href="#STM32的三种开发方式" class="headerlink" title="STM32的三种开发方式"></a>STM32的三种开发方式</h2><p>基于寄存器</p>
<p>基于标准库  本课程使用</p>
<p>基于HAL库（图形化界面）</p>
<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128192252479.png" alt="image-20231128192252479" style="zoom:50%;" />

<blockquote>
<p>弹出来的新窗口不用管，直接叉掉</p>
</blockquote>
<h3 id="添加工程必要文件"><a href="#添加工程必要文件" class="headerlink" title="添加工程必要文件"></a>添加工程必要文件</h3><p>在工程文件夹中新建start，user，library文件夹</p>
<p>添加相关文件到start中：</p>
<ul>
<li>添加STM32启动文件</li>
</ul>
<blockquote>
<p>D:\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\</p>
<p>Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm</p>
</blockquote>
<ul>
<li>添加外设寄存器的描述文件</li>
</ul>
<blockquote>
<p>D:\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\</p>
<p>Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x</p>
<p>路径下的.h .c 文件（三个）</p>
</blockquote>
<ul>
<li>添加内核寄存器的描述文件</li>
</ul>
<blockquote>
<p>D:\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\</p>
<p>Libraries\CMSIS\CM3\CoreSupport</p>
</blockquote>
<hr>
<p>回到K_5 添加导入 添加的文件</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128200951991.png" alt="image-20231128200951991" style="zoom:50%;" />



<blockquote>
<p>注意选择 文件类型 为All files</p>
<p>选择后缀为_md.s  , .c   .h  的文件添加到start中</p>
</blockquote>
<h3 id="添加头文件路径"><a href="#添加头文件路径" class="headerlink" title="添加头文件路径"></a>添加头文件路径</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424145315979.png" alt="image-20240424145315979"></p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128211940014.png" alt="image-20231128211940014" style="zoom:50%;" />

<h3 id="添加main函数（在user文件夹中）"><a href="#添加main函数（在user文件夹中）" class="headerlink" title="添加main函数（在user文件夹中）"></a>添加main函数（在user文件夹中）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意最后一个 } 后要空一行，不然编译后会报错</p>
</blockquote>
<h3 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h3><p>STM32与STINK接线图</p>
<blockquote>
<p>STM32最小系统版；STLINK;  杜邦线</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128194611354.png" alt="image-20231128194611354" style="zoom:50%;" />



<h3 id="配置调试器"><a href="#配置调试器" class="headerlink" title="配置调试器"></a>配置调试器</h3><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128193738985.png" alt="image-20231128193738985" style="zoom:50%;" />



<ul>
<li>设置下载程序后即 立即复位执行</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128193849237.png" alt="image-20231128193849237" style="zoom:50%;" />

<h3 id="编译烧录"><a href="#编译烧录" class="headerlink" title="编译烧录"></a>编译烧录</h3><p>编译后烧录到单片机内</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231128204534853.png" alt="image-20231128204534853"></p>
<p>从左到右依次</p>
<ul>
<li>1</li>
<li>编译</li>
<li>3</li>
<li>4</li>
<li>5</li>
<li>将程序下载到STM32内</li>
</ul>
<h3 id="用寄存器点灯"><a href="#用寄存器点灯" class="headerlink" title="用寄存器点灯"></a>用寄存器点灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	RCC-&gt;APB2ENR = <span class="number">0X00000010</span>;</span><br><span class="line">	GPIOC-&gt;CRH = <span class="number">0X00300000</span>;</span><br><span class="line">	GPIOC-&gt;ODR = <span class="number">0X00000000</span>;  <span class="comment">//0X00002000 熄灭</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>32位寄存器，了解即可 </p>
</blockquote>
<p>：（</p>
<h3 id="添加库函数"><a href="#添加库函数" class="headerlink" title="添加库函数"></a>添加库函数</h3><blockquote>
<p>D:\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\</p>
<p>Libraries\STM32F10x_StdPeriph_Driver\src</p>
<p>D:\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\</p>
<p>Libraries\STM32F10x_StdPeriph_Driver\inc</p>
<p>全选 复制到library文件夹中</p>
</blockquote>
<p>回到K_5 添加导入 添加的文件</p>
<blockquote>
<p>D:\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\</p>
<p>Project\STM32F10x_StdPeriph_Template</p>
<p>选择以 stm32f10x 命名的三个文件</p>
<p>复制到user文件夹中</p>
</blockquote>
<p>回到K_5 添加导入 添加的文件</p>
<hr>
<p>在 stm32f10x.h 找到 “USE_STDPERIPH_DRIVER”  （第 8296 行）</p>
<p>添加 代码 到 预处理器 define中（如图 步骤3 所示）</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424150523430.png" alt="image-20240424150523430"></p>
<hr>
<h2 id="拓展—模块化编程"><a href="#拓展—模块化编程" class="headerlink" title="拓展—模块化编程"></a>拓展—模块化编程</h2><p>1.在项目内新建文件夹（Handware）</p>
<p>2.魔术棒 - &gt; C&#x2F;C++ - &gt; Include Path  - &gt;  三个点 - &gt; 选择 新建的文件夹 （Handware）</p>
<p>3.Kile5中（Handware） 右键 添加 相应的.c .h 文件</p>
<blockquote>
<p>此步注意修改文件路径</p>
<p>代码提示：ctrl+alt+空格</p>
</blockquote>
<h1 id="第三章：GPIO"><a href="#第三章：GPIO" class="headerlink" title="第三章：GPIO"></a>第三章：GPIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GPIO（General Purpose Input Output）</p>
<h3 id="通用输入输出口"><a href="#通用输入输出口" class="headerlink" title="通用输入输出口"></a>通用输入输出口</h3><ul>
<li>输出模式下可控制端口输出高低电平，</li>
</ul>
<p>​		用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</p>
<ul>
<li>输入模式下可读取端口的高低电平或电压，</li>
</ul>
<p>​		用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li>GPIOA</li>
<li>GPIOB</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231129203415365.png" alt="image-20231129203415365" style="zoom:50%;" />

<p>1-&gt;高电平</p>
<p>0-&gt;低电平</p>
<p>驱动器：增大驱动能力</p>
<h3 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a>GPIO模式</h3><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231129203559092.png" alt="image-20231129203559092" style="zoom:50%;" />

<blockquote>
<p>目前 看不懂：（</p>
</blockquote>
<h4 id="推挽输出"><a href="#推挽输出" class="headerlink" title="推挽输出"></a>推挽输出</h4><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/b7cc12c256aaa7d4b210618c9df2cee5.jpeg" alt="img" style="zoom:25%;" />

<p>高电平上拉</p>
<p>低电平下拉</p>
<h4 id="开漏输出"><a href="#开漏输出" class="headerlink" title="开漏输出"></a>开漏输出</h4><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508125558309.png" alt="image-20240508125558309" style="zoom:25%;" />

<p>高电平引脚浮空</p>
<p>低电平下拉</p>
<p>—–&gt;I2C  -&gt; 硬件电路 ：外置弱上拉电阻+开漏输出模式</p>
<h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4><p>复用：GPIO的控制权交给硬件外设</p>
<h2 id="操控GPIO基本步骤"><a href="#操控GPIO基本步骤" class="headerlink" title="操控GPIO基本步骤"></a>操控GPIO基本步骤</h2><ol>
<li>使用RCC开启GPIO时钟</li>
<li>使用GPIO_init 函数 初始化GPIO</li>
<li>使用输出或者输入函数控制GPIO口</li>
</ol>
<h3 id="常用的RCC库函数"><a href="#常用的RCC库函数" class="headerlink" title="常用的RCC库函数"></a>常用的RCC库函数</h3><ul>
<li><p>RCC_AHB外设时钟控制</p>
<blockquote>
<p>第一个参数：选择外设</p>
<p>第二个参数：选择使能&#x2F;失能AHB外设时钟</p>
</blockquote>
</li>
<li><p>RCC_APB2外设时钟控制</p>
</li>
<li><p>RCC_APB1外设时钟控制</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="常用GPIO库函数"><a href="#常用GPIO库函数" class="headerlink" title="常用GPIO库函数"></a>常用GPIO库函数</h3><p>GPIO_Init:选择端口范围</p>
<p>GPIO_ReadInputDataBit：读取输入寄存器某一端口的输入值</p>
<p>GPIO_ReadInputData：读取整个输入寄存器</p>
<p>GPIO_ReadOutputDataBit：读取输出寄存器某一端口的输入值</p>
<p>GPIO_ReadOutputData：读取整个输出寄存器</p>
<p>GPIO_SetBits：把指定的端口设置成高电平       </p>
<blockquote>
<p> 相当于 C51中  P1_1&#x3D;0</p>
<p> 其中   GPIOx    就是P1口</p>
<p> ​           GPIO_Pin 就是选择P1口下的几号端口</p>
<p> 避免了  设置 P1&#x3D;0xff时，修改了寄存器的其他相关配置的情况</p>
</blockquote>
<p>GPIO_ResetBits：把指定的端口设置成低电平</p>
<p>GPIO_WriteBit：选择端口，置低&#x2F;高 电平【bit_set&#x2F;bit_reset】</p>
<p>GPIO_Write：直接配置寄存器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GPIO初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO读写函数</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>set置1</li>
<li>reset置0 （led亮）</li>
</ul>
<h2 id="LED闪烁"><a href="#LED闪烁" class="headerlink" title="LED闪烁"></a>LED闪烁</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/3-1 LED闪烁.jpg" style="zoom:200%;" />

<ul>
<li>点亮PA0口的LED，选择RCC_APB2Periph_GPIOA</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	</span><br><span class="line">	<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">    <span class="comment">//使用各个外设前必须开启时钟，否则对外设的操作无效</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">//定义结构体变量</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*右键 go to definitior of ...*/</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	<span class="comment">//GPIO模式，赋值为推挽输出模式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">    <span class="comment">//GPIO引脚，赋值为第0号引脚</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">//GPIO速度，赋值为50MHz （照搬即可）</span></span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	<span class="comment">//将赋值后的构体变量传递给GPIO_Init函数</span></span><br><span class="line">	<span class="comment">//函数内部会自动根据结构体的参数配置相应寄存器</span></span><br><span class="line">    <span class="comment">//实现GPIOA的初始化</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*设置PA0引脚的高低电平，实现LED闪烁，下面展示3种方法*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*方法1：GPIO_ResetBits设置低电平，GPIO_SetBits设置高电平*/</span></span><br><span class="line">		GPIO_ResetBits(GPIOA, GPIO_Pin_0);					<span class="comment">//将PA0引脚设置为低电平(亮)</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);										<span class="comment">//延时500ms</span></span><br><span class="line">		GPIO_SetBits(GPIOA, GPIO_Pin_0);					<span class="comment">//将PA0引脚设置为高电平</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);										<span class="comment">//延时500ms</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*方法2：GPIO_WriteBit设置低/高电平，由Bit_RESET/Bit_SET指定*/</span></span><br><span class="line">		GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);		<span class="comment">//将PA0引脚设置为低电平</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);										<span class="comment">//延时500ms</span></span><br><span class="line">		GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);			<span class="comment">//将PA0引脚设置为高电平</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);										<span class="comment">//延时500ms</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*方法3：GPIO_WriteBit设置低/高电平，由数据0/1指定，数据需要强转为BitAction类型*/</span></span><br><span class="line">		GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)<span class="number">0</span>);		<span class="comment">//将PA0引脚设置为低电平</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);										<span class="comment">//延时500ms</span></span><br><span class="line">		GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)<span class="number">1</span>);		<span class="comment">//将PA0引脚设置为高电平</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);										<span class="comment">//延时500ms</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LED流水灯"><a href="#LED流水灯" class="headerlink" title="LED流水灯"></a>LED流水灯</h2><p>![](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/3-2">https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/3-2</a> LED流水灯.jpg)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;  <span class="comment">//选择GPIOA所有引脚</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0001</span>);	<span class="comment">//0000 0000 0000 0001</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0002</span>);	<span class="comment">//0000 0000 0000 0010</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0004</span>);	<span class="comment">//0000 0000 0000 0100</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0008</span>);	<span class="comment">//0000 0000 0000 1000</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0010</span>);	<span class="comment">//0000 0000 0001 0000</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0020</span>);	<span class="comment">//0000 0000 0010 0000</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0040</span>);	<span class="comment">//0000 0000 0100 0000</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0080</span>);	<span class="comment">//0000 0000 1000 0000</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231129215659059.png" alt="image-20231129215659059" style="zoom: 33%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;    <span class="comment">//选择配置 PB_12 引脚</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_SetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_ResetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		GPIO_SetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">		Delay_ms(<span class="number">700</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意 PA15, B3, B4 是调试端口，若要使用，还需要进行额外的配置</li>
</ul>
<h2 id="按键控制LED"><a href="#按键控制LED" class="headerlink" title="按键控制LED"></a>按键控制LED</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/3-4 按键控制LED.jpg" style="zoom: 33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LED.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化，使用PA1和PA2口</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);</span><br><span class="line">    <span class="comment">//设PA1和PA2口默认为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//开LED1</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_ResetBits(GPIOA, GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_OFF</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//关LED1</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_SetBits(GPIOA, GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读PA1口寄存器，如果是0 置1 ；如果是1 置0</span></span><br><span class="line">	<span class="keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOA, GPIO_Pin_1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOA, GPIO_Pin_1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_ResetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_SetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_Turn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化，使用PB1和PB11口 </span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">//上拉输入</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//知道哪个按键按下</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_GetNum</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> KeyNum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果PB1口（寄存器）是0，即按键按下，KeyNum = 1</span></span><br><span class="line">	<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">20</span>);<span class="comment">//消抖</span></span><br><span class="line">		<span class="keyword">while</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>);</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		KeyNum = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == <span class="number">0</span>);</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		KeyNum = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> KeyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_Init();</span><br><span class="line">	Key_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KeyNum = Key_GetNum();</span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED1_Turn();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED2_Turn();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="光敏传感器控制蜂鸣器"><a href="#光敏传感器控制蜂鸣器" class="headerlink" title="光敏传感器控制蜂鸣器"></a>光敏传感器控制蜂鸣器</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/3-5 光敏传感器控制蜂鸣器.jpg" style="zoom:50%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Buzzer.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);						     <span class="comment">//将PB12引脚初始化为推挽输出</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	GPIO_SetBits(GPIOB, GPIO_Pin_12);							</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//蜂鸣器开启  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_ResetBits(GPIOB, GPIO_Pin_12);		<span class="comment">//设置PB12引脚为低电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_SetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_Turn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_12) == <span class="number">0</span>)		<span class="comment">//获取输出寄存器的状态，如果当前引脚输出低电平,设置PB12引脚为高电平</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOB, GPIO_Pin_12);						</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>														</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOB, GPIO_Pin_12);						</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LightSensor.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LightSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);						<span class="comment">//将PB13引脚初始化为上拉输入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取当前光敏传感器输出的高低电平</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：光敏传感器输出的高低电平，范围：0/1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LightSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);			<span class="comment">//返回PB13输入寄存器的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LightSensor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	Buzzer_Init();			<span class="comment">//蜂鸣器初始化</span></span><br><span class="line">	LightSensor_Init();		<span class="comment">//光敏传感器初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (LightSensor_Get() == <span class="number">1</span>)		<span class="comment">//如果当前光敏输出1</span></span><br><span class="line">		&#123;</span><br><span class="line">			Buzzer_ON();				<span class="comment">//蜂鸣器开启</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>							<span class="comment">//否则</span></span><br><span class="line">		&#123;</span><br><span class="line">			Buzzer_OFF();				<span class="comment">//蜂鸣器关闭</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="第四章：OLED显示屏—调试"><a href="#第四章：OLED显示屏—调试" class="headerlink" title="第四章：OLED显示屏—调试"></a>第四章：OLED显示屏—调试</h1><h2 id="UP自己写的OLED调试函数"><a href="#UP自己写的OLED调试函数" class="headerlink" title="UP自己写的OLED调试函数"></a>UP自己写的OLED调试函数</h2><p>需要导入</p>
<ul>
<li>OLED.c</li>
<li>OLED.h</li>
<li>OLED_Font.h  (字库)</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130180641058.png" alt="image-20231130180641058" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/4-1 OLED显示屏.jpg" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*OLED显示*/</span></span><br><span class="line">	OLED_ShowChar(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>);				<span class="comment">//1行1列显示字符A</span></span><br><span class="line">	</span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;HelloWorld!&quot;</span>);	<span class="comment">//1行3列显示字符串HelloWorld!</span></span><br><span class="line">	</span><br><span class="line">	OLED_ShowNum(<span class="number">2</span>, <span class="number">1</span>, <span class="number">12345</span>, <span class="number">5</span>);			<span class="comment">//2行1列显示十进制数字12345，长度为5</span></span><br><span class="line">	</span><br><span class="line">	OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">7</span>, <span class="number">-66</span>, <span class="number">2</span>);		<span class="comment">//2行7列显示有符号十进制数字-66，长度为2</span></span><br><span class="line">	</span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, <span class="number">0xAA55</span>, <span class="number">4</span>);		<span class="comment">//3行1列显示十六进制数字0xA5A5，长度为4</span></span><br><span class="line">	</span><br><span class="line">	OLED_ShowBinNum(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0xAA55</span>, <span class="number">16</span>);		<span class="comment">//4行1列显示二进制数字0xA5A5，长度为16</span></span><br><span class="line">											<span class="comment">//C语言无法直接写出二进制数字，故需要用十六进制表示</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kile5-自带调试工具"><a href="#Kile5-自带调试工具" class="headerlink" title="Kile5 自带调试工具"></a>Kile5 自带调试工具</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130183409493.png" alt="image-20231130183409493" style="zoom:50%;" />

<p>进入调试模式需要叉好板子（或者进入模拟调试模式）</p>
<ul>
<li>汇编程序</li>
<li>寄存器组和状态标志位</li>
<li>C语言程序</li>
</ul>
<ol>
<li>RST复位</li>
<li>全速运行</li>
<li>停止全速运行</li>
<li>单步运行</li>
<li>跳过当前行单步运行</li>
<li>跳出当前函数单步运行</li>
<li>跳到光标指定行单步运行</li>
</ol>
<hr>
<ol>
<li>命令窗口</li>
<li>反汇编窗口</li>
<li>符号窗口 ：实时 查看程序中所有变量的值</li>
</ol>
<p><strong>如果想修改程序，需要退出调试模式，修改代码后，再编译，进入调试模式</strong></p>
<p>添加书签</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423183926095.png" alt="image-20240423183926095" style="zoom:80%;" />



<h1 id="第五章：EXTI-外部中断"><a href="#第五章：EXTI-外部中断" class="headerlink" title="第五章：EXTI 外部中断"></a>第五章：EXTI 外部中断</h1><h2 id="STM32中断"><a href="#STM32中断" class="headerlink" title="STM32中断"></a>STM32中断</h2><ul>
<li>68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设</li>
<li>使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级</li>
<li>NVIC：嵌套中断向量控制器</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130202514617.png" alt="image-20231130202514617" style="zoom:50%;" />

<ul>
<li>一个外设可以占用多个中断通道</li>
<li>NVIC响应多个中断，并对其优先级进行 排序，从而减轻CPU负担</li>
</ul>
<p>NVIC的中断优先级由优先级寄存器的4位（0~15）决定</p>
<p>这4位可以进行切分</p>
<p>分为<u><strong>高n位的抢占优先级</strong></u>和<u><strong>低4-n位的响应优先级</strong></u><br>抢占优先级 高的可以中断嵌套（暂停前一个中断，直接执行这个中断）</p>
<p>响应优先级 高的可以优先排队（前一个中断执行完了，执行这个中断）</p>
<p>抢占优先级和响应优先级均相同的按中断号排队，数值小的优先</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/屏幕截图 2023-11-30 203823.png" style="zoom:50%;" />

<h2 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h2><ul>
<li>EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO<strong>口产生电平变化时</strong>，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</li>
<li>支持的触发方式：上升沿&#x2F;下降沿&#x2F;双边沿（上升沿和下降沿皆可）&#x2F;软件触发</li>
<li>支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断</li>
</ul>
<blockquote>
<p>相同的pin：</p>
<p>类似于PA0,PB0或者PA1,PB1,PC1这样的</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130205519044.png" alt="image-20231130205519044" style="zoom:50%;" />

<p>数据选择器：多选一</p>
</blockquote>
<ul>
<li><p>通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</p>
</li>
<li><p>触发响应方式：中断响应&#x2F;事件响应</p>
<blockquote>
<p>事件响应：不触发中断，而是触发其他的外设操作</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20231130204921149.png" alt="image-20231130204921149"></p>
<p><strong>AFIO</strong></p>
<ul>
<li>中断引脚选择</li>
<li>复用功能引脚重映射</li>
</ul>
<h2 id="旋转编码器"><a href="#旋转编码器" class="headerlink" title="旋转编码器"></a>旋转编码器</h2><ul>
<li>用来测量位置、速度或旋转方向的装置</li>
<li>当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向</li>
<li>类型：机械触点式&#x2F;霍尔传感器式&#x2F;光栅式</li>
</ul>
<h2 id="对射式红外传感器计次"><a href="#对射式红外传感器计次" class="headerlink" title="对射式红外传感器计次"></a>对射式红外传感器计次</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/5-1 对射式红外传感器计次.jpg" style="zoom:50%;" />



<p>当挡光片经过传感器时，DO口输出电平变化的信号 ，触发PB14口中断</p>
<h3 id="外部中断配置：（参考上图的EXTI基本结构）"><a href="#外部中断配置：（参考上图的EXTI基本结构）" class="headerlink" title="外部中断配置：（参考上图的EXTI基本结构）"></a>外部中断配置：（参考上图的EXTI基本结构）</h3><ul>
<li><p>配置RCC，打开外设时钟</p>
<ul>
<li>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</li>
<li>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</li>
</ul>
</li>
<li><p>配置GPIO</p>
<ul>
<li><pre><code class="c">GPIO_InitTypeDef GPIO_InitStructure;
//查找参考手册 GPIO--&gt; 外设GPIO配置表
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
//（默认GPIO_Speed_50MHz）
GPIO_Init(GPIOB, &amp;GPIO_InitStructure);						//将PB14引脚初始化为上拉输入
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 配置AFIO</span><br><span class="line"></span><br><span class="line">  - GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 配置EXTI,选择边沿触发方式，选择触发响应方式（触发，中断响应）</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    /*EXTI初始化*/(跳到定义，查看配置)</span><br><span class="line">    EXTI_InitTypeDef EXTI_InitStructure;//定义结构体变量</span><br><span class="line">    EXTI_InitStructure.EXTI_Line = EXTI_Line14;	//选择配置外部中断的14号线</span><br><span class="line">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;//指定外部中断线使能</span><br><span class="line">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;	//指定外部中断线为中断模式</span><br><span class="line">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;	//指定外部中断线为下降沿触发</span><br><span class="line">    EXTI_Init(&amp;EXTI_InitStructure);		//将结构体变量交给EXTI_Init，配置EXTI外设</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>配置NVIC，选择中断优先级，通过NVIC，外部中断信号，进入CPU</p>
<ul>
<li><pre><code class="c">/*NVIC配置*/
    NVIC_InitTypeDef NVIC_InitStructure;						//定义结构体变量
    NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;		//选择配置NVIC的EXTI15_10线
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				//指定NVIC线路使能
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;	//指定NVIC线路的抢占优先级为1
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;			//指定NVIC线路的响应优先级为1
    NVIC_Init(&amp;NVIC_InitStructure);								//将结构体变量交给NVIC_Init，配置NVIC外设
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- CPU 收到 中断信号，跳转到中断函数内 执行中断程序</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    void EXTI15_10_IRQHandler(void)</span><br><span class="line">    &#123;</span><br><span class="line">    	if (EXTI_GetITStatus(EXTI_Line14) == SET)		//判断是否是外部中断14号线触发的中断</span><br><span class="line">    	&#123;</span><br><span class="line">    		/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span><br><span class="line">    		if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == 0)</span><br><span class="line">    		&#123;</span><br><span class="line">    			CountSensor_Count ++;					//计数值自增一次</span><br><span class="line">    		&#125;</span><br><span class="line">    		EXTI_ClearITPendingBit(EXTI_Line14);		//清除外部中断14号线的中断标志位</span><br><span class="line">    													//中断标志位必须清除</span><br><span class="line">    													//否则中断将连续不断地触发，导致主程序卡死</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><h4 id="AFIO的库函数"><a href="#AFIO的库函数" class="headerlink" title="AFIO的库函数"></a>AFIO的库函数</h4><p>GPIO库函数（GPIO.h）中 关于AFIO外设 的库函数（重要的）</p>
<ul>
<li>void GPIO_AFIODeInit(void);&#x2F;&#x2F;复位AFIO外设</li>
<li>void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);&#x2F;&#x2F;锁定GPIO某个引脚配置</li>
<li>void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState);&#x2F;&#x2F;引脚重映射</li>
<li>void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);&#x2F;&#x2F;配置AFIO的数据选择器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423130848486.png" alt="image-20240423130848486"></p>
<h4 id="EXTI库函数"><a href="#EXTI库函数" class="headerlink" title="EXTI库函数"></a>EXTI库函数</h4><ul>
<li>void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);&#x2F;&#x2F;软件触发外部中断</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423131425294.png" alt="image-20240423131425294"></p>
<h4 id="NVIC库函数"><a href="#NVIC库函数" class="headerlink" title="NVIC库函数"></a>NVIC库函数</h4><p>打开msic.h 中的NVIC库函数</p>
<ul>
<li>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup); &#x2F;&#x2F;中断分组</li>
<li>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);&#x2F;&#x2F;初始化NVIC</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423132610399.png" alt="image-20240423132610399"></p>
<h4 id="启动文件—-中断函数"><a href="#启动文件—-中断函数" class="headerlink" title="启动文件—&gt;中断函数"></a>启动文件—&gt;中断函数</h4><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423155711392.png" alt="image-20240423155711392"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传感器驱动</span></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count;				<span class="comment">//全局变量，用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：计数传感器初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);		<span class="comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);						<span class="comment">//将PB14引脚初始化为上拉输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*AFIO选择中断引脚*/</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);</span><br><span class="line">    <span class="comment">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*EXTI初始化*/</span></span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Line = EXTI_Line14;					<span class="comment">//选择配置外部中断的14号线</span></span><br><span class="line">	EXTI_InitStructure.EXTI_LineCmd = ENABLE;					<span class="comment">//指定外部中断线使能</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;			<span class="comment">//指定外部中断线为中断模式</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;		<span class="comment">//指定外部中断线为下降沿触发</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructure);								<span class="comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);				<span class="comment">//配置NVIC为分组2</span></span><br><span class="line">																<span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line">																<span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line">										<span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line">									    <span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC配置*/</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;		<span class="comment">//选择配置NVIC的EXTI15_10线</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;	<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;			<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);								<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取计数传感器的计数值</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：计数值，范围：0~65535</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：EXTI15_10外部中断函数</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span></span><br><span class="line"><span class="comment">  *           函数名为预留的指定名称，可以从启动文件复制</span></span><br><span class="line"><span class="comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET)		<span class="comment">//判断是否是外部中断14号线触发的中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			CountSensor_Count ++;					<span class="comment">//计数值自增一次</span></span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line14);		<span class="comment">//清除外部中断14号线的中断标志位</span></span><br><span class="line">													<span class="comment">//中断标志位必须清除</span></span><br><span class="line">													<span class="comment">//否则中断将连续不断地触发，导致主程序卡死</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();			<span class="comment">//OLED初始化</span></span><br><span class="line">	CountSensor_Init();		<span class="comment">//计数传感器初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Count:&quot;</span>);	<span class="comment">//1行1列显示字符串Count:</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">7</span>, CountSensor_Get(), <span class="number">5</span>);		<span class="comment">//OLED不断刷新显示CountSensor_Get的返回值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="旋转编码器计次"><a href="#旋转编码器计次" class="headerlink" title="旋转编码器计次"></a>旋转编码器计次</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423160827731.png" alt="image-20240423160827731"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旋转编码器驱动（旋钮）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Encoder_Count;					<span class="comment">//全局变量，用于计数旋转编码器的增量值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);		<span class="comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);						<span class="comment">//将PB0和PB1引脚初始化为上拉输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*AFIO选择中断引脚*/</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);<span class="comment">//将外部中断的0号线映射到GPIOB，即选择PB0为外部中断引脚</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);<span class="comment">//将外部中断的1号线映射到GPIOB，即选择PB1为外部中断引脚</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*EXTI初始化*/</span></span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1;		<span class="comment">//选择配置外部中断的0号线和1号线</span></span><br><span class="line">	EXTI_InitStructure.EXTI_LineCmd = ENABLE;					<span class="comment">//指定外部中断线使能</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;			<span class="comment">//指定外部中断线为中断模式</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;		<span class="comment">//指定外部中断线为下降沿触发</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructure);								<span class="comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);				<span class="comment">//配置NVIC为分组2</span></span><br><span class="line">																<span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line">																<span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line">																<span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line">																<span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC配置*/</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;			<span class="comment">//选择配置NVIC的EXTI0线</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;	<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;			<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);								<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line"></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;			<span class="comment">//选择配置NVIC的EXTI1线</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;	<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;			<span class="comment">//指定NVIC线路的响应优先级为2</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);								<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：旋转编码器获取增量值</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：自上此调用此函数后，旋转编码器的增量值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*使用Temp变量作为中继，目的是返回Encoder_Count后将其清零*/</span></span><br><span class="line">	<span class="comment">/*在这里，也可以直接返回Encoder_Count</span></span><br><span class="line"><span class="comment">	  但这样就不是获取增量值的操作方法了</span></span><br><span class="line"><span class="comment">	  也可以实现功能，只是思路不一样*/</span></span><br><span class="line">	<span class="type">int16_t</span> Temp;</span><br><span class="line">	Temp = Encoder_Count;</span><br><span class="line">	Encoder_Count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：EXTI0外部中断函数</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span></span><br><span class="line"><span class="comment">  *           函数名为预留的指定名称，可以从启动文件复制</span></span><br><span class="line"><span class="comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line0) == SET)		<span class="comment">//判断是否是外部中断0号线触发的中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)		<span class="comment">//PB0的下降沿触发中断，此时检测另一相PB1的电平，目的是判断旋转方向</span></span><br><span class="line">			&#123;</span><br><span class="line">				Encoder_Count --;					<span class="comment">//此方向定义为反转，计数变量自减</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line0);			<span class="comment">//清除外部中断0号线的中断标志位</span></span><br><span class="line">													<span class="comment">//中断标志位必须清除</span></span><br><span class="line">													<span class="comment">//否则中断将连续不断地触发，导致主程序卡死</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：EXTI1外部中断函数</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span></span><br><span class="line"><span class="comment">  *           函数名为预留的指定名称，可以从启动文件复制</span></span><br><span class="line"><span class="comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line1) == SET)		<span class="comment">//判断是否是外部中断1号线触发的中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)		<span class="comment">//PB1的下降沿触发中断，此时检测另一相PB0的电平，目的是判断旋转方向</span></span><br><span class="line">			&#123;</span><br><span class="line">				Encoder_Count ++;					<span class="comment">//此方向定义为正转，计数变量自增</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line1);			<span class="comment">//清除外部中断1号线的中断标志位</span></span><br><span class="line">													<span class="comment">//中断标志位必须清除</span></span><br><span class="line">													<span class="comment">//否则中断将连续不断地触发，导致主程序卡死</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="第六章：TIM定时中断"><a href="#第六章：TIM定时中断" class="headerlink" title="第六章：TIM定时中断"></a>第六章：TIM定时中断</h1><h2 id="定时器简介"><a href="#定时器简介" class="headerlink" title="定时器简介"></a>定时器简介</h2><ul>
<li>定时器对输入的时钟进行计数，并在计数值达到设定值时触发中断</li>
<li>定时器级联：一个定时器的输出 当做 另一个定时器的输入</li>
<li>基本功能：<ul>
<li>定时中断功能</li>
<li>内外时钟源选择</li>
<li>输入捕获</li>
<li>输出比较</li>
<li>编码器接口</li>
<li>主从触发模式</li>
<li>等等</li>
</ul>
</li>
</ul>
<h2 id="定时器类型"><a href="#定时器类型" class="headerlink" title="定时器类型"></a>定时器类型</h2><p>STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423163404013.png" alt="image-20240423163404013"></p>
<h3 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h3><p>时基单元：由   16位的   计数器，预分频器和自动重装寄存器  组成</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423165340586.png" alt="image-20240423165340586"></p>
<p>当 CNT计数器 自增的值   等于  自动重装载寄存器 （软件配置）内的值  时，产生 中断信号，进入CPU 中断，并且 清零 技术值</p>
<h3 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h3><p>通用定时器同时具备了以下三种模式，而 基本定时器 只具备了向上计数 一种 模式</p>
<ul>
<li>向上计数 （计时器从0开始自增 到 重装值 时 产生中断 ）</li>
<li>向下计数 （计时器从重装值向下 自减 减到0 时 产生中断 ）</li>
<li>中央对齐 （计时器从0开始自增 到 重装值 时 产生中断，然后向下 自减 减到0 时 产生中断）</li>
</ul>
<p>通用定时器 不仅可以用 内部RCC 作为时钟  还可以从 外部引脚的输入信号作为 时钟，还有  TRGI 提供时钟（触发输入）</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423172532746.png" alt="image-20240423172532746"></p>
<h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423173716573.png" alt="image-20240423173716573"></p>
<h2 id="定时器中断基本结构"><a href="#定时器中断基本结构" class="headerlink" title="定时器中断基本结构"></a>定时器中断基本结构</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423173752958.png" alt="image-20240423173752958"></p>
<h3 id="预分频器时序（回炉重造）"><a href="#预分频器时序（回炉重造）" class="headerlink" title="预分频器时序（回炉重造）"></a>预分频器时序（回炉重造）</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423175242890.png" alt="image-20240423175242890"></p>
<p>计数器计数频率：CK_CNT &#x3D; CK_PSC &#x2F; (PSC + 1)</p>
<h2 id="计数器时序"><a href="#计数器时序" class="headerlink" title="计数器时序"></a>计数器时序</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423180636503.png" alt="image-20240423180636503"></p>
<p>计数器溢出频率：CK_CNT_OV &#x3D; CK_CNT &#x2F; (ARR + 1)<br>                           &#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)</p>
<h3 id="计数器无预装时序"><a href="#计数器无预装时序" class="headerlink" title="计数器无预装时序"></a>计数器无预装时序</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423180658568.png" alt="image-20240423180658568"></p>
<h3 id="计数器有预装时序"><a href="#计数器有预装时序" class="headerlink" title="计数器有预装时序"></a>计数器有预装时序</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423180715769.png" alt="image-20240423180715769"></p>
<h3 id="RCC-时钟树"><a href="#RCC-时钟树" class="headerlink" title="RCC 时钟树"></a>RCC 时钟树</h3><p>SystemInit   中 实现时钟树 </p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423180609837.png" alt="image-20240423180609837" style="zoom:200%;" />



<h2 id="定时器初始化（回炉重造）"><a href="#定时器初始化（回炉重造）" class="headerlink" title="定时器初始化（回炉重造）"></a>定时器初始化（回炉重造）</h2><p>基于上面的 定时中断基本结构（图）</p>
<ul>
<li><p>RCC 开启 时钟 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			<span class="comment">//开启TIM2的时钟</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>选择时基单元的时钟源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_InternalClockConfig(TIM2);		<span class="comment">//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置时基单元</p>
<ul>
<li><p>预分频器</p>
</li>
<li><p>计数器</p>
</li>
</ul>
<ol>
<li>自动重装器</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;		</span><br><span class="line"><span class="comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;	<span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span> - <span class="number">1</span>;				<span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;				<span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;			<span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);				</span><br><span class="line"><span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元	</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 输出中断控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TIM_ClearFlag(TIM2, TIM_FLAG_Update);						<span class="comment">//清除定时器更新标志位</span></span><br><span class="line">													<span class="comment">//TIM_TimeBaseInit函数末尾，手动产生了更新事件</span></span><br><span class="line">													<span class="comment">//若不清除此标志位，则开启中断后，会立刻进入一次中断</span></span><br><span class="line">													<span class="comment">//如果不介意此问题，则不清除此标志位也可</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开NVIC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);				<span class="comment">//配置NVIC为分组2</span></span><br><span class="line">									<span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line">									<span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line">									<span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line">									<span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;				<span class="comment">//选择配置NVIC的TIM2线</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;	<span class="comment">//指定NVIC线路的抢占优先级为2</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;			<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);								<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行控制 （使能 计数器）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_Cmd(TIM2, ENABLE);			<span class="comment">//使能TIM2，定时器开始运行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置定时器 中断函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) <span class="comment">//检查 中断标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		TIM_ClearITPendingBit(TIM2, TIM_IT_Update); <span class="comment">//清除 中断标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 中断函数 可以写在 其他.c文件中</span></span><br><span class="line"><span class="comment">// exturn 跨文件 寻找变量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="定时器-库函数"><a href="#定时器-库函数" class="headerlink" title="定时器 库函数"></a>定时器 库函数</h2><ul>
<li><p>void TIM_DeInit(TIM_TypeDef* TIMx);   &#x2F;&#x2F; 恢复 缺省配置</p>
</li>
<li><p>void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);  &#x2F;&#x2F; 时基单元 初始化</p>
</li>
<li><p>void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct); &#x2F;&#x2F;给结构体变量 赋默认值</p>
</li>
<li><p>void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);&#x2F;&#x2F;使能计数器</p>
</li>
<li><p>void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);  &#x2F;&#x2F;  使能中断输出 信号</p>
<p>&#x2F;&#x2F;时基单元 的 时基选择部分</p>
</li>
<li><p>void TIM_InternalClockConfig(TIM_TypeDef* TIMx);  </p>
</li>
<li><p>void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p>
</li>
<li><p>void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,<br>uint16_t TIM_ICPolarity, uint16_t ICFilter);</p>
</li>
<li><p>void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,<br>uint16_t ExtTRGFilter);</p>
</li>
<li><p>void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,<br>uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);</p>
</li>
<li><p>void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,<br>uint16_t ExtTRGFilter);</p>
</li>
</ul>
<hr>
<ul>
<li><p>void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode); &#x2F;&#x2F;单独 写入 预分频值</p>
</li>
<li><p>&#x2F;&#x2F;配置输出比较 模块</p>
<p>void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);</p>
<p>void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);</p>
<p>void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);</p>
<p>void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);</p>
</li>
<li><p>&#x2F;&#x2F;单独更改 RCC 寄存器 值的函数</p>
<p>Duty &#x3D; CCR &#x2F; (ARR + 1)    可以使用此函数 调整 PWM 占空比</p>
<p>void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);<br>void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);<br>void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);<br>void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);</p>
</li>
<li><p>等等</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423183618467.png" alt="image-20240423183618467"></p>
<h2 id="定时器定时中断-timer-c"><a href="#定时器定时中断-timer-c" class="headerlink" title="定时器定时中断 timer.c"></a>定时器定时中断 timer.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			<span class="comment">//开启TIM2的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*配置时钟源*/</span></span><br><span class="line">	TIM_InternalClockConfig(TIM2);		<span class="comment">//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;		<span class="comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;	<span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span> - <span class="number">1</span>;				<span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;				<span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;			<span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);				<span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元	</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*中断输出配置*/</span></span><br><span class="line">	TIM_ClearFlag(TIM2, TIM_FLAG_Update);						<span class="comment">//清除定时器更新标志位</span></span><br><span class="line">																<span class="comment">//TIM_TimeBaseInit函数末尾，手动产生了更新事件</span></span><br><span class="line">																<span class="comment">//若不清除此标志位，则开启中断后，会立刻进入一次中断</span></span><br><span class="line">																<span class="comment">//如果不介意此问题，则不清除此标志位也可</span></span><br><span class="line">	</span><br><span class="line">	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);					<span class="comment">//开启TIM2的更新中断</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);				<span class="comment">//配置NVIC为分组2</span></span><br><span class="line">																<span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line">																<span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line">																<span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line">																<span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC配置*/</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;				<span class="comment">//选择配置NVIC的TIM2线</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;	<span class="comment">//指定NVIC线路的抢占优先级为2</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;			<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);								<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM使能*/</span></span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);			<span class="comment">//使能TIM2，定时器开始运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="定时器外部时钟"><a href="#定时器外部时钟" class="headerlink" title="定时器外部时钟"></a>定时器外部时钟</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240423192333488.png" alt="image-20240423192333488"></p>
<p>用红外传感器 模拟 时钟输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			<span class="comment">//开启TIM2的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);						<span class="comment">//将PA0引脚初始化为上拉输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*外部时钟配置*/</span></span><br><span class="line">	TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, <span class="number">0x0F</span>);</span><br><span class="line">																<span class="comment">//选择外部时钟模式2，时钟从TIM_ETR引脚输入</span></span><br><span class="line">																<span class="comment">//注意TIM2的ETR引脚固定为PA0，无法随意更改</span></span><br><span class="line">																<span class="comment">//最后一个滤波器参数加到最大0x0F，可滤除时钟信号抖动</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;		</span><br><span class="line">    <span class="comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;	<span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10</span> - <span class="number">1</span>;					<span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>;				<span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;			<span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);				</span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元	</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*中断输出配置*/</span></span><br><span class="line">	TIM_ClearFlag(TIM2, TIM_FLAG_Update);						<span class="comment">//清除定时器更新标志位</span></span><br><span class="line">																<span class="comment">//TIM_TimeBaseInit函数末尾，手动产生了更新事件</span></span><br><span class="line">																<span class="comment">//若不清除此标志位，则开启中断后，会立刻进入一次中断</span></span><br><span class="line">																<span class="comment">//如果不介意此问题，则不清除此标志位也可</span></span><br><span class="line">																</span><br><span class="line">	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);					<span class="comment">//开启TIM2的更新中断</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);				<span class="comment">//配置NVIC为分组2</span></span><br><span class="line">											<span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line">											<span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line">											<span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line">											<span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC配置*/</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;				<span class="comment">//选择配置NVIC的TIM2线</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;	<span class="comment">//指定NVIC线路的抢占优先级为2</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;			<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);								<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM使能*/</span></span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);			<span class="comment">//使能TIM2，定时器开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Timer_GetCounter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> TIM_GetCounter(TIM2);	<span class="comment">//返回定时器TIM2的CNT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器输出比较功能（OC）"><a href="#定时器输出比较功能（OC）" class="headerlink" title="定时器输出比较功能（OC）"></a>定时器输出比较功能（OC）</h2><p>每个<strong>高级定时器</strong>和<strong>通用定时器</strong>都拥有4个输出比较通道<br><em>高级定时器的前3个通道额外拥有<strong>死区生成和互补输出</strong>的功能</em></p>
<p>输出比较 主要用于输出PWM 波形 —&gt; 驱动电机</p>
<p>输出比较 可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形</p>
<p>PWM 的几个参数</p>
<ul>
<li>频率</li>
<li>占空比</li>
<li>分辨率</li>
</ul>
<h3 id="通用定时器的-输出比较-通道"><a href="#通用定时器的-输出比较-通道" class="headerlink" title="通用定时器的 输出比较 通道"></a>通用定时器的 输出比较 通道</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424104143811.png" alt="image-20240424104143811"></p>
<h4 id="输出模式控制器"><a href="#输出模式控制器" class="headerlink" title="输出模式控制器"></a>输出模式控制器</h4><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424104245002.png" alt="image-20240424104245002"></p>
<p>有效电平：高电平</p>
<p>无效电平：低电平</p>
<p>匹配时置有效（无效）电平：只是输出一次 高（低）电平，不会输出高低电平波形</p>
<h4 id="输出-PWM的基本结构"><a href="#输出-PWM的基本结构" class="headerlink" title="输出 PWM的基本结构"></a>输出 PWM的基本结构</h4><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424110749304.png" alt="image-20240424110749304"></p>
<p>占空比 受CCR值 调控（正相关）</p>
<p>REF：频率可调，占空比可调的PWM波形</p>
<h4 id="PWM参数计算"><a href="#PWM参数计算" class="headerlink" title="PWM参数计算"></a>PWM参数计算</h4><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424111359139.png" alt="image-20240424111359139"></p>
<p>CK_PSC ：输入时钟，系统内部 输入时钟 72M</p>
<p>程序设置ARR,PSC,CCR 的值：</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424124425256.png" alt="image-20240424124425256"></p>
<p>其中CRR 的值可以通过 调用库函数 动态变化：</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424124809576.png" alt="image-20240424124809576"></p>
<h4 id="程序计算频率-和-占空比"><a href="#程序计算频率-和-占空比" class="headerlink" title="程序计算频率 和 占空比"></a>程序计算频率 和 占空比</h4><p>根据公式可知频率和占空比的计算公式：</p>
<ul>
<li>频率 &#x3D; CK_PSC &#x2F; ( PSC + 1) &#x2F; ( ARR + 1)</li>
<li>占空比 &#x3D; CCR &#x2F; （ ARR + 1）</li>
</ul>
<p>由此可知：频率 受  CK_PSC （一般 都是 系统提供 时钟 72M） ， PSC  ，ARR  影响</p>
<p>​					占空比 受 CCR  ， ARR 影响</p>
<p>​					ARR 可以同时影响 频率 和 占空比 </p>
<p>因此 我们可以 软件 调节 PSC   来控制频率</p>
<p>​											CCR   来控制占空比</p>
<h3 id="高级定时器的-输出比较-通道（了解）"><a href="#高级定时器的-输出比较-通道（了解）" class="headerlink" title="高级定时器的 输出比较 通道（了解）"></a>高级定时器的 输出比较 通道（了解）</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424111637501.png" alt="image-20240424111637501"></p>
<p>OC1 和 OC1N 接入外围电路</p>
<p>​	推挽电路：两个–&gt;H桥电路–&gt;控制 直流电机正反转</p>
<p>​						三个–&gt;驱动 三相无刷电机</p>
<p>​					</p>
<h2 id="STM32-可-由-PWM-驱动的-外部设备"><a href="#STM32-可-由-PWM-驱动的-外部设备" class="headerlink" title="STM32 可 由 PWM 驱动的 外部设备"></a>STM32 可 由 PWM 驱动的 外部设备</h2><h3 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424112224572.png" alt="image-20240424112224572"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424112133537.png" alt="image-20240424112133537"></p>
<p>输入一个PWM 波形，输出轴 固定在一个角度（机器人转头，小车控制方向）</p>
<h3 id="直流电机"><a href="#直流电机" class="headerlink" title="直流电机"></a>直流电机</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424112152000.png" alt="image-20240424112152000"></p>
<p>TB6612 原理图</p>
<p>AO1和AO2 ：设置电机的旋转方向</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424113329965.png" alt="image-20240424113329965"></p>
<h2 id="PWM-初始化-基本步骤"><a href="#PWM-初始化-基本步骤" class="headerlink" title="PWM 初始化 基本步骤"></a>PWM 初始化 基本步骤</h2><p>参考：输出 PWM的基本结构 图</p>
<ul>
<li><p>RCC 开启时钟  ：打开 TIM 外设 和 GPIO 外设 时钟</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			<span class="comment">//开启TIM2的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);           <span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置时钟源*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM2);		<span class="comment">//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>配置 时基 单元</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     </span><br><span class="line">	<span class="comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;					<span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span> - <span class="number">1</span>;				<span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;            <span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);   </span><br></pre></td></tr></table></figure>


</li>
<li><p>配置 输出比较单元</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*输出比较初始化*/</span></span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStructure;							<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStructure);							</span><br><span class="line">	<span class="comment">//结构体初始化，若结构体没有完整赋值，则最好执行此函数，给结构体所有成员都赋一个默认值</span></span><br><span class="line">	<span class="comment">//避免结构体初值不确定的问题</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;				<span class="comment">//输出比较模式，选择PWM模式1</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;		</span><br><span class="line">	<span class="comment">//输出极性，选择为高，若选择极性为低，则输出高低电平取反（上图的极性 选择）</span></span><br><span class="line"></span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;	<span class="comment">//输出使能</span></span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;								<span class="comment">//初始的CCR值</span></span><br><span class="line">	TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);						</span><br><span class="line">	<span class="comment">//将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>配置 GPIO </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;		<span class="comment">//GPIO_Pin_15;</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="comment">//将PA0引脚初始化为复用推挽输出	</span></span><br><span class="line">																	<span class="comment">//受外设控制的引脚，均需要配置为复用模式</span></span><br></pre></td></tr></table></figure>



<ul>
<li>—–&gt;PA0  选择PA0的原因：</li>
<li><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424121508183.png" alt="image-20240424121508183"></li>
</ul>
</li>
<li><p>运行控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*TIM使能*/</span></span><br><span class="line">TIM_Cmd(TIM2, ENABLE);			<span class="comment">//使能TIM2，定时器开始运行 , 启动定时器</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="PWM-驱动LED呼吸灯"><a href="#PWM-驱动LED呼吸灯" class="headerlink" title="PWM 驱动LED呼吸灯"></a>PWM 驱动LED呼吸灯</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424114010835.png" alt="image-20240424114010835"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PWM 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			<span class="comment">//开启TIM2的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO重映射*/</span></span><br><span class="line"><span class="comment">//	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);			//开启AFIO的时钟，重映射必须先开启AFIO的时钟</span></span><br><span class="line"><span class="comment">//	GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);			//将TIM2的引脚部分重映射，具体的映射方案需查看参考手册</span></span><br><span class="line"><span class="comment">//	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);		//将JTAG引脚失能，作为普通GPIO引脚使用</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;		<span class="comment">//GPIO_Pin_15;</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="comment">//将PA0引脚初始化为复用推挽输出	</span></span><br><span class="line">																	<span class="comment">//受外设控制的引脚，均需要配置为复用模式		</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*配置时钟源*/</span></span><br><span class="line">	TIM_InternalClockConfig(TIM2);		<span class="comment">//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     </span><br><span class="line">    <span class="comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;					<span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span> - <span class="number">1</span>;				<span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;            <span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);            </span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*输出比较初始化*/</span></span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStructure;							<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStructure);		<span class="comment">//结构体初始化，若结构体没有完整赋值</span></span><br><span class="line">												<span class="comment">//则最好执行此函数，给结构体所有成员都赋一个默认值</span></span><br><span class="line">												<span class="comment">//避免结构体初值不确定的问题</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;				<span class="comment">//输出比较模式，选择PWM模式1</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;		</span><br><span class="line">    <span class="comment">//输出极性，选择为高，若选择极性为低，则输出高低电平取反</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;	<span class="comment">//输出使能</span></span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;								<span class="comment">//初始的CCR值</span></span><br><span class="line">	TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);						</span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM使能*/</span></span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);			<span class="comment">//使能TIM2，定时器开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：PWM设置CCR</span></span><br><span class="line"><span class="comment">  * 参    数：Compare 要写入的CCR的值，范围：0~100</span></span><br><span class="line"><span class="comment">  * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比</span></span><br><span class="line"><span class="comment">  *          占空比Duty = CCR / (ARR + 1)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare1</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare1(TIM2, Compare);		<span class="comment">//设置CCR1的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">uint8_t</span> i;			<span class="comment">//定义for循环的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	PWM_Init();			<span class="comment">//PWM初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			PWM_SetCompare1(i);			<span class="comment">//依次将定时器的CCR寄存器设置为0~100，PWM占空比逐渐增大，LED逐渐变亮</span></span><br><span class="line">			Delay_ms(<span class="number">10</span>);				<span class="comment">//延时10ms</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			PWM_SetCompare1(<span class="number">100</span> - i);	<span class="comment">//依次将定时器的CCR寄存器设置为100~0，PWM占空比逐渐减小，LED逐渐变暗</span></span><br><span class="line">			Delay_ms(<span class="number">10</span>);				<span class="comment">//延时10ms</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此节UP还讲了 引脚复用 P16 30Min（没记）</p>
<h2 id="PWM-驱动舵机"><a href="#PWM-驱动舵机" class="headerlink" title="PWM 驱动舵机"></a>PWM 驱动舵机</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424123639218.png" alt="image-20240424123639218"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			<span class="comment">//开启TIM2的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="comment">//将PA1引脚初始化为复用推挽输出	</span></span><br><span class="line">																	<span class="comment">//受外设控制的引脚，均需要配置为复用模式</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*配置时钟源*/</span></span><br><span class="line">	TIM_InternalClockConfig(TIM2);		<span class="comment">//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     </span><br><span class="line">    <span class="comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">20000</span> - <span class="number">1</span>;				<span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;				<span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;            <span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);             </span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*输出比较初始化*/</span> </span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStructure;							<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStructure);                         <span class="comment">//结构体初始化，若结构体没有完整赋值</span></span><br><span class="line">	               <span class="comment">//则最好执行此函数，给结构体所有成员都赋一个默认值</span></span><br><span class="line">	               <span class="comment">//避免结构体初值不确定的问题</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;               <span class="comment">//输出比较模式，选择PWM模式1</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;       </span><br><span class="line">    <span class="comment">//输出极性，选择为高，若选择极性为低，则输出高低电平取反</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;   <span class="comment">//输出使能</span></span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;								<span class="comment">//初始的CCR值</span></span><br><span class="line">	TIM_OC2Init(TIM2, &amp;TIM_OCInitStructure);                       </span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_OC2Init，配置TIM2的输出比较通道2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM使能*/</span></span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);			<span class="comment">//使能TIM2，定时器开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：PWM设置CCR</span></span><br><span class="line"><span class="comment">  * 参    数：Compare 要写入的CCR的值，范围：0~100</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare2</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare2(TIM2, Compare);		<span class="comment">//设置CCR2的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servo.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	PWM_Init();			<span class="comment">//初始化舵机的底层PWM</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：舵机设置角度</span></span><br><span class="line"><span class="comment">  * 参    数：Angle 要设置的舵机角度，范围：0~180</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span></span><br><span class="line">&#123;</span><br><span class="line">	PWM_SetCompare2(Angle / <span class="number">180</span> * <span class="number">2000</span> + <span class="number">500</span>);	<span class="comment">//设置占空比</span></span><br><span class="line">												<span class="comment">//将角度线性变换，对应到舵机要求的占空比范围上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;		</span><br><span class="line"><span class="type">float</span> Angle;			<span class="comment">//定义角度变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	Servo_Init();		<span class="comment">//舵机初始化</span></span><br><span class="line">	Key_Init();			<span class="comment">//按键初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Angle:&quot;</span>);	<span class="comment">//1行1列显示字符串Angle:</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KeyNum = Key_GetNum();			<span class="comment">//获取按键键码</span></span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">1</span>)				<span class="comment">//按键1按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			Angle += <span class="number">30</span>;				<span class="comment">//角度变量自增30</span></span><br><span class="line">			<span class="keyword">if</span> (Angle &gt; <span class="number">180</span>)			<span class="comment">//角度变量超过180后</span></span><br><span class="line">			&#123;</span><br><span class="line">				Angle = <span class="number">0</span>;				<span class="comment">//角度变量归零</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Servo_SetAngle(Angle);			<span class="comment">//设置舵机的角度为角度变量</span></span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">7</span>, Angle, <span class="number">3</span>);	<span class="comment">//OLED显示角度变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PWM-驱动直流电机"><a href="#PWM-驱动直流电机" class="headerlink" title="PWM 驱动直流电机"></a>PWM 驱动直流电机</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424125625732.png" alt="image-20240424125625732"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PWM.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			<span class="comment">//开启TIM2的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="comment">//将PA2引脚初始化为复用推挽输出	</span></span><br><span class="line">																	</span><br><span class="line">	<span class="comment">/*配置时钟源*/</span></span><br><span class="line">	TIM_InternalClockConfig(TIM2);		<span class="comment">//选择TIM2为内部时钟</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="comment">//时钟分频，选择不分频</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;                 <span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">36</span> - <span class="number">1</span>;               <span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;            <span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);             </span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*输出比较初始化*/</span> </span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStructure;							<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStructure);                         <span class="comment">//结构体初始化，给结构体所有成员都赋一个默认值</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;               <span class="comment">//输出比较模式，选择PWM模式1</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;       <span class="comment">//输出极性，选择为高</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;   <span class="comment">//输出使能</span></span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;								<span class="comment">//初始的CCR值</span></span><br><span class="line">	TIM_OC3Init(TIM2, &amp;TIM_OCInitStructure);                       </span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_OC3Init，配置TIM2的输出比较通道3</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM使能*/</span></span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);			<span class="comment">//使能TIM2，定时器开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare3</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare3(TIM2, Compare);		<span class="comment">//设置CCR3的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Motor.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PWM_Init();													<span class="comment">//初始化直流电机的底层PWM</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*初始化 电机驱动的 方向控制（正/反转）的两个引脚*/</span></span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);		<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);						<span class="comment">//将PA4和PA5引脚初始化为推挽输出	</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：直流电机设置速度</span></span><br><span class="line"><span class="comment">  * 参    数：Speed 要设置的速度，范围：-100~100</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_SetSpeed</span><span class="params">(<span class="type">int8_t</span> Speed)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Speed &gt;= <span class="number">0</span>)							<span class="comment">//如果设置正转的速度值</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOA, GPIO_Pin_4);	<span class="comment">//PA4置高电平</span></span><br><span class="line">		GPIO_ResetBits(GPIOA, GPIO_Pin_5);	<span class="comment">//PA5置低电平，设置方向为正转</span></span><br><span class="line">		PWM_SetCompare3(Speed);				<span class="comment">//PWM设置为速度值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>									<span class="comment">//否则，即设置反转的速度值</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOA, GPIO_Pin_4);	<span class="comment">//PA4置低电平</span></span><br><span class="line">		GPIO_SetBits(GPIOA, GPIO_Pin_5);	<span class="comment">//PA5置高电平，设置方向为反转</span></span><br><span class="line">		PWM_SetCompare3(-Speed);			<span class="comment">//PWM设置为负的速度值，因为此时速度值为负数，而PWM只能给正数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;		<span class="comment">//定义用于接收按键键码的变量</span></span><br><span class="line"><span class="type">int8_t</span> Speed;		<span class="comment">//定义速度变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	Motor_Init();		<span class="comment">//直流电机初始化</span></span><br><span class="line">	Key_Init();			<span class="comment">//按键初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Speed:&quot;</span>);		<span class="comment">//1行1列显示字符串Speed:</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KeyNum = Key_GetNum();				<span class="comment">//获取按键键码</span></span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">1</span>)					<span class="comment">//按键1按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			Speed += <span class="number">20</span>;					<span class="comment">//速度变量自增20</span></span><br><span class="line">			<span class="keyword">if</span> (Speed &gt; <span class="number">100</span>)				<span class="comment">//速度变量超过100后</span></span><br><span class="line">			&#123;</span><br><span class="line">				Speed = <span class="number">-100</span>;				<span class="comment">//速度变量变为-100</span></span><br><span class="line">											<span class="comment">//此操作会让电机旋转方向突然改变，可能会因供电不足而导致单片机复位</span></span><br><span class="line">											<span class="comment">//若出现了此现象，则应避免使用这样的操作</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Motor_SetSpeed(Speed);				<span class="comment">//设置直流电机的速度为速度变量</span></span><br><span class="line">		OLED_ShowSignedNum(<span class="number">1</span>, <span class="number">7</span>, Speed, <span class="number">3</span>);	<span class="comment">//OLED显示速度变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="TIM输入捕获（IC）"><a href="#TIM输入捕获（IC）" class="headerlink" title="TIM输入捕获（IC）"></a>TIM输入捕获（IC）</h2><ul>
<li>对于同一个定时器 输入捕获 和 输出比较 只能用一个 不能同时使用</li>
<li>输入捕获模式下，当通道输入引脚出现指定<strong>电平跳变</strong>时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数</li>
<li>每个高级定时器和通用定时器都拥有4个输入捕获通道(如图)</li>
<li>可配置为PWMI模式（<strong>PWM输入模式</strong>），同时测量频率和占空比</li>
<li>可配合主从触发模式，实现硬件全自动测量（需要测量的时候，直接读取RCC寄存器即可）</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424181523055.png" alt="image-20240424181523055" style="zoom:150%;" />



<p>主从触发模式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424182022272.png" alt="image-20240424182022272"></p>
<ul>
<li>主模式：将定时器 内部的信号 ，映射到TRGO 引脚 ，用于触发其他外设</li>
<li>从模式：接收 其他外设 或者 自身外设 的信号，用于控制自身 定时器的运行</li>
<li>触发源选择：选择 从模式 的触发 信号源</li>
</ul>
<h3 id="测量频率的几种方法"><a href="#测量频率的几种方法" class="headerlink" title="测量频率的几种方法"></a>测量频率的几种方法</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424175158358.png" alt="image-20240424175158358"></p>
<p>当待测信号频率小于中界频率时，测周法误差更小</p>
<p>当待测信号频率大于中界频率时，测频法误差更小</p>
<h3 id="输入捕获模式测频率"><a href="#输入捕获模式测频率" class="headerlink" title="输入捕获模式测频率"></a>输入捕获模式测频率</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425131618033.png" alt="image-20240425131618033"></p>
<ul>
<li><em>CNT</em> 计数器 自增 ，上升沿触发清零 <strong>之前</strong> ，<em>把数据传给CCR1</em></li>
<li>GPIO口 输入 左上角的方波信号</li>
<li>选择TI1FP1 为上升沿 触发</li>
<li>计算频率 &#x3D; Fc &#x2F; [CCR1–&gt;N]</li>
</ul>
<h4 id="IC-输入捕获-的-初始化"><a href="#IC-输入捕获-的-初始化" class="headerlink" title="IC(输入捕获 的 初始化)"></a>IC(输入捕获 的 初始化)</h4><ul>
<li>RCC 开启 时钟 ，把 GPIO 和 TIM 时钟打开</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);			<span class="comment">//开启TIM3的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="comment">//开启GPIOA的时钟</span></span><br></pre></td></tr></table></figure>

<ul>
<li>GPIO 初始化 ，把GPIO 配置成输入模式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="comment">//将PA6引脚初始化为上拉输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置时钟源*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM3);		<span class="comment">//选择TIM3为内部时钟</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置 时基 单元</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="comment">//时钟分频，选择不分频</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;               <span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;               <span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;            <span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);            </span><br><span class="line"><span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<ul>
<li>配置 输入捕获单元（结构体统一配置）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;							<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				<span class="comment">//选择配置定时器通道1</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;							<span class="comment">//输入滤波器参数，可以过滤信号抖动</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		<span class="comment">//极性，选择为上升沿触发捕获</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			<span class="comment">//捕获预分频，选择不分频，每次信号都触发捕获</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;	<span class="comment">//输入信号交叉，选择直通，不交叉</span></span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);							</span><br><span class="line"><span class="comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span></span><br></pre></td></tr></table></figure>

<ul>
<li>选择 从模式为触发源（TI1FP1）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);					<span class="comment">//触发源选择TI1FP1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>选择 触发后 执行的操作（配置从模式）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);					<span class="comment">//从模式选择复位</span></span><br><span class="line">																<span class="comment">//即TI1产生上升沿时，会触发CNT归零</span></span><br></pre></td></tr></table></figure>

<ul>
<li>开启定时器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_Cmd(TIM3, ENABLE);			<span class="comment">//使能TIM3，定时器开始运行</span></span><br></pre></td></tr></table></figure>



<h4 id="以PWM作为信号源，输入捕获测试频率"><a href="#以PWM作为信号源，输入捕获测试频率" class="headerlink" title="以PWM作为信号源，输入捕获测试频率"></a>以PWM作为信号源，输入捕获测试频率</h4><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240424173652102.png" alt="image-20240424173652102"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PWM.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			<span class="comment">//开启TIM2的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;		<span class="comment">//GPIO_Pin_15;</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="comment">//将PA0引脚初始化为复用推挽输出	</span></span><br><span class="line">																	<span class="comment">//受外设控制的引脚，均需要配置为复用模式		</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*配置时钟源*/</span></span><br><span class="line">	TIM_InternalClockConfig(TIM2);		<span class="comment">//选择TIM2为内部时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="comment">//时钟分频，选择不分频</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;					<span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span> - <span class="number">1</span>;				<span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;            <span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);            </span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*输出比较初始化*/</span></span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStructure;							<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStructure);							<span class="comment">//结构体初始化</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;				<span class="comment">//输出比较模式，选择PWM模式1</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;		<span class="comment">//输出极性，选择为高</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;	<span class="comment">//输出使能</span></span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;								<span class="comment">//初始的CCR值</span></span><br><span class="line">	TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);						</span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM使能*/</span></span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);			<span class="comment">//使能TIM2，定时器开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//占空比Duty = CCR / (ARR + 1)</span></span><br><span class="line"><span class="comment">//通过 改变 CCR 的值 来 改变 频率</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare1</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare1(TIM2, Compare);		<span class="comment">//设置CCR1的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//频率Freq = CK_PSC / (PSC + 1) / (ARR + 1)</span></span><br><span class="line"> <span class="comment">//通过 改变PSC的值 来 改变 频率</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetPrescaler</span><span class="params">(<span class="type">uint16_t</span> Prescaler)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_PrescalerConfig(TIM2, Prescaler, TIM_PSCReloadMode_Immediate);		<span class="comment">//设置PSC的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	PWM_Init();			<span class="comment">//PWM初始化</span></span><br><span class="line">	IC_Init();			<span class="comment">//输入捕获初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Freq:00000Hz&quot;</span>);		<span class="comment">//1行1列显示字符串Freq:00000Hz</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*使用PWM模块提供输入捕获的测试信号*/</span></span><br><span class="line">	PWM_SetPrescaler(<span class="number">720</span> - <span class="number">1</span>);					<span class="comment">//PWM频率Freq = 72M / (PSC + 1) / 100</span></span><br><span class="line">	PWM_SetCompare1(<span class="number">50</span>);						<span class="comment">//PWM占空比Duty = CCR / 100</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, IC_GetFreq(), <span class="number">5</span>);	<span class="comment">//不断刷新显示输入捕获测得的频率</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IC 输入捕获</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);			<span class="comment">//开启TIM3的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="comment">//将PA6引脚初始化为上拉输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*配置时钟源*/</span></span><br><span class="line">	TIM_InternalClockConfig(TIM3);		<span class="comment">//选择TIM3为内部时钟，若不调用此函数，TIM默认也为内部时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;               <span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;               <span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;            <span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);             <span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*输入捕获初始化*/</span></span><br><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;							<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				<span class="comment">//选择配置定时器通道1</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;							<span class="comment">//输入滤波器参数，可以过滤信号抖动</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		<span class="comment">//极性，选择为上升沿触发捕获</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			<span class="comment">//捕获预分频，选择不分频，每次信号都触发捕获</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;	<span class="comment">//输入信号交叉，选择直通，不交叉</span></span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);							<span class="comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*选择触发源及从模式*/</span></span><br><span class="line">	TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);					<span class="comment">//触发源选择TI1FP1</span></span><br><span class="line">	TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);					<span class="comment">//从模式选择复位</span></span><br><span class="line">																	<span class="comment">//即TI1产生上升沿时，会触发CNT归零</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM使能*/</span></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);			<span class="comment">//使能TIM3，定时器开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取输入捕获的频率</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：捕获得到的频率</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);		<span class="comment">//测周法得到频率fx = fc / N，这里不执行+1的操作也可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="PWMI模式测频率占空比"><a href="#PWMI模式测频率占空比" class="headerlink" title="PWMI模式测频率占空比"></a>PWMI模式测频率占空比</h3><ul>
<li>PWMI模式 既可以 测量频率 又可以 测占空比</li>
<li>上半部分和 <em>输入捕获模式测频率</em>  一样</li>
<li>选择TI1FP1 为上升沿 触发 ，<em>触发上升沿</em>  时  CNT <strong>清零     ，之前 ，</strong>CNT 把数据传给CCR1</li>
<li>选择TI1FP2 为下降沿 触发 ，<em>触发下降沿</em>  时 CCR2 &#x3D; CNT</li>
<li>CCR2 &#x2F; CCR1  即为占空比</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);			<span class="comment">//开启TIM3的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="comment">//将PA6引脚初始化为上拉输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*配置时钟源*/</span></span><br><span class="line">	TIM_InternalClockConfig(TIM3);		<span class="comment">//选择TIM3为内部时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="comment">//时钟分频，选择不分频</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;               <span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;               <span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;            <span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);             </span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*PWMI模式初始化*/</span></span><br><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;							<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				<span class="comment">//选择配置定时器通道1</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;							<span class="comment">//输入滤波器参数，可以过滤信号抖动</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		<span class="comment">//极性，选择为上升沿触发捕获</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			<span class="comment">//捕获预分频，选择不分频，每次信号都触发捕获</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;	<span class="comment">//输入信号交叉，选择直通，不交叉</span></span><br><span class="line">	TIM_PWMIConfig(TIM3, &amp;TIM_ICInitStructure);				</span><br><span class="line">	<span class="comment">//此函数同时会把另一个通道配置为相反的配置，实现PWMI模式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*选择触发源及从模式*/</span></span><br><span class="line">	TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);					<span class="comment">//触发源选择TI1FP1</span></span><br><span class="line">	TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);					<span class="comment">//从模式选择复位</span></span><br><span class="line">																	<span class="comment">//即TI1产生上升沿时，会触发CNT归零</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM使能*/</span></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);			<span class="comment">//使能TIM3，定时器开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);		<span class="comment">//测周法得到频率fx = fc / N</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取输入捕获的占空比</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetDuty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (TIM_GetCapture2(TIM3) + <span class="number">1</span>) * <span class="number">100</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);	</span><br><span class="line">    <span class="comment">//占空比Duty = CCR2 / CCR1 * 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	PWM_Init();			<span class="comment">//PWM初始化</span></span><br><span class="line">	IC_Init();			<span class="comment">//输入捕获初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Freq:00000Hz&quot;</span>);		<span class="comment">//1行1列显示字符串Freq:00000Hz</span></span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Duty:00%&quot;</span>);			<span class="comment">//2行1列显示字符串Duty:00%</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*使用PWM模块提供输入捕获的测试信号*/</span></span><br><span class="line">	PWM_SetPrescaler(<span class="number">720</span> - <span class="number">1</span>);					<span class="comment">//PWM频率Freq = 72M / (PSC + 1) / 100</span></span><br><span class="line">	PWM_SetCompare1(<span class="number">50</span>);						<span class="comment">//PWM占空比Duty = CCR / 100</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, IC_GetFreq(), <span class="number">5</span>);	<span class="comment">//不断刷新显示输入捕获测得的频率</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, IC_GetDuty(), <span class="number">2</span>);	<span class="comment">//不断刷新显示输入捕获测得的占空比</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TIM编码器接口"><a href="#TIM编码器接口" class="headerlink" title="TIM编码器接口"></a>TIM编码器接口</h2><p>用过定时器的编码接口，实现 旋转编码器（旋钮） 测速（不计次）</p>
<p>应用场景：电机控制（测量电机 的旋转速度）</p>
<h3 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h3><ul>
<li>编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</li>
<li>每个高级定时器和通用定时器都拥有1个编码器接口</li>
<li>如果一个定时器 配置成了 编码器接口模式，那么这个定时器一般就干不了其他的事情了（一共就四个定时器）</li>
<li>如果硬件资源不够，可以用 软件资源弥补（用 外部中断 实现）</li>
<li>两个输入引脚借用了输入捕获的通道1和通道2（TI1FP1和TIFP2）</li>
</ul>
<p><strong>基本结构</strong></p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425140042547.png" alt="image-20240425140042547" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425140111015.png" alt="image-20240425140111015" style="zoom:80%;" />



<h3 id="正交编码器"><a href="#正交编码器" class="headerlink" title="正交编码器"></a>正交编码器</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425134501762.png" alt="image-20240425134501762"></p>
<ul>
<li>当编码器旋转时 ，A相 和 B相 会输出方波信号</li>
<li>转的越快，方波的频率越高</li>
<li>当正转时，A相 提前 B相 90度<ul>
<li>​    反转时，A相 滞后 B相 90度</li>
</ul>
</li>
</ul>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ul>
<li>RCC 开启时钟</li>
<li>配置GPIO </li>
<li>配置 时基单元</li>
<li>配置 输入捕获单元</li>
<li>配置 编码器接口模式</li>
<li>启动 定时器</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425141057721.png" alt="image-20240425141057721"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Encoder.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);			<span class="comment">//开启TIM3的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="comment">//将PA6和PA7引脚初始化为上拉输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*时基单元初始化*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="comment">//时钟分频，选择不分频</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//计数器模式，选择向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;               <span class="comment">//计数周期，即ARR的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>;                <span class="comment">//预分频器，即PSC的值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;            <span class="comment">//重复计数器，高级定时器才会用到</span></span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);             </span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*输入捕获初始化*/</span></span><br><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;							<span class="comment">//定义结构体变量</span></span><br><span class="line">	TIM_ICStructInit(&amp;TIM_ICInitStructure);							<span class="comment">//结构体初始化</span></span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				<span class="comment">//选择配置定时器通道1</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;							<span class="comment">//输入滤波器参数，可以过滤信号抖动</span></span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);							</span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span></span><br><span class="line">    </span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;				<span class="comment">//选择配置定时器通道2</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;							<span class="comment">//输入滤波器参数，可以过滤信号抖动</span></span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);							</span><br><span class="line">    <span class="comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span></span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*编码器接口配置*/</span></span><br><span class="line">	TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);</span><br><span class="line">																	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM使能*/</span></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);			<span class="comment">//使能TIM3，定时器开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取编码器的增量值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*使用Temp变量作为中继，目的是返回CNT后将其清零*/</span></span><br><span class="line">	<span class="type">int16_t</span> Temp;</span><br><span class="line">	Temp = TIM_GetCounter(TIM3);</span><br><span class="line">	TIM_SetCounter(TIM3, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">int16_t</span> Speed;			<span class="comment">//定义速度变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	Timer_Init();		<span class="comment">//定时器初始化</span></span><br><span class="line">	Encoder_Init();		<span class="comment">//编码器初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Speed:&quot;</span>);		<span class="comment">//1行1列显示字符串Speed:</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">1</span>, <span class="number">7</span>, Speed, <span class="number">5</span>);	<span class="comment">//不断刷新显示编码器测得的最新速度</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TIM2中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)		<span class="comment">//判断是否是TIM2的更新事件触发的中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		Speed = Encoder_Get();								<span class="comment">//每隔固定时间段读取一次编码器计数增量值，即为速度值</span></span><br><span class="line">		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);			<span class="comment">//清除TIM2更新事件的中断标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第七章：ADC模数转换器"><a href="#第七章：ADC模数转换器" class="headerlink" title="第七章：ADC模数转换器"></a>第七章：ADC模数转换器</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>ADC可以将引脚上连续变化的<strong>模拟电压 <strong>转换 为内存中存储的</strong>数字变量</strong>，建立模拟电路到数字电路的桥梁</p>
<p>输入电压范围：0<del>3.3V，转换结果范围：0</del>4095<br>18个输入通道，可测量16个外部和2个内部信号源( 内部温度传感器 和 内部参考电压 )<br>模拟看门狗自动监测输入电压范围（阈值监测）</p>
<p>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425151506773.png" alt="image-20240425151506773"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425151749337.png" alt="image-20240425151749337"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425152145297.png" alt="image-20240425152145297"></p>
<h3 id="规则组的转换模式"><a href="#规则组的转换模式" class="headerlink" title="规则组的转换模式"></a>规则组的转换模式</h3><p>不同的模式，对应着不同的读取AD的方法 </p>
<ul>
<li>单次转换，非扫描模式 </li>
<li>连续转换，非扫描模式</li>
<li>单次转换，扫描模式</li>
<li>连续转换，扫描模式</li>
</ul>
<h3 id="触发控制"><a href="#触发控制" class="headerlink" title="触发控制"></a>触发控制</h3><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><h3 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h3><ul>
<li>AD转换 步骤 ：采样，保持，量化，编码</li>
<li>TCONV &#x3D; 采样时间 + 12.5个ADC周期</li>
</ul>
<h3 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h3><h3 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425153812321.png" alt="image-20240425153812321"></p>
<h2 id="AD初始化步骤"><a href="#AD初始化步骤" class="headerlink" title="AD初始化步骤"></a>AD初始化步骤</h2><ul>
<li>开启，配置RCC 时钟</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);	<span class="comment">//开启ADC1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);						<span class="comment">//选择时钟6分频</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置GPIO</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA0引脚初始化为模拟输入</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置多路开关</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);		</span><br><span class="line"><span class="comment">//规则组序列1的位置，配置为通道0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置ADC，初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitTypeDef ADC_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;		<span class="comment">//工作模式，选择独立模式，即单独使用ADC1</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;	<span class="comment">//数据对齐，选择右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	<span class="comment">//外部触发，使用软件触发，不需要外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;		<span class="comment">//连续转换，失能，每转换一次规则组序列后停止</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = DISABLE;			<span class="comment">//扫描模式，失能，只转换规则组的序列1这一个位置</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;					</span><br><span class="line"><span class="comment">//通道数，为1，仅在扫描模式下，才需要指定大于1的数，在非扫描模式下，只能是1</span></span><br><span class="line">ADC_Init(ADC1, &amp;ADC_InitStructure);						<span class="comment">//将结构体变量交给ADC_Init，配置ADC1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>AD开关控制，AD校准</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ADC_Cmd(ADC1, ENABLE);	                                <span class="comment">//AD 使能</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);								<span class="comment">//固定流程，内部有电路会自动执行校准</span></span><br><span class="line"><span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="AD单通道-电位器"><a href="#AD单通道-电位器" class="headerlink" title="AD单通道(电位器)"></a>AD单通道(电位器)</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425154223350.png" alt="image-20240425154223350"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ad_init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);	<span class="comment">//开启ADC1的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*设置ADC时钟*/</span></span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);						<span class="comment">//选择时钟6分频，ADCCLK = 72MHz / 6 = 12MHz</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA0引脚初始化为模拟输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*规则组通道配置*/</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);		<span class="comment">//规则组序列1的位置，配置为通道0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*ADC初始化*/</span></span><br><span class="line">	ADC_InitTypeDef ADC_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;		<span class="comment">//模式，选择独立模式，即单独使用ADC1</span></span><br><span class="line">	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;	<span class="comment">//数据对齐，选择右对齐</span></span><br><span class="line">	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	<span class="comment">//外部触发，使用软件触发，不需要外部触发</span></span><br><span class="line">	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;		<span class="comment">//连续转换，失能，每转换一次规则组序列后停止</span></span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = DISABLE;			<span class="comment">//扫描模式，失能，只转换规则组的序列1这一个位置</span></span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;					<span class="comment">//通道数，为1，仅在扫描模式下，才需要指定大于1的数，在非扫描模式下，只能是1</span></span><br><span class="line">	ADC_Init(ADC1, &amp;ADC_InitStructure);						<span class="comment">//将结构体变量交给ADC_Init，配置ADC1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*ADC使能*/</span></span><br><span class="line">	ADC_Cmd(ADC1, ENABLE);									<span class="comment">//使能ADC1，ADC开始运行</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*ADC校准*/</span></span><br><span class="line">	ADC_ResetCalibration(ADC1);								<span class="comment">//固定流程，内部有电路会自动执行校准</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取AD转换的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;  <span class="comment">//单次转换 ， 非扫描</span></span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);					<span class="comment">//软件触发AD转换一次</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);	<span class="comment">//等待EOC标志位，即等待AD转换结束</span></span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);					<span class="comment">//读数据寄存器，得到AD转换的结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">uint16_t</span> ADValue;			<span class="comment">//定义AD值变量</span></span><br><span class="line"><span class="type">float</span> Voltage;				<span class="comment">//定义电压变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();			<span class="comment">//OLED初始化</span></span><br><span class="line">	AD_Init();				<span class="comment">//AD初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;ADValue:&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Voltage:0.00V&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ADValue = AD_GetValue();					<span class="comment">//获取AD转换的值</span></span><br><span class="line">		Voltage = (<span class="type">float</span>)ADValue / <span class="number">4095</span> * <span class="number">3.3</span>;		<span class="comment">//将AD值线性变换到0~3.3的范围，表示电压</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">9</span>, ADValue, <span class="number">4</span>);				<span class="comment">//显示AD值</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">9</span>, Voltage, <span class="number">1</span>);				<span class="comment">//显示电压值的整数部分</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">11</span>, (<span class="type">uint16_t</span>)(Voltage * <span class="number">100</span>) % <span class="number">100</span>, <span class="number">2</span>);	<span class="comment">//显示电压值的小数部分</span></span><br><span class="line">		</span><br><span class="line">		Delay_ms(<span class="number">100</span>);			<span class="comment">//延时100ms，手动增加一些转换的间隔时间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要设置阈值，但是获取的AD值抖动，AD值在阈值附近来回跳动解决办法：</p>
<p>1，读多个AD值，取平均</p>
<p>2，设上阈值和下阈值，不要只设一个阈值</p>
<h2 id="AD多通道"><a href="#AD多通道" class="headerlink" title="AD多通道"></a>AD多通道</h2><p>电位器，光敏传感器，热敏传感器，反射式红外传感器</p>
<ul>
<li>单次转换，非扫描 的形式实现AD多通道：<ul>
<li>每次转换时，改变通道后，然后再触发，等待，读值</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 写AD读取函数时，传入需要 读取ad值 的通道编号</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240425155245130.png" alt="image-20240425155245130"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ad_init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);	<span class="comment">//开启ADC1的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*设置ADC时钟*/</span></span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);						<span class="comment">//选择时钟6分频，ADCCLK = 72MHz / 6 = 12MHz</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA0、PA1、PA2和PA3引脚初始化为模拟输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*不在此处配置规则组序列，而是在每次AD转换前配置，这样可以灵活更改AD转换的通道*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*ADC初始化*/</span></span><br><span class="line">	ADC_InitTypeDef ADC_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;		<span class="comment">//模式，选择独立模式，即单独使用ADC1</span></span><br><span class="line">	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;	<span class="comment">//数据对齐，选择右对齐</span></span><br><span class="line">	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	<span class="comment">//外部触发，使用软件触发，不需要外部触发</span></span><br><span class="line">	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;		<span class="comment">//连续转换，失能，每转换一次规则组序列后停止</span></span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = DISABLE;			<span class="comment">//扫描模式，失能，只转换规则组的序列1这一个位置</span></span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;					</span><br><span class="line">    <span class="comment">//通道数，为1，仅在扫描模式下，才需要指定大于1的数，在非扫描模式下，只能是1</span></span><br><span class="line">	ADC_Init(ADC1, &amp;ADC_InitStructure);						<span class="comment">//将结构体变量交给ADC_Init，配置ADC1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*ADC使能*/</span></span><br><span class="line">	ADC_Cmd(ADC1, ENABLE);									<span class="comment">//使能ADC1，ADC开始运行</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*ADC校准*/</span></span><br><span class="line">	ADC_ResetCalibration(ADC1);								<span class="comment">//固定流程，内部有电路会自动执行校准</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取AD转换的值</span></span><br><span class="line"><span class="comment">  * 参    数：ADC_Channel 指定AD转换的通道，范围：ADC_Channel_x，其中x可以是0/1/2/3</span></span><br><span class="line"><span class="comment">  * 返 回 值：AD转换的值，范围：0~4095</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">uint8_t</span> ADC_Channel)</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel, <span class="number">1</span>, ADC_SampleTime_55Cycles5);	</span><br><span class="line">    <span class="comment">//在每次转换前，根据函数形参灵活更改规则组的通道1</span></span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);					<span class="comment">//软件触发AD转换一次</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);	<span class="comment">//等待EOC标志位，即等待AD转换结束</span></span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);					<span class="comment">//读数据寄存器，得到AD转换的结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">uint16_t</span> AD0, AD1, AD2, AD3;	<span class="comment">//定义AD值变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();				<span class="comment">//OLED初始化</span></span><br><span class="line">	AD_Init();					<span class="comment">//AD初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;AD0:&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;AD1:&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;AD2:&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;AD3:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AD0 = AD_GetValue(ADC_Channel_0);		<span class="comment">//单次启动ADC，转换通道0</span></span><br><span class="line">		AD1 = AD_GetValue(ADC_Channel_1);		<span class="comment">//单次启动ADC，转换通道1</span></span><br><span class="line">		AD2 = AD_GetValue(ADC_Channel_2);		<span class="comment">//单次启动ADC，转换通道2</span></span><br><span class="line">		AD3 = AD_GetValue(ADC_Channel_3);		<span class="comment">//单次启动ADC，转换通道3</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">5</span>, AD0, <span class="number">4</span>);				<span class="comment">//显示通道0的转换结果AD0</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">5</span>, AD1, <span class="number">4</span>);				<span class="comment">//显示通道1的转换结果AD1</span></span><br><span class="line">		OLED_ShowNum(<span class="number">3</span>, <span class="number">5</span>, AD2, <span class="number">4</span>);				<span class="comment">//显示通道2的转换结果AD2</span></span><br><span class="line">		OLED_ShowNum(<span class="number">4</span>, <span class="number">5</span>, AD3, <span class="number">4</span>);				<span class="comment">//显示通道3的转换结果AD3</span></span><br><span class="line">		</span><br><span class="line">		Delay_ms(<span class="number">100</span>);			<span class="comment">//延时100ms，手动增加一些转换的间隔时间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第八章：DMA直接存储器存取（搬数据）"><a href="#第八章：DMA直接存储器存取（搬数据）" class="headerlink" title="第八章：DMA直接存储器存取（搬数据）"></a>第八章：DMA直接存储器存取（搬数据）</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>DMA可以直接访问STM32 内部的存储器：运行内存SRAM（存变量，数组），程序存储器Flash，寄存器等。</p>
<blockquote>
<p>寄存器：特殊的存储器</p>
<p>1.CPU 对寄存器进行读写</p>
<p>2.寄存器 后有一根导线 与其相连</p>
<p>​	控制外设电路的状态：引脚的高低电平，导通和断开开关，切换数据选择器等											</p>
</blockquote>
<p>DMA可以提供外设（外设存储器）和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源</p>
<p>12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）<br>每个通道都支持软件触发和特定的硬件触发</p>
<p>外设到存储器数据转运，用硬件触发；</p>
<p>存储器到存储器数据转运，用软件触发；</p>
<p>STM32F103C8T6 DMA资源：只有 DMA1（7个通道）</p>
<h2 id="存储器映像"><a href="#存储器映像" class="headerlink" title="存储器映像"></a>存储器映像</h2><p>（运算器，控制器）CPU，存储器，输入设备，输出设备</p>
<p>存储器—&gt;存储器内容+存储器地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507103320957.png" alt="image-20240507103320957"></p>
<p>ROM：只读存储器，非易失，掉电不丢失</p>
<p>RAM：随机存储器，易失，掉电丢失</p>
<h2 id="DMA-框图，结构图"><a href="#DMA-框图，结构图" class="headerlink" title="DMA 框图，结构图"></a>DMA 框图，结构图</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507104834480.png" alt="image-20240507104834480"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507105821854.png" alt="image-20240507105821854"></p>
<h2 id="数据宽度对齐"><a href="#数据宽度对齐" class="headerlink" title="数据宽度对齐"></a>数据宽度对齐</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507110709893.png" alt="image-20240507110709893"></p>
<p>如果把小的数据转到大的里面去，高位补0</p>
<p>如果把大的数据转到小的里面去，高位舍弃</p>
<h2 id="DMA初始化步骤"><a href="#DMA初始化步骤" class="headerlink" title="DMA初始化步骤"></a>DMA初始化步骤</h2><ul>
<li>RCC 开启DMA 时钟</li>
<li>调用DMA_init 初始化参数：起始地址，数据宽度，地址是否自增等</li>
<li>开关控制DMA_Cmd</li>
<li>15min 中断</li>
</ul>
<h2 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运 + DMA"></a>数据转运 + DMA</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507110933873.png" alt="image-20240507110933873"></p>
<p>将SRAM 里的数组DataA ，转运到另一个数组DataB中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">mydma.c</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;		</span><br><span class="line"><span class="comment">//定义全局变量，用于记住Init函数的Size，供Transfer函数使用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 参    数：AddrA 原数组的首地址</span></span><br><span class="line"><span class="comment">  * 参    数：AddrB 目的数组的首地址</span></span><br><span class="line"><span class="comment">  * 参    数：Size 转运的数据大小（转运次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA, <span class="type">uint32_t</span> AddrB, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyDMA_Size = Size;					</span><br><span class="line">    <span class="comment">//将Size写入到全局变量，记住参数Size</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);		<span class="comment">//开启DMA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*DMA初始化*/</span></span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;										<span class="comment">//定义结构体变量</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA;						<span class="comment">//外设基地址，给定形参AddrA</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;	<span class="comment">//外设数据宽度，选择字节</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;			<span class="comment">//外设地址自增，选择使能</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = AddrB;							<span class="comment">//存储器基地址，给定形参AddrB</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;			<span class="comment">//存储器数据宽度，选择字节</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;					<span class="comment">//存储器地址自增，选择使能</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;						<span class="comment">//数据传输方向，选择由外设到存储器</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = Size;								<span class="comment">//转运的数据大小（转运次数）</span></span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;							<span class="comment">//模式，是否自动重装(转运一次停下来)</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;								<span class="comment">//存储器到存储器，选择使能</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;					<span class="comment">//优先级，选择中等</span></span><br><span class="line">	DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);							</span><br><span class="line">    <span class="comment">//将结构体变量交给DMA_Init，配置DMA1的通道1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*DMA使能*/</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel1, DISABLE);	<span class="comment">//这里先不给使能，初始化后不会立刻工作，等后续调用Transfer后，再开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函    数：启动DMA数据转运</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1, DISABLE);					<span class="comment">//DMA失能，在写入传输计数器之前，需要DMA暂停工作</span></span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1, MyDMA_Size);	<span class="comment">//写入传输计数器，指定将要转运的次数</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel1, ENABLE);						<span class="comment">//DMA使能，开始工作</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);	<span class="comment">//等待DMA工作完成</span></span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);						<span class="comment">//清除工作完成标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line"><span class="type">uint8_t</span> DataA[] = &#123;<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>&#125;;				<span class="comment">//定义测试数组DataA，为数据源</span></span><br><span class="line"><span class="type">uint8_t</span> DataB[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;							<span class="comment">//定义测试数组DataB，为数据目的地</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();</span><br><span class="line">	MyDMA_Init((<span class="type">uint32_t</span>)DataA, (<span class="type">uint32_t</span>)DataB, <span class="number">4</span>);	<span class="comment">//DMA初始化，把源数组和目的数组的地址传入</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DataA[<span class="number">0</span>] ++;		</span><br><span class="line">		DataA[<span class="number">1</span>] ++;</span><br><span class="line">		DataA[<span class="number">2</span>] ++;</span><br><span class="line">		DataA[<span class="number">3</span>] ++;</span><br><span class="line">		</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">1</span>, DataA[<span class="number">0</span>], <span class="number">2</span>);		<span class="comment">//显示数组DataA</span></span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">4</span>, DataA[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">7</span>, DataA[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">10</span>, DataA[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, DataB[<span class="number">0</span>], <span class="number">2</span>);		<span class="comment">//显示数组DataB</span></span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">4</span>, DataB[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">7</span>, DataB[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">10</span>, DataB[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">		Delay_ms(<span class="number">1000</span>);		<span class="comment">//延时1s，观察转运前的现象</span></span><br><span class="line">		</span><br><span class="line">		MyDMA_Transfer();	<span class="comment">//使用DMA转运数组，从DataA转运到DataB</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">1</span>, DataA[<span class="number">0</span>], <span class="number">2</span>);		<span class="comment">//显示数组DataA</span></span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">4</span>, DataA[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">7</span>, DataA[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">10</span>, DataA[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, DataB[<span class="number">0</span>], <span class="number">2</span>);		<span class="comment">//显示数组DataB</span></span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">4</span>, DataB[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">7</span>, DataB[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">10</span>, DataB[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		Delay_ms(<span class="number">1000</span>);		<span class="comment">//延时1s，观察转运后的现象</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式 + DMA"></a>ADC扫描模式 + DMA</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507111336195.png" alt="image-20240507111336195"></p>
<p>每个通道依次 ADC 转换，数据存到 ADC_DR 数据寄存器</p>
<p>通道 ADC 转换完成后，DMA数据转运，数据从 ADC_DR 转运到 SRAM</p>
<p>ADC 数据覆盖 —–&gt; ADC_DR  只有一个地址（好像）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">4</span>];					<span class="comment">//定义用于存放AD转换结果的全局数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC 转换完成后，DMA 进行数据转运，数据从 ADC_DR 转运到 SRAM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);	<span class="comment">//开启ADC1的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);		<span class="comment">//开启DMA1的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*设置ADC时钟*/</span></span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);						<span class="comment">//选择时钟6分频，ADCCLK = 72MHz / 6 = 12MHz</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA0、PA1、PA2和PA3引脚初始化为模拟输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*规则组通道配置*/</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);	<span class="comment">//规则组序列1的位置，配置为通道0</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, <span class="number">2</span>, ADC_SampleTime_55Cycles5);	<span class="comment">//规则组序列2的位置，配置为通道1</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_2, <span class="number">3</span>, ADC_SampleTime_55Cycles5);	<span class="comment">//规则组序列3的位置，配置为通道2</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_3, <span class="number">4</span>, ADC_SampleTime_55Cycles5);	<span class="comment">//规则组序列4的位置，配置为通道3</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*ADC初始化*/</span></span><br><span class="line">	ADC_InitTypeDef ADC_InitStructure;											<span class="comment">//定义结构体变量</span></span><br><span class="line">	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;							</span><br><span class="line">    <span class="comment">//模式，选择独立模式，即单独使用ADC1</span></span><br><span class="line">	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;						<span class="comment">//数据对齐，选择右对齐</span></span><br><span class="line">	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;			</span><br><span class="line">    <span class="comment">//外部触发，使用软件触发，不需要外部触发</span></span><br><span class="line">	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;							</span><br><span class="line">    <span class="comment">//连续转换，使能，每转换一次规则组序列后立刻开始下一次转换</span></span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = ENABLE;								</span><br><span class="line">    <span class="comment">//扫描模式，使能，扫描规则组的序列，扫描数量由ADC_NbrOfChannel确定</span></span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">4</span>;										</span><br><span class="line">    <span class="comment">//通道数，为4，扫描规则组的前4个通道</span></span><br><span class="line">	ADC_Init(ADC1, &amp;ADC_InitStructure);											</span><br><span class="line">    <span class="comment">//将结构体变量交给ADC_Init，配置ADC1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*DMA初始化*/</span></span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;											<span class="comment">//定义结构体变量</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;				<span class="comment">//外设基地址，给定形参AddrA</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	</span><br><span class="line">    <span class="comment">//外设数据宽度，选择半字，对应16为的ADC数据寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;			</span><br><span class="line">    <span class="comment">//外设地址自增，选择失能，始终以ADC数据寄存器为源</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)AD_Value;					</span><br><span class="line">    <span class="comment">//存储器基地址，给定存放AD转换结果的全局数组AD_Value</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;			</span><br><span class="line">    <span class="comment">//存储器数据宽度，选择半字，与源数据宽度对应</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;						</span><br><span class="line">    <span class="comment">//存储器地址自增，选择使能，每次转运后，数组移到下一个位置</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;							</span><br><span class="line">    <span class="comment">//数据传输方向，选择由外设到存储器，ADC数据寄存器转到数组</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = <span class="number">4</span>;										</span><br><span class="line">    <span class="comment">//转运的数据大小（转运次数），与ADC通道数一致</span></span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;								</span><br><span class="line">    <span class="comment">//模式，选择循环模式，与ADC的连续转换一致</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;								</span><br><span class="line">    <span class="comment">//存储器到存储器，选择失能，数据由ADC外设触发转运到存储器</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;						<span class="comment">//优先级，选择中等</span></span><br><span class="line">	DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);								</span><br><span class="line">    <span class="comment">//将结构体变量交给DMA_Init，配置DMA1的通道1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*DMA和ADC使能*/</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel1, ENABLE);							<span class="comment">//DMA1的通道1使能</span></span><br><span class="line">	ADC_DMACmd(ADC1, ENABLE);								<span class="comment">//ADC1触发DMA1的信号使能</span></span><br><span class="line">	ADC_Cmd(ADC1, ENABLE);									<span class="comment">//ADC1使能</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*ADC校准*/</span></span><br><span class="line">	ADC_ResetCalibration(ADC1);								<span class="comment">//固定流程，内部有电路会自动执行校准</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*ADC触发*/</span></span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);	</span><br><span class="line">    <span class="comment">//软件触发ADC开始工作，由于ADC处于连续转换模式，故触发一次后ADC就可以一直连续不断地工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储器地址，常量和变亮，结构体访问寄存器"><a href="#存储器地址，常量和变亮，结构体访问寄存器" class="headerlink" title="存储器地址，常量和变亮，结构体访问寄存器"></a>存储器地址，常量和变亮，结构体访问寄存器</h2><p>P24课程，开始时，介绍</p>
<h1 id="第九章：USART串口"><a href="#第九章：USART串口" class="headerlink" title="第九章：USART串口"></a>第九章：USART串口</h1><h2 id="通信接口"><a href="#通信接口" class="headerlink" title="通信接口"></a>通信接口</h2><ul>
<li>通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统</li>
<li>通信协议：制定通信的规则，通信双方按照协议规则进行数据收发</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507123517760.png" alt="image-20240507123517760"></p>
<ul>
<li>半双工通信。半双工通信允许数据在两个方向上传输，但在同一时刻，数据只能在一个方向上传输。这意味着，通信双方可以相互传送数据，但在任一时刻，只能向一个方向传送。例如，一个设备发送数据后，必须等待另一设备接收完毕，再切换角色接收数据。</li>
<li>全双工通信。全双工通信则允许数据同时在两个方向上传输。这意味着通信双方可以同时在两个方向上发送和接收数据，例如，在电话通话中，双方可以同时讲话和听对方讲话。</li>
<li>全双工一般有两根数据线，半双工只有一跟数据线</li>
</ul>
<h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><p>串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信</p>
<p>单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大地扩展了单片机的应用范围，增强了单片机系统的硬件实力</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507125249980.png" alt="image-20240507125249980"></p>
<ul>
<li>USB 转串口模块 ：把 串口协议 转化成 USB协议，实现串口和电脑的通信</li>
<li>陀螺仪传感器模块：测量 角速度，加速度等姿态参数，左边是串口的引脚 ，右边是I2C引脚</li>
<li>蓝牙串口模块：下面是串口的引脚，上面可以和手机互联</li>
</ul>
<h3 id="硬件电路-1"><a href="#硬件电路-1" class="headerlink" title="硬件电路"></a>硬件电路</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507125816989.png" alt="image-20240507125816989"></p>
<ul>
<li>简单双向串口通信有两根通信线（发送端TX和接收端RX）</li>
<li>复杂的串口通信还有其他引脚：时钟引脚，硬件控制流引脚等</li>
<li>TX与RX要交叉连接（发送和接收 连接）</li>
<li>当只需单向的数据传输时，可以只接一根通信线</li>
<li>当电平标准不一致时，需要加电平转换芯片</li>
</ul>
<h3 id="电平标准（常用的）"><a href="#电平标准（常用的）" class="headerlink" title="电平标准（常用的）"></a>电平标准（常用的）</h3><ul>
<li>TTL电平：+3.3V或+5V表示1，0V表示0</li>
<li>RS232电平：-3<del>-15V表示1，+3</del>+15V表示0</li>
<li>RS485电平：两线压差+2<del>+6V表示1，-2</del>-6V表示0（差分信号）</li>
</ul>
<h3 id="字，字节，字长，位"><a href="#字，字节，字长，位" class="headerlink" title="字，字节，字长，位"></a>字，字节，字长，位</h3><p>一个字节 &#x3D; 8 位  （一个字节 等于 八个比特）</p>
<blockquote>
<p>1B &#x3D; 8bit</p>
<p>一个 位（bit） 表示一个二进制位 （0或者1）</p>
<p>一个 字节 表示 一个 字符 或 数字  （字符集）</p>
</blockquote>
<p>字：一串数码作为一个整体来处理或运算的，称为一个计算机字，简称字。字 通过 位（bit）来描述长度。字通常分为若干个字节。在存储器中，通常每个单元存储一个字。因此每个字都是可以寻址的</p>
<p>字长：计算机的每个字所包含的位数（bit），计算的字长是指它一次可处理的二进制的数目。一般地，大型计算机的字长为32-64位，小型计算机为12-32位，而微型计算机为4-16位。</p>
<blockquote>
<p>32位计算机 四个字节表示一个字，CPU 一次可以处理32位二进制，并且寄存器宽度，数据总线，内存管理单元等也是32位</p>
<p>64位计算机 八个字节表示一个字，同理</p>
</blockquote>
<p>其中：<br>数据存储以 字节（B）为单位</p>
<p>数据传输以  位（bit） 为单位</p>
<h3 id="串口参数及时序"><a href="#串口参数及时序" class="headerlink" title="串口参数及时序"></a>串口参数及时序</h3><ul>
<li>波特率：串口通信的速率（每秒传输码元的速率），每隔多久发送一位</li>
</ul>
<blockquote>
<p>例如，比特率是9600，传输每一位的时间就是1&#x2F;9600 &#x3D; 104微秒</p>
</blockquote>
<ul>
<li>比特率：每秒传输比特的速率</li>
</ul>
<blockquote>
<p>在二进制调制模式下 一码元 等于 一比特</p>
</blockquote>
<ul>
<li>起始位：标志一个数据帧的开始，固定为低电平</li>
<li>数据位：数据帧的有效载荷，1为高电平，0为低电平，<strong>低位先行</strong></li>
<li>校验位：用于数据验证，根据数据位计算得来（CRC，奇偶校验）</li>
<li>停止位：用于数据帧间隔，固定为高电平</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507140319955.png" alt="image-20240507140319955"></p>
<p>上图的数据位为八位（一个字节）</p>
<p>下图的数据位为九位（一个字节 + 一个奇偶校验位）</p>
<ul>
<li>空闲（没有传输数据）时，引脚置高电平</li>
<li>起始位，引脚置低电平，创造下降沿 </li>
<li>停止位，引脚置高电平，创造上升沿</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507141151398.png" alt="image-20240507141151398"></p>
<h2 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h2><p>USART（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）通用同步&#x2F;异步收发器</p>
<p>USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里</p>
<p>自带波特率发生器，最高达4.5Mbits&#x2F;s</p>
<p>可配置数据位长度（8&#x2F;9）、停止位长度（0.5&#x2F;1&#x2F;1.5&#x2F;2）</p>
<p>可选校验位（无校验&#x2F;奇校验&#x2F;偶校验）</p>
<p>支持同步模式、硬件流控制、DMA、智能卡、IrDA、LIN</p>
<p>STM32F103C8T6 USART资源： USART1、 USART2、 USART3</p>
<h3 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507160039811.png" alt="image-20240507160039811"></p>
<h3 id="校验位"><a href="#校验位" class="headerlink" title="校验位"></a>校验位</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507145539871.png" alt="image-20240507145539871"></p>
<h3 id="停止位"><a href="#停止位" class="headerlink" title="停止位"></a>停止位</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507145653336.png" alt="image-20240507145653336"></p>
<p>一般选择 一位 停止位</p>
<h3 id="起始位侦测"><a href="#起始位侦测" class="headerlink" title="起始位侦测"></a>起始位侦测</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507150528702.png" alt="image-20240507150528702"></p>
<p>当输入电路 侦测到一个数据帧的起始位后，就会以波特率的频率，连续采样一帧数据，同时，从起始位开始，采样位置就要对齐到位的正中间，只要第一位对齐了，后面就会都对齐</p>
<h3 id="波特率计算"><a href="#波特率计算" class="headerlink" title="波特率计算"></a>波特率计算</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507150743416.png" alt="image-20240507150743416"></p>
<p>发送器和接收器的波特率由波特率寄存器BRR里的DIV确定<br>计算公式：波特率 &#x3D; fPCLK2&#x2F;1 &#x2F; (16 * DIV)</p>
<blockquote>
<p>9600 &#x3D; 72M &#x2F; (16 * DIV)</p>
<p>DIV &#x3D; 468.75 —-&gt;1110 1010 0.11</p>
</blockquote>
<h3 id="数据模式"><a href="#数据模式" class="headerlink" title="数据模式"></a>数据模式</h3><p>HEX模式&#x2F;十六进制模式&#x2F;二进制模式：以原始数据的形式显示（收到什么，显示什么）</p>
<p>文本模式&#x2F;字符模式：以原始数据编码后的形式显示</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507162511368.png" alt="image-20240507162511368" style="zoom:50%;" />

<h2 id="串口发送数据"><a href="#串口发送数据" class="headerlink" title="串口发送数据"></a>串口发送数据</h2><h3 id="接线图"><a href="#接线图" class="headerlink" title="接线图"></a>接线图</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507160456765.png" alt="image-20240507160456765"></p>
<p>STLink和USB串口模块都需要插到电脑上（供电）</p>
<h3 id="基本步骤-1"><a href="#基本步骤-1" class="headerlink" title="基本步骤"></a>基本步骤</h3><ul>
<li>开启时钟（USART,GPIO）</li>
<li>GPIO初始化，TX配置成复用输出，RX配置成输入</li>
<li>配置USART（结构体配置）</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	<span class="comment">//开启USART1的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA9引脚初始化为复用推挽输出</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*USART初始化*/</span></span><br><span class="line">	USART_InitTypeDef USART_InitStructure;					<span class="comment">//定义结构体变量</span></span><br><span class="line">	USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;				<span class="comment">//波特率</span></span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	<span class="comment">//硬件流控制，不需要</span></span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Tx;			<span class="comment">//模式，选择为发送模式</span></span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;		<span class="comment">//奇偶校验，不需要</span></span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;	<span class="comment">//停止位，选择1位</span></span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;		<span class="comment">//字长，选择8位</span></span><br><span class="line">	USART_Init(USART1, &amp;USART_InitStructure);				<span class="comment">//将结构体变量交给USART_Init，配置USART1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*USART使能*/</span></span><br><span class="line">	USART_Cmd(USART1, ENABLE);								<span class="comment">//使能USART1，串口开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;	<span class="comment">/*调用串口库函数*/</span></span><br><span class="line">	USART_SendData(USART1, Byte);		<span class="comment">//将字节数据写入数据寄存器，写入后USART自动生成时序波形</span></span><br><span class="line">	<span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);	<span class="comment">//等待发送完成</span></span><br><span class="line">	<span class="comment">/*下次写入数据寄存器会自动清除发送完成标志位，故此循环后，无需清除标志位*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：串口发送一个数组</span></span><br><span class="line"><span class="comment">  * 参    数：Array 要发送数组的首地址</span></span><br><span class="line"><span class="comment">  * 参    数：Length 要发送数组的长度</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)		<span class="comment">//遍历数组</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Array[i]);		<span class="comment">//依次调用Serial_SendByte发送每个字节数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：串口发送一个字符串</span></span><br><span class="line"><span class="comment">  * 参    数：String 要发送字符串的首地址</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="comment">/* &#x27;\0&#x27; 表示空字符  */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; String[i] != <span class="string">&#x27;\0&#x27;</span>; i ++)<span class="comment">//遍历字符数组（字符串），遇到字符串结束标志位后停止</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(String[i]);		<span class="comment">//依次调用Serial_SendByte发送每个字节数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：次方函数（内部使用）</span></span><br><span class="line"><span class="comment">  * 返 回 值：返回值等于X的Y次方</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> Result = <span class="number">1</span>;	<span class="comment">//设置结果初值为1</span></span><br><span class="line">	<span class="keyword">while</span> (Y --)			<span class="comment">//执行Y次</span></span><br><span class="line">	&#123;</span><br><span class="line">		Result *= X;		<span class="comment">//将X累乘到结果</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：串口发送数字</span></span><br><span class="line"><span class="comment">  * 参    数：Number 要发送的数字，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * 参    数：Length 要发送数字的长度，范围：0~10</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number, <span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)		<span class="comment">//根据数字长度遍历数字的每一位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Number / Serial_Pow(<span class="number">10</span>, Length - i - <span class="number">1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);	</span><br><span class="line">        <span class="comment">//10 的0 或 1次方，&#x27;0&#x27;表示ask11表中的数字偏移</span></span><br><span class="line">        <span class="comment">//依次调用Serial_SendByte发送每位数字</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：使用printf需要重定向的底层函数</span></span><br><span class="line"><span class="comment">  * 参    数：保持原始格式即可，无需变动</span></span><br><span class="line"><span class="comment">  * 返 回 值：保持原始格式即可，无需变动</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">	Serial_SendByte(ch);			<span class="comment">//将printf的底层重定向到自己的发送字节函数</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：自己封装的prinf函数</span></span><br><span class="line"><span class="comment">  * 参    数：format 格式化字符串</span></span><br><span class="line"><span class="comment">  * 参    数：... 可变的参数列表</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> String[<span class="number">100</span>];				<span class="comment">//定义字符数组</span></span><br><span class="line">	va_list arg;					<span class="comment">//定义可变参数列表数据类型的变量arg</span></span><br><span class="line">	va_start(arg, format);			<span class="comment">//从format开始，接收参数列表到arg变量</span></span><br><span class="line">	<span class="built_in">vsprintf</span>(String, format, arg);	<span class="comment">//使用vsprintf打印格式化字符串和参数列表到字符数组中</span></span><br><span class="line">	va_end(arg);					<span class="comment">//结束变量arg</span></span><br><span class="line">	Serial_SendString(String);		<span class="comment">//串口发送字符数组（字符串）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> ‘\0’ 表示空字符 </p>
<p>“\r\n”表示换行 </p>
<p>使用 移植 pintf函数时 需要 打开魔术棒，勾选Use MicroLIB(精简库)，并添加头文件:stdio.h</p>
<p>如果多个串口都想使用pintf，可以用spintf</p>
<blockquote>
<p>使用sprintf打印到字符数组，再用串口发送字符数组，此方法打印到字符数组，之后想怎么处理都可以，可在多处使用<br>    char String[100];					&#x2F;&#x2F;定义字符数组<br>    sprintf(String, “\r\nNum3&#x3D;%d”, 333);&#x2F;&#x2F;使用sprintf，把格式化字符串打印到字符数组<br>    Serial_SendString(String);			&#x2F;&#x2F;串口发送字符数组（字符串）</p>
</blockquote>
<p>封装spintf，C语言可变参数</p>
<blockquote>
<p>添加头文件，stdarg.h</p>
<p>void Serial_Printf(char *format, …)<br>{<br>    char String[100];				&#x2F;&#x2F;定义字符数组<br>    va_list arg;					&#x2F;&#x2F;定义可变参数列表数据类型的变量arg<br>    va_start(arg, format);			&#x2F;&#x2F;从format开始，接收参数列表到arg变量<br>    vsprintf(String, format, arg);	&#x2F;&#x2F;使用vsprintf打印格式化字符串和参数列表到字符数组中<br>    va_end(arg);					&#x2F;&#x2F;结束变量arg<br>    Serial_SendString(String);		&#x2F;&#x2F;串口发送字符数组（字符串）<br>}</p>
<p>Serial_Printf(“\r\nNum4&#x3D;%d”, 444);	&#x2F;&#x2F;串口打印字符串，使用自己封装的函数实现printf的效果</p>
</blockquote>
<p>串口发送汉字乱码，keil选择utf-8编码，选择魔术棒，C&#x2F;C++ , Misc Contols 选项，输入–no-multibyte-chars</p>
<p>或者</p>
<p>keil选择GB2312，串口助手选则GBK</p>
<h2 id="串口接收数据"><a href="#串口接收数据" class="headerlink" title="串口接收数据"></a>串口接收数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//加GPIO_Pin_10引脚</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改模式参数</span></span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;</span><br><span class="line">	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);			<span class="comment">//开启串口接收数据的中断</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*NVIC配置*/</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;					<span class="comment">//定义结构体变量</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;		<span class="comment">//选择配置NVIC的USART1线</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;		<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;		<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);							<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Serial_RxFlag == <span class="number">1</span>)			<span class="comment">//如果标志位为1</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;					<span class="comment">//则返回1，并自动清零标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;						<span class="comment">//如果标志位为0，则返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取串口接收的数据</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Serial_RxData;			<span class="comment">//返回接收的数据变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//USART1中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)		<span class="comment">//判断是否是USART1的接收事件触发的中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_RxData = USART_ReceiveData(USART1);				<span class="comment">//读取数据寄存器，存放在接收的数据变量</span></span><br><span class="line">		Serial_RxFlag = <span class="number">1</span>;										<span class="comment">//置接收标志位变量为1</span></span><br><span class="line">		USART_ClearITPendingBit(USART1, USART_IT_RXNE);			<span class="comment">//清除USART1的RXNE标志位</span></span><br><span class="line">																<span class="comment">//读取数据寄存器会自动清除此标志位</span></span><br><span class="line">																<span class="comment">//如果已经读取了数据寄存器，也可以不执行此代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span>)			<span class="comment">//检查串口接收数据的标志位</span></span><br><span class="line">		&#123;</span><br><span class="line">			RxData = Serial_GetRxData();		<span class="comment">//获取串口接收的数据</span></span><br><span class="line">			Serial_SendByte(RxData);			<span class="comment">//串口将收到的数据回传回去，用于测试</span></span><br><span class="line">			OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, RxData, <span class="number">2</span>);	<span class="comment">//显示串口接收的数据</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="串口收发数据包"><a href="#串口收发数据包" class="headerlink" title="串口收发数据包"></a>串口收发数据包</h2><p>自行规定包头，包尾</p>
<h3 id="HEX数据包"><a href="#HEX数据包" class="headerlink" title="HEX数据包"></a>HEX数据包</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507181403346.png" alt="image-20240507181403346"></p>
<h3 id="文本数据包"><a href="#文本数据包" class="headerlink" title="文本数据包"></a>文本数据包</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507181617814.png" alt="image-20240507181617814"></p>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>一个能够记住不同固定状态的机制，在不同状态执行不同操作，同时进行状态的合理转移</p>
<blockquote>
<p>根据 包头和包尾的联系 设计状态机（ 如下图 ）</p>
</blockquote>
<h3 id="接收HEX数据包（固定包长）"><a href="#接收HEX数据包（固定包长）" class="headerlink" title="接收HEX数据包（固定包长）"></a>接收HEX数据包（固定包长）</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507181819508.png" alt="image-20240507181819508"></p>
<h3 id="接收文本数据包（不固定包长）"><a href="#接收文本数据包（不固定包长）" class="headerlink" title="接收文本数据包（不固定包长）"></a>接收文本数据包（不固定包长）</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507181937806.png" alt="image-20240507181937806"></p>
<h2 id="串口收发HEX数据包"><a href="#串口收发HEX数据包" class="headerlink" title="串口收发HEX数据包"></a>串口收发HEX数据包</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507183549401.png" alt="image-20240507183549401"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> Serial_TxPacket[<span class="number">4</span>];				<span class="comment">//定义发送数据包数组，数据包格式：FF 01 02 03 04 FE</span></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">4</span>];				<span class="comment">//定义接收数据包数组</span></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;					<span class="comment">//定义接收数据包标志位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	<span class="comment">//开启USART1的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA9引脚初始化为复用推挽输出</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA10引脚初始化为上拉输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*USART初始化*/</span></span><br><span class="line">	USART_InitTypeDef USART_InitStructure;					<span class="comment">//定义结构体变量</span></span><br><span class="line">	USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;				<span class="comment">//波特率</span></span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	<span class="comment">//硬件流控制，不需要</span></span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;	<span class="comment">//模式，发送模式和接收模式均选择</span></span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;		<span class="comment">//奇偶校验，不需要</span></span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;	<span class="comment">//停止位，选择1位</span></span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;		<span class="comment">//字长，选择8位</span></span><br><span class="line">	USART_Init(USART1, &amp;USART_InitStructure);				<span class="comment">//将结构体变量交给USART_Init，配置USART1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*中断输出配置*/</span></span><br><span class="line">	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);			<span class="comment">//开启串口接收数据的中断</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);			<span class="comment">//配置NVIC为分组2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC配置*/</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;					<span class="comment">//定义结构体变量</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;		<span class="comment">//选择配置NVIC的USART1线</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;		<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;		<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);							<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*USART使能*/</span></span><br><span class="line">	USART_Cmd(USART1, ENABLE);								<span class="comment">//使能USART1，串口开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(USART1, Byte);		<span class="comment">//将字节数据写入数据寄存器，写入后USART自动生成时序波形</span></span><br><span class="line">	<span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);	<span class="comment">//等待发送完成</span></span><br><span class="line">	<span class="comment">/*下次写入数据寄存器会自动清除发送完成标志位，故此循环后，无需清除标志位*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送一个数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)		<span class="comment">//遍历数组</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Array[i]);		<span class="comment">//依次调用Serial_SendByte发送每个字节数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送一个字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; String[i] != <span class="string">&#x27;\0&#x27;</span>; i ++)<span class="comment">//遍历字符数组（字符串），遇到字符串结束标志位后停止</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(String[i]);		<span class="comment">//依次调用Serial_SendByte发送每个字节数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：次方函数（内部使用）</span></span><br><span class="line"><span class="comment">  * 返 回 值：返回值等于X的Y次方</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> Result = <span class="number">1</span>;	<span class="comment">//设置结果初值为1</span></span><br><span class="line">	<span class="keyword">while</span> (Y --)			<span class="comment">//执行Y次</span></span><br><span class="line">	&#123;</span><br><span class="line">		Result *= X;		<span class="comment">//将X累乘到结果</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送数字</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number, <span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)		<span class="comment">//根据数字长度遍历数字的每一位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Number / Serial_Pow(<span class="number">10</span>, Length - i - <span class="number">1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);	</span><br><span class="line">        <span class="comment">//依次调用Serial_SendByte发送每位数字</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用printf需要重定向的底层函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">	Serial_SendByte(ch);			<span class="comment">//将printf的底层重定向到自己的发送字节函数</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己封装的prinf函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> String[<span class="number">100</span>];				<span class="comment">//定义字符数组</span></span><br><span class="line">	va_list arg;					<span class="comment">//定义可变参数列表数据类型的变量arg</span></span><br><span class="line">	va_start(arg, format);			<span class="comment">//从format开始，接收参数列表到arg变量</span></span><br><span class="line">	<span class="built_in">vsprintf</span>(String, format, arg);	<span class="comment">//使用vsprintf打印格式化字符串和参数列表到字符数组中</span></span><br><span class="line">	va_end(arg);					<span class="comment">//结束变量arg</span></span><br><span class="line">	Serial_SendString(String);		<span class="comment">//串口发送字符数组（字符串）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Serial_SendByte(<span class="number">0xFF</span>); <span class="comment">// 包头</span></span><br><span class="line">	Serial_SendArray(Serial_TxPacket, <span class="number">4</span>);</span><br><span class="line">	Serial_SendByte(<span class="number">0xFE</span>); <span class="comment">// 包尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取串口接收数据包标志位</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Serial_RxFlag == <span class="number">1</span>)			<span class="comment">//如果标志位为1</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;					<span class="comment">//则返回1，并自动清零标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;						<span class="comment">//如果标志位为0，则返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//USART1中断函数  状态机</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;		<span class="comment">//定义表示当前状态机状态的静态变量  0 ， 1，  2</span></span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> pRxPacket = <span class="number">0</span>;	<span class="comment">//定义表示当前接收数据位置的静态变量</span></span><br><span class="line">	<span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)		<span class="comment">//判断是否是USART1的接收事件触发的中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);				<span class="comment">//读取数据寄存器，存放在接收的数据变量</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*使用状态机的思路，依次处理数据包的不同部分*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*当前状态为0，接收数据包包头*/</span></span><br><span class="line">		<span class="keyword">if</span> (RxState == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (RxData == <span class="number">0xFF</span>)			<span class="comment">//如果数据确实是包头</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">1</span>;			<span class="comment">//置下一个状态</span></span><br><span class="line">				pRxPacket = <span class="number">0</span>;			<span class="comment">//数据包的位置归零</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*当前状态为1，接收数据包数据*/</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Serial_RxPacket[pRxPacket] = RxData;	<span class="comment">//将数据存入数据包数组的指定位置</span></span><br><span class="line">			pRxPacket ++;				<span class="comment">//数据包的位置自增</span></span><br><span class="line">			<span class="keyword">if</span> (pRxPacket &gt;= <span class="number">4</span>)			<span class="comment">//如果收够4个数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">2</span>;			<span class="comment">//置下一个状态</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*当前状态为2，接收数据包包尾*/</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (RxData == <span class="number">0xFE</span>)			<span class="comment">//如果数据确实是包尾部</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">0</span>;			<span class="comment">//状态归0</span></span><br><span class="line">				Serial_RxFlag = <span class="number">1</span>;		<span class="comment">//接收数据包标志位置1，成功接收一个数据包</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		USART_ClearITPendingBit(USART1, USART_IT_RXNE);		<span class="comment">//清除标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置发送数据包数组的初始值，用于测试*/</span></span><br><span class="line">	Serial_TxPacket[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">	Serial_TxPacket[<span class="number">1</span>] = <span class="number">0x02</span>;</span><br><span class="line">	Serial_TxPacket[<span class="number">2</span>] = <span class="number">0x03</span>;</span><br><span class="line">	Serial_TxPacket[<span class="number">3</span>] = <span class="number">0x04</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KeyNum = Key_GetNum();			<span class="comment">//获取按键键码</span></span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">1</span>)				<span class="comment">//按键1按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			Serial_TxPacket[<span class="number">0</span>] ++;		<span class="comment">//测试数据自增</span></span><br><span class="line">			Serial_TxPacket[<span class="number">1</span>] ++;</span><br><span class="line">			Serial_TxPacket[<span class="number">2</span>] ++;</span><br><span class="line">			Serial_TxPacket[<span class="number">3</span>] ++;</span><br><span class="line">			</span><br><span class="line">			Serial_SendPacket();		<span class="comment">//串口发送数据包Serial_TxPacket</span></span><br><span class="line">			</span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>, <span class="number">1</span>, Serial_TxPacket[<span class="number">0</span>], <span class="number">2</span>);	<span class="comment">//显示发送的数据包</span></span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>, <span class="number">4</span>, Serial_TxPacket[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>, <span class="number">7</span>, Serial_TxPacket[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>, <span class="number">10</span>, Serial_TxPacket[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span>)	<span class="comment">//如果接收到数据包</span></span><br><span class="line">		&#123;</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, Serial_RxPacket[<span class="number">0</span>], <span class="number">2</span>);	<span class="comment">//显示接收的数据包</span></span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>, <span class="number">4</span>, Serial_RxPacket[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>, <span class="number">7</span>, Serial_RxPacket[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>, <span class="number">10</span>, Serial_RxPacket[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码可能出现问题: 由于收发数据的读取速度（时间差）问题，导致 接收到的数据包为 上一个数据包的前半部分和下一个数据包的后半部分 </p>
<p>解决办法：在接收时，加入判断，当前数据包读取完成后，再接收下一个数据包</p>
<h2 id="串口收发文本数据包"><a href="#串口收发文本数据包" class="headerlink" title="串口收发文本数据包"></a>串口收发文本数据包</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240507183628869.png" alt="image-20240507183628869"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> Serial_RxPacket[<span class="number">100</span>];				<span class="comment">//定义接收数据包数组，数据类型为char，接收字符 </span></span><br><span class="line">										<span class="comment">//数据包格式&quot;@MSG\r\n&quot;</span></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;					<span class="comment">//定义接收数据包标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	<span class="comment">//开启USART1的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA9引脚初始化为复用推挽输出</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA10引脚初始化为上拉输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*USART初始化*/</span></span><br><span class="line">	USART_InitTypeDef USART_InitStructure;					<span class="comment">//定义结构体变量</span></span><br><span class="line">	USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;				<span class="comment">//波特率</span></span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	<span class="comment">//硬件流控制，不需要</span></span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;	<span class="comment">//模式，发送模式和接收模式均选择</span></span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;		<span class="comment">//奇偶校验，不需要</span></span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;	<span class="comment">//停止位，选择1位</span></span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;		<span class="comment">//字长，选择8位</span></span><br><span class="line">	USART_Init(USART1, &amp;USART_InitStructure);				<span class="comment">//将结构体变量交给USART_Init，配置USART1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*中断输出配置*/</span></span><br><span class="line">	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);			<span class="comment">//开启串口接收数据的中断</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);			<span class="comment">//配置NVIC为分组2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*NVIC配置*/</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;					<span class="comment">//定义结构体变量</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;		<span class="comment">//选择配置NVIC的USART1线</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;		<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;		<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);							<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*USART使能*/</span></span><br><span class="line">	USART_Cmd(USART1, ENABLE);								<span class="comment">//使能USART1，串口开始运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(USART1, Byte);		<span class="comment">//将字节数据写入数据寄存器，写入后USART自动生成时序波形</span></span><br><span class="line">	<span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);	<span class="comment">//等待发送完成</span></span><br><span class="line">	<span class="comment">/*下次写入数据寄存器会自动清除发送完成标志位，故此循环后，无需清除标志位*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送一个数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)		<span class="comment">//遍历数组</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Array[i]);		<span class="comment">//依次调用Serial_SendByte发送每个字节数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送一个字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; String[i] != <span class="string">&#x27;\0&#x27;</span>; i ++)<span class="comment">//遍历字符数组（字符串），遇到字符串结束标志位后停止</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(String[i]);		<span class="comment">//依次调用Serial_SendByte发送每个字节数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：次方函数（内部使用）</span></span><br><span class="line"><span class="comment">  * 返 回 值：返回值等于X的Y次方</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> Result = <span class="number">1</span>;	<span class="comment">//设置结果初值为1</span></span><br><span class="line">	<span class="keyword">while</span> (Y --)			<span class="comment">//执行Y次</span></span><br><span class="line">	&#123;</span><br><span class="line">		Result *= X;		<span class="comment">//将X累乘到结果</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number, <span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)		<span class="comment">//根据数字长度遍历数字的每一位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Number / Serial_Pow(<span class="number">10</span>, Length - i - <span class="number">1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);	<span class="comment">//依次调用Serial_SendByte发送每位数字</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用printf需要重定向的底层函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">	Serial_SendByte(ch);			<span class="comment">//将printf的底层重定向到自己的发送字节函数</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己封装的prinf函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> String[<span class="number">100</span>];				<span class="comment">//定义字符数组</span></span><br><span class="line">	va_list arg;					<span class="comment">//定义可变参数列表数据类型的变量arg</span></span><br><span class="line">	va_start(arg, format);			<span class="comment">//从format开始，接收参数列表到arg变量</span></span><br><span class="line">	<span class="built_in">vsprintf</span>(String, format, arg);	<span class="comment">//使用vsprintf打印格式化字符串和参数列表到字符数组中</span></span><br><span class="line">	va_end(arg);					<span class="comment">//结束变量arg</span></span><br><span class="line">	Serial_SendString(String);		<span class="comment">//串口发送字符数组（字符串）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//USART1中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;		<span class="comment">//定义表示当前状态机状态的静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> pRxPacket = <span class="number">0</span>;	<span class="comment">//定义表示当前接收数据位置的静态变量</span></span><br><span class="line">	<span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)	<span class="comment">//判断是否是USART1的接收事件触发的中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);			<span class="comment">//读取数据寄存器，存放在接收的数据变量</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*使用状态机的思路，依次处理数据包的不同部分*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*当前状态为0，接收数据包包头*/</span></span><br><span class="line">		<span class="keyword">if</span> (RxState == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (RxData == <span class="string">&#x27;@&#x27;</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)		<span class="comment">//如果数据确实是包头，并且上一个数据包已处理完毕</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">1</span>;			<span class="comment">//置下一个状态</span></span><br><span class="line">				pRxPacket = <span class="number">0</span>;			<span class="comment">//数据包的位置归零</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*当前状态为1，接收数据包数据，同时判断是否接收到了第一个包尾*/</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (RxData == <span class="string">&#x27;\r&#x27;</span>)			<span class="comment">//如果收到第一个包尾</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">2</span>;			<span class="comment">//置下一个状态</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>						<span class="comment">//接收到了正常的数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				Serial_RxPacket[pRxPacket] = RxData;		<span class="comment">//将数据存入数据包数组的指定位置</span></span><br><span class="line">				pRxPacket ++;			<span class="comment">//数据包的位置自增</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*当前状态为2，接收数据包第二个包尾*/</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (RxData == <span class="string">&#x27;\n&#x27;</span>)			<span class="comment">//如果收到第二个包尾</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">0</span>;			<span class="comment">//状态归0</span></span><br><span class="line">				Serial_RxPacket[pRxPacket] = <span class="string">&#x27;\0&#x27;</span>;			<span class="comment">//将收到的字符数据包添加一个字符串结束标志</span></span><br><span class="line">				Serial_RxFlag = <span class="number">1</span>;		<span class="comment">//接收数据包标志位置1，成功接收一个数据包</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		USART_ClearITPendingBit(USART1, USART_IT_RXNE);		<span class="comment">//清除标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Serial_RxFlag == <span class="number">1</span>)		<span class="comment">//如果接收到数据包</span></span><br><span class="line">		&#123;</span><br><span class="line">			OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">			OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, Serial_RxPacket);				<span class="comment">//OLED清除指定位置，并显示接收到的数据包</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">/*将收到的数据包与预设的指令对比，以此决定将要执行的操作*/</span></span><br><span class="line">           <span class="comment">/*strcmp 是string 库中的函数，如果Serial_RxPacket == LED_ON  则 返回0 */</span> </span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(Serial_RxPacket, <span class="string">&quot;LED_ON&quot;</span>) == <span class="number">0</span>)			<span class="comment">//如果收到LED_ON指令</span></span><br><span class="line">			&#123;</span><br><span class="line">				LED1_ON();										<span class="comment">//点亮LED</span></span><br><span class="line">				Serial_SendString(<span class="string">&quot;LED_ON_OK\r\n&quot;</span>);				<span class="comment">//串口回传一个字符串LED_ON_OK</span></span><br><span class="line">				OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">				OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;LED_ON_OK&quot;</span>);				<span class="comment">//OLED清除指定位置，并显示LED_ON_OK</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(Serial_RxPacket, <span class="string">&quot;LED_OFF&quot;</span>) == <span class="number">0</span>)	<span class="comment">//如果收到LED_OFF指令</span></span><br><span class="line">			&#123;</span><br><span class="line">				LED1_OFF();										<span class="comment">//熄灭LED</span></span><br><span class="line">				Serial_SendString(<span class="string">&quot;LED_OFF_OK\r\n&quot;</span>);			<span class="comment">//串口回传一个字符串LED_OFF_OK</span></span><br><span class="line">				OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">				OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;LED_OFF_OK&quot;</span>);			<span class="comment">//OLED清除指定位置，并显示LED_OFF_OK</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>						<span class="comment">//上述所有条件均不满足，即收到了未知指令</span></span><br><span class="line">			&#123;</span><br><span class="line">				Serial_SendString(<span class="string">&quot;ERROR_COMMAND\r\n&quot;</span>);			<span class="comment">//串口回传一个字符串ERROR_COMMAND</span></span><br><span class="line">				OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">				OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;ERROR_COMMAND&quot;</span>);			<span class="comment">//OLED清除指定位置，并显示ERROR_COMMAND</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			Serial_RxFlag = <span class="number">0</span>;			<span class="comment">//处理完成后，需要将接收数据包标志位清零，否则将无法接收后续数据包</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第十章：I2C通信"><a href="#第十章：I2C通信" class="headerlink" title="第十章：I2C通信"></a>第十章：I2C通信</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><ul>
<li>I2C（Inter IC Bus）是由Philips公司开发的一种<strong>通用数据总线</strong></li>
<li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</li>
<li>同步，半双工</li>
<li>带数据应答</li>
<li>支持总线挂载多设备（一主多从、多主多从）</li>
<li>单片机读写外部（外挂）模块的存储器（寄存器）</li>
</ul>
<blockquote>
<p>实现在指定的位置，读 写寄存器</p>
</blockquote>
<p>使用I2C协议的几个模块</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508121303965.png" alt="image-20240508121303965"></p>
<p>图片1：MPU6050 陀螺仪 姿态测量</p>
<p>图片2：OLED 模块 </p>
<p>图片3：AT24C02 存储器模块（51） </p>
<p>图片4：DS3231 实时时钟模块</p>
<h2 id="硬件电路-2"><a href="#硬件电路-2" class="headerlink" title="硬件电路"></a>硬件电路</h2><ul>
<li>所有I2C设备的SCL连在一起，SDA连在一起</li>
<li>设备的SCL和SDA均要配置成开漏输出模式</li>
<li>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508122825421.png" alt="image-20240508122825421"></p>
<p>挂载模块，只能被动的读取<strong>时钟线</strong>，且不能主动地发起对<strong>数据线</strong>的控制（只有在主机发起控制信号后，才可以）</p>
<p>主机拥有SCL的绝对控制权，可以配置成推挽输出  或  [外置弱上拉电阻+开漏输出模式]</p>
<p>​							从机的SCL可以配置成浮空输入或上拉输入</p>
<p>但是对于SDA线,主机和从机会在输入和输出之间反复切换</p>
<p>I2C的解决办法：禁止所有设备输出强上拉的高电平，采用外置弱上拉电阻+开漏输出模式</p>
<p>主机和从机的内部结构:</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508131539041.png" alt="image-20240508131539041" style="zoom:50%;" />

<p>外置弱上拉电阻+开漏输出模式——-&gt;   弹簧和杆 模型</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508130213549.png" alt="image-20240508130213549" style="zoom:25%;" />

<p>输出低电平 时，弹簧处于拉升状态，引脚接地</p>
<p>输出高电平 时，弹簧处于收缩状态，引脚回弹到高电平（引脚本来是浮空的，接上电阻（弹簧）后，形成弱上拉高电平）</p>
<blockquote>
<p>杜绝了 短路的情况</p>
<p>避免了 引脚的频繁切换</p>
<p>能够 模拟 “线与”的现象：</p>
<p>当有一个或多个设备处于低电平时，总线就处于低电平。</p>
<p>只有所有设备处于高电平，总线才会处于高电平</p>
</blockquote>
<p>但是 这会导致，上升沿的耗时比较长，限制I2C的最大通信速度</p>
<h2 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h2><p>设备地址分为 7位 和 10位（主要使用7位）</p>
<p>不同类型模块的设备地址不同，同一类型模块的设备地址相同</p>
<p>如果要在一个MCU上挂载多个 同一类型（型号）的模块 ，可以通过配置它们的低位设备地址来区分 </p>
<h2 id="I2C时序基本单元"><a href="#I2C时序基本单元" class="headerlink" title="I2C时序基本单元"></a>I2C时序基本单元</h2><h3 id="起始条件"><a href="#起始条件" class="headerlink" title="起始条件"></a>起始条件</h3><p>类似于 串口的起始位</p>
<p>SCL高电平期间，SDA从高电平切换到低电平（下降沿）</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508132757906.png" alt="image-20240508132757906" style="zoom:33%;" />

<h3 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h3><p>类似于 串口的终止位</p>
<p>SCL高电平期间，SDA从低电平切换到高电平（上升沿）</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508132603924.png" alt="image-20240508132603924" style="zoom: 33%;" />

<h3 id="发送一个字节（主机）"><a href="#发送一个字节（主机）" class="headerlink" title="发送一个字节（主机）"></a>发送一个字节（主机）</h3><p>主机发送字节，从机接收字节（<strong>高位先行</strong>）</p>
<p>当SCL（时钟线）处于低电平时，主机改变SDA（数据线）的高低电平（数据线，置1&#x2F;0），然后 拉高 SCL （时钟线）电平</p>
<p>当SCL（时钟线）处于高电平 或 上升沿 时，从机从 SDA（数据线）读取高低电平（读取数据）</p>
<blockquote>
<p>SCL 高电平期间 （从机读取数据时）SDA不允许有数据变化</p>
</blockquote>
<p>依次循环上述过程8次，即可发送一个字节</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508134526296.png" alt="image-20240508134526296"></p>
<p>主机控制时钟线实现同步，如果主机发送数据时，产生中断，主机可以拉长（高&#x2F;低）电平线，即停止收发数据，先处理中断，完成后再回来发送数据</p>
<h3 id="接收一个字节（主机）"><a href="#接收一个字节（主机）" class="headerlink" title="接收一个字节（主机）"></a>接收一个字节（主机）</h3><p>主机接收字节，从机发送字节（<strong>高位先行</strong>）</p>
<p>当SCL（时钟线）处于低电平，从机 将 数据位 依次放到SDA线上，然后释放SCL</p>
<blockquote>
<p>将 数据位 依次放到SDA线上 ——–&gt;改变SDA（数据线）的高低电平（数据线，置1&#x2F;0）</p>
</blockquote>
<p>当SCL（时钟线）处于高电平，主机读取数据位，</p>
<blockquote>
<p>SCL高电平期间（主机读取数据）SDA不允许有数据变化</p>
</blockquote>
<p>依次循环上述过程8次，即可接收一个字节<strong>（主机在接收之前，需要释放SDA,把  SDA  控制权 给从机）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508142101896.png" alt="image-20240508142101896"></p>
<h3 id="发送应答"><a href="#发送应答" class="headerlink" title="发送应答"></a>发送应答</h3><p>主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答</p>
<p>从机收到0后，继续发数据给主机；收到0后，停止发数据给主机；</p>
<h3 id="接收应答"><a href="#接收应答" class="headerlink" title="接收应答"></a>接收应答</h3><p>主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）</p>
<blockquote>
<p>主机发送一个字节后，调用 <strong>接收应答</strong> 并释放SDA，在 一个时钟内 等待从机的响应</p>
</blockquote>
<h2 id="I2C时序"><a href="#I2C时序" class="headerlink" title="I2C时序"></a>I2C时序</h2><h3 id="指定地址写"><a href="#指定地址写" class="headerlink" title="指定地址写"></a>指定地址写</h3><p>1-读</p>
<p>对于指定设备，在指定地址下，写入指定数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508150323202.png" alt="image-20240508150323202"></p>
<h3 id="当前地址读"><a href="#当前地址读" class="headerlink" title="当前地址读"></a>当前地址读</h3><p>对于指定设备，在 <strong>当前地址指针</strong> 指示的地址下，读取从机数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508151532800.png" alt="image-20240508151532800"></p>
<h3 id="指定地址读"><a href="#指定地址读" class="headerlink" title="指定地址读"></a>指定地址读</h3><p>指定地址读 &#x3D; 指定地址写  + Sr + 指定地址读</p>
<p>对于指定设备，在指定地址下，读取从机数据</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508152340082.png" alt="image-20240508152340082" style="zoom:200%;" />

<h2 id="MPU6050（回炉重造）"><a href="#MPU6050（回炉重造）" class="headerlink" title="MPU6050（回炉重造）"></a>MPU6050（回炉重造）</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul>
<li>MPU6050是一个6轴<strong>姿态传感器</strong>，可以测量芯片自身X、Y、Z轴的加速度、角速度参数，通过数据融合，可进一步得到姿态角，常应用于平衡车、飞行器等需要检测自身姿态的场景</li>
<li>3轴加速度计（Accelerometer）：测量X、Y、Z轴的加速度</li>
<li>3轴陀螺仪传感器（Gyroscope）：测量X、Y、Z轴的角速度</li>
</ul>
<h3 id="MPU6050参数"><a href="#MPU6050参数" class="headerlink" title="MPU6050参数"></a>MPU6050参数</h3><p>16位ADC采集传感器的模拟信号，量化范围：-32768~32767</p>
<p>加速度计满量程选择：±2、±4、±8、±16（g）</p>
<p>陀螺仪满量程选择： ±250、±500、±1000、±2000（°&#x2F;sec）</p>
<p>可配置的数字低通滤波器</p>
<p>可配置的时钟源</p>
<p>可配置的采样分频</p>
<p>I2C从机地址：1101000（AD0&#x3D;0）<br>            1101001（AD0&#x3D;1）</p>
<table>
<thead>
<tr>
<th><strong>引脚</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>VCC、GND</td>
<td>电源</td>
</tr>
<tr>
<td>SCL、SDA</td>
<td>I2C通信引脚</td>
</tr>
<tr>
<td>XCL、XDA</td>
<td>主机I2C通信引脚</td>
</tr>
<tr>
<td>AD0</td>
<td>从机地址最低位</td>
</tr>
<tr>
<td>INT</td>
<td>中断信号输出</td>
</tr>
</tbody></table>
<h2 id="软件I2C读写MPU6050"><a href="#软件I2C读写MPU6050" class="headerlink" title="软件I2C读写MPU6050"></a>软件I2C读写MPU6050</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508163058093.png" alt="image-20240508163058093"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">I2C.c</span><br><span class="line"><span class="comment">/*引脚配置层*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：I2C写SCL引脚电平</span></span><br><span class="line"><span class="comment">  * 参    数：BitValue 协议层传入的当前需要写入SCL的电平，范围0~1</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数需要用户实现内容，当BitValue为0时，需要置SCL为低电平，当BitValue为1时，需要置SCL为高电平</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SCL</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOB, GPIO_Pin_10, (BitAction)BitValue);		<span class="comment">//根据BitValue，设置SCL引脚的电平</span></span><br><span class="line">	Delay_us(<span class="number">10</span>);												<span class="comment">//延时10us，防止时序频率超过要求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：I2C写SDA引脚电平</span></span><br><span class="line"><span class="comment">  * 参    数：BitValue 协议层传入的当前需要写入SDA的电平，范围0~0xFF</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数需要用户实现内容，当BitValue为0时，需要置SDA为低电平，当BitValue非0时，需要置SDA为高电平</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SDA</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOB, GPIO_Pin_11, (BitAction)BitValue);		</span><br><span class="line">    <span class="comment">//根据BitValue，设置SDA引脚的电平，BitValue要实现非0即1的特性</span></span><br><span class="line">	Delay_us(<span class="number">10</span>);												<span class="comment">//延时10us，防止时序频率超过要求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：I2C读SDA引脚电平</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：协议层需要得到的当前SDA的电平，范围0~1</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数需要用户实现内容，当前SDA为低电平时，返回0，当前SDA为高电平时，返回1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SDA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> BitValue;</span><br><span class="line">	BitValue = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11);		<span class="comment">//读取SDA电平</span></span><br><span class="line">	Delay_us(<span class="number">10</span>);												<span class="comment">//延时10us，防止时序频率超过要求</span></span><br><span class="line">	<span class="keyword">return</span> BitValue;											<span class="comment">//返回SDA电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//I2C初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);	<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);					<span class="comment">//将PB10和PB11引脚初始化为开漏输出</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*设置默认电平*/</span></span><br><span class="line">	GPIO_SetBits(GPIOB, GPIO_Pin_10 | GPIO_Pin_11);			<span class="comment">//设置PB10和PB11引脚初始化后默认为高电平（释放总线状态）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*协议层*/</span></span><br><span class="line"><span class="comment">//I2C起始位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyI2C_W_SDA(<span class="number">1</span>);							<span class="comment">//释放SDA，确保SDA为高电平</span></span><br><span class="line">	MyI2C_W_SCL(<span class="number">1</span>);							<span class="comment">//释放SCL，确保SCL为高电平</span></span><br><span class="line">	MyI2C_W_SDA(<span class="number">0</span>);							<span class="comment">//在SCL高电平期间，拉低SDA，产生起始信号</span></span><br><span class="line">	MyI2C_W_SCL(<span class="number">0</span>);							<span class="comment">//起始后把SCL也拉低，即为了占用总线，也为了方便总线时序的拼接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//I2C终止位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyI2C_W_SDA(<span class="number">0</span>);							<span class="comment">//拉低SDA，确保SDA为低电平</span></span><br><span class="line">	MyI2C_W_SCL(<span class="number">1</span>);							<span class="comment">//释放SCL，使SCL呈现高电平</span></span><br><span class="line">	MyI2C_W_SDA(<span class="number">1</span>);							<span class="comment">//在SCL高电平期间，释放SDA，产生终止信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//I2C发送一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)				<span class="comment">//循环8次，主机依次发送数据的每一位</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyI2C_W_SDA(Byte &amp; (<span class="number">0x80</span> &gt;&gt; i));	<span class="comment">//使用掩码的方式取出Byte的指定一位数据并写入到SDA线</span></span><br><span class="line">		MyI2C_W_SCL(<span class="number">1</span>);						<span class="comment">//释放SCL，从机在SCL高电平期间读取SDA</span></span><br><span class="line">		MyI2C_W_SCL(<span class="number">0</span>);						<span class="comment">//拉低SCL，主机开始发送下一位数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//I2C接收一个字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i, Byte = <span class="number">0x00</span>;					<span class="comment">//定义接收的数据，并赋初值0x00，此处必须赋初值0x00，后面会用到</span></span><br><span class="line">	MyI2C_W_SDA(<span class="number">1</span>);							<span class="comment">//接收前，主机先确保释放SDA，避免干扰从机的数据发送</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)				<span class="comment">//循环8次，主机依次接收数据的每一位</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyI2C_W_SCL(<span class="number">1</span>);						<span class="comment">//释放SCL，主机机在SCL高电平期间读取SDA</span></span><br><span class="line">		<span class="keyword">if</span> (MyI2C_R_SDA() == <span class="number">1</span>)&#123;Byte |= (<span class="number">0x80</span> &gt;&gt; i);&#125;	<span class="comment">//读取SDA数据，并存储到Byte变量</span></span><br><span class="line">		<span class="comment">//当SDA为1时，置变量指定位为1，当SDA为0时，不做处理，指定位为默认的初值0</span></span><br><span class="line">		MyI2C_W_SCL(<span class="number">0</span>);						<span class="comment">//拉低SCL，从机在SCL低电平期间写入SDA</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Byte;							<span class="comment">//返回接收到的一个字节数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//I2C发送应答位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyI2C_W_SDA(AckBit);					<span class="comment">//主机把应答位数据放到SDA线</span></span><br><span class="line">	MyI2C_W_SCL(<span class="number">1</span>);							<span class="comment">//释放SCL，从机在SCL高电平期间，读取应答位</span></span><br><span class="line">	MyI2C_W_SCL(<span class="number">0</span>);							<span class="comment">//拉低SCL，开始下一个时序模块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//I2C接收应答位</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> AckBit;							<span class="comment">//定义应答位变量</span></span><br><span class="line">	MyI2C_W_SDA(<span class="number">1</span>);							<span class="comment">//接收前，主机先确保释放SDA，避免干扰从机的数据发送</span></span><br><span class="line">	MyI2C_W_SCL(<span class="number">1</span>);							<span class="comment">//释放SCL，主机机在SCL高电平期间读取SDA</span></span><br><span class="line">	AckBit = MyI2C_R_SDA();					<span class="comment">//将应答位存储到变量里</span></span><br><span class="line">	MyI2C_W_SCL(<span class="number">0</span>);							<span class="comment">//拉低SCL，开始下一个时序模块</span></span><br><span class="line">	<span class="keyword">return</span> AckBit;							<span class="comment">//返回定义应答位变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">MPU6950.C</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：主机通过I2C写 MPU6050寄存器</span></span><br><span class="line"><span class="comment">  * 参    数：RegAddress 寄存器地址，范围：参考MPU6050手册的寄存器描述</span></span><br><span class="line"><span class="comment">  * 参    数：Data 要写入寄存器的数据，范围：0x00~0xFF</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress, <span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//I2C通信</span></span><br><span class="line">	MyI2C_Start();						<span class="comment">//I2C起始</span></span><br><span class="line">	MyI2C_SendByte(MPU6050_ADDRESS);	<span class="comment">//发送从机地址，读写位为0，表示即将写入</span></span><br><span class="line">	MyI2C_ReceiveAck();					<span class="comment">//接收应答</span></span><br><span class="line">    <span class="comment">//此处省略对ACK的判断</span></span><br><span class="line">	MyI2C_SendByte(RegAddress);			<span class="comment">//发送寄存器地址</span></span><br><span class="line">	MyI2C_ReceiveAck();					<span class="comment">//接收应答</span></span><br><span class="line">	MyI2C_SendByte(Data);				<span class="comment">//发送要写入寄存器的数据</span></span><br><span class="line">	MyI2C_ReceiveAck();					<span class="comment">//接收应答</span></span><br><span class="line">	MyI2C_Stop();						<span class="comment">//I2C终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：主机通过I2C读MPU6050寄存器</span></span><br><span class="line"><span class="comment">  * 参    数：RegAddress 寄存器地址，范围：参考MPU6050手册的寄存器描述</span></span><br><span class="line"><span class="comment">  * 返 回 值：读取寄存器的数据，范围：0x00~0xFF</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> Data;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//I2C通信</span></span><br><span class="line">	MyI2C_Start();						<span class="comment">//I2C起始</span></span><br><span class="line">	MyI2C_SendByte(MPU6050_ADDRESS);	<span class="comment">//发送从机地址，读写位为0，表示即将写入</span></span><br><span class="line">	MyI2C_ReceiveAck();					<span class="comment">//接收应答</span></span><br><span class="line">	MyI2C_SendByte(RegAddress);			<span class="comment">//发送寄存器地址</span></span><br><span class="line">	MyI2C_ReceiveAck();					<span class="comment">//接收应答</span></span><br><span class="line">	</span><br><span class="line">	MyI2C_Start();						<span class="comment">//I2C重复起始</span></span><br><span class="line">	MyI2C_SendByte(MPU6050_ADDRESS | <span class="number">0x01</span>);	<span class="comment">//发送从机地址，读写位为1，表示即将读取</span></span><br><span class="line">	MyI2C_ReceiveAck();					<span class="comment">//接收应答</span></span><br><span class="line">	Data = MyI2C_ReceiveByte();			<span class="comment">//接收指定寄存器的数据</span></span><br><span class="line">	MyI2C_SendAck(<span class="number">1</span>);					<span class="comment">//发送应答，给从机非应答，终止从机的数据输出</span></span><br><span class="line">	MyI2C_Stop();						<span class="comment">//I2C终止</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MPU6050初始化 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyI2C_Init();									<span class="comment">//先初始化底层的I2C</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*MPU6050寄存器初始化，需要对照MPU6050手册的寄存器描述配置，此处仅配置了部分重要的寄存器*/</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_1, <span class="number">0x01</span>);		<span class="comment">//电源管理寄存器1，取消睡眠模式，选择时钟源为X轴陀螺仪</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_2, <span class="number">0x00</span>);		<span class="comment">//电源管理寄存器2，保持默认值0，所有轴均不待机</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_SMPLRT_DIV, <span class="number">0x09</span>);		<span class="comment">//采样率分频寄存器，配置采样率</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_CONFIG, <span class="number">0x06</span>);			<span class="comment">//配置寄存器，配置DLPF</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_GYRO_CONFIG, <span class="number">0x18</span>);	<span class="comment">//陀螺仪配置寄存器，选择满量程为±2000°/s</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, <span class="number">0x18</span>);	<span class="comment">//加速度计配置寄存器，选择满量程为±16g</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MPU6050获取ID号</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);		<span class="comment">//返回WHO_AM_I寄存器的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：MPU6050获取数据</span></span><br><span class="line"><span class="comment">  * 参    数：AccX AccY AccZ 加速度计X、Y、Z轴的数据，使用输出参数的形式返回，范围：-32768~32767</span></span><br><span class="line"><span class="comment">  * 参    数：GyroX GyroY GyroZ 陀螺仪X、Y、Z轴的数据，使用输出参数的形式返回，范围：-32768~32767</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX, <span class="type">int16_t</span> *AccY, <span class="type">int16_t</span> *AccZ, </span></span><br><span class="line"><span class="params">						<span class="type">int16_t</span> *GyroX, <span class="type">int16_t</span> *GyroY, <span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> DataH, DataL;								<span class="comment">//定义数据高8位和低8位的变量</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);		<span class="comment">//读取加速度计X轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);		<span class="comment">//读取加速度计X轴的低8位数据</span></span><br><span class="line">	*AccX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);		<span class="comment">//读取加速度计Y轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);		<span class="comment">//读取加速度计Y轴的低8位数据</span></span><br><span class="line">	*AccY = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);		<span class="comment">//读取加速度计Z轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);		<span class="comment">//读取加速度计Z轴的低8位数据</span></span><br><span class="line">	*AccZ = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);		<span class="comment">//读取陀螺仪X轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);		<span class="comment">//读取陀螺仪X轴的低8位数据</span></span><br><span class="line">	*GyroX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);		<span class="comment">//读取陀螺仪Y轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);		<span class="comment">//读取陀螺仪Y轴的低8位数据</span></span><br><span class="line">	*GyroY = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);		<span class="comment">//读取陀螺仪Z轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);		<span class="comment">//读取陀螺仪Z轴的低8位数据</span></span><br><span class="line">	*GyroZ = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MAIN.C</span><br><span class="line"><span class="type">uint8_t</span> ID;								<span class="comment">//定义用于存放ID号的变量</span></span><br><span class="line"><span class="type">int16_t</span> AX, AY, AZ, GX, GY, GZ;			<span class="comment">//定义用于存放各个数据的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	MPU6050_Init();		<span class="comment">//MPU6050初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示ID号*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;ID:&quot;</span>);		<span class="comment">//显示静态字符串</span></span><br><span class="line">	ID = MPU6050_GetID();				<span class="comment">//获取MPU6050的ID号</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>, <span class="number">4</span>, ID, <span class="number">2</span>);		<span class="comment">//OLED显示ID号</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		MPU6050_GetData(&amp;AX, &amp;AY, &amp;AZ, &amp;GX, &amp;GY, &amp;GZ);		<span class="comment">//获取MPU6050的数据</span></span><br><span class="line">		OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">1</span>, AX, <span class="number">5</span>);					<span class="comment">//OLED显示数据</span></span><br><span class="line">		OLED_ShowSignedNum(<span class="number">3</span>, <span class="number">1</span>, AY, <span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">4</span>, <span class="number">1</span>, AZ, <span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">8</span>, GX, <span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">3</span>, <span class="number">8</span>, GY, <span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">4</span>, <span class="number">8</span>, GZ, <span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="I2C通信外设"><a href="#I2C通信外设" class="headerlink" title="I2C通信外设"></a>I2C通信外设</h2><p>STM32内部集成了硬件I2C收发电路，可以由硬件自动执行时钟生成、起始终止条件生成、应答位收发、数据收发等功能，减轻CPU的负担</p>
<p>支持多主机模型</p>
<p>支持7位&#x2F;10位地址模式</p>
<p>支持不同的通讯速度，标准速度(高达100 kHz)，快速(高达400 kHz)<br>支持DMA</p>
<p>兼容SMBus协议</p>
<p>STM32F103C8T6 硬件I2C资源：I2C1、I2C2</p>
<h3 id="硬件结构图"><a href="#硬件结构图" class="headerlink" title="硬件结构图"></a>硬件结构图</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508175628888.png" alt="image-20240508175628888"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508175702958.png" alt="image-20240508175702958"></p>
<h3 id="主机-发送-接收-流程"><a href="#主机-发送-接收-流程" class="headerlink" title="主机 发送&amp;接收 流程"></a>主机 发送&amp;接收 流程</h3><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508180134158.png" alt="image-20240508180134158" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240508180212982.png" alt="image-20240508180212982" style="zoom:33%;" />

<h2 id="硬件I2C读写MPU6050（HLCZ）"><a href="#硬件I2C读写MPU6050（HLCZ）" class="headerlink" title="硬件I2C读写MPU6050（HLCZ）"></a>硬件I2C读写MPU6050（HLCZ）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">MPU6050.c</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS		0xD0		<span class="comment">//MPU6050的I2C从机地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：MPU6050等待事件</span></span><br><span class="line"><span class="comment">  * 参    数：同I2C_CheckEvent</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> Timeout;</span><br><span class="line">	Timeout = <span class="number">10000</span>;									<span class="comment">//给定超时计数时间</span></span><br><span class="line">	<span class="keyword">while</span> (I2C_CheckEvent(I2Cx, I2C_EVENT) != SUCCESS)	<span class="comment">//循环等待指定事件</span></span><br><span class="line">	&#123;</span><br><span class="line">		Timeout --;										<span class="comment">//等待时，计数值自减</span></span><br><span class="line">		<span class="keyword">if</span> (Timeout == <span class="number">0</span>)								<span class="comment">//自减到0后，等待超时</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*超时的错误处理代码，可以添加到此处*/</span></span><br><span class="line">			<span class="keyword">break</span>;										<span class="comment">//跳出等待，不等了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：MPU6050写寄存器</span></span><br><span class="line"><span class="comment">  * 参    数：RegAddress 寄存器地址，范围：参考MPU6050手册的寄存器描述</span></span><br><span class="line"><span class="comment">  * 参    数：Data 要写入寄存器的数据，范围：0x00~0xFF</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress, <span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*步骤参考流程图*/</span></span><br><span class="line">	I2C_GenerateSTART(I2C2, ENABLE);										<span class="comment">//硬件I2C生成起始条件</span></span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);					<span class="comment">//等待EV5</span></span><br><span class="line">	</span><br><span class="line">	I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);	<span class="comment">//硬件I2C发送从机地址，方向为发送</span></span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);	<span class="comment">//等待EV6</span></span><br><span class="line">	</span><br><span class="line">	I2C_SendData(I2C2, RegAddress);											<span class="comment">//硬件I2C发送寄存器地址</span></span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING);			<span class="comment">//等待EV8</span></span><br><span class="line">	</span><br><span class="line">	I2C_SendData(I2C2, Data);												<span class="comment">//硬件I2C发送数据</span></span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);				<span class="comment">//等待EV8_2</span></span><br><span class="line">	</span><br><span class="line">	I2C_GenerateSTOP(I2C2, ENABLE);											<span class="comment">//硬件I2C生成终止条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：MPU6050读寄存器</span></span><br><span class="line"><span class="comment">  * 参    数：RegAddress 寄存器地址，范围：参考MPU6050手册的寄存器描述</span></span><br><span class="line"><span class="comment">  * 返 回 值：读取寄存器的数据，范围：0x00~0xFF</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> Data;</span><br><span class="line">	</span><br><span class="line">	I2C_GenerateSTART(I2C2, ENABLE);										<span class="comment">//硬件I2C生成起始条件</span></span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);					<span class="comment">//等待EV5</span></span><br><span class="line">	</span><br><span class="line">	I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);	<span class="comment">//硬件I2C发送从机地址，方向为发送</span></span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);	<span class="comment">//等待EV6</span></span><br><span class="line">	</span><br><span class="line">	I2C_SendData(I2C2, RegAddress);											<span class="comment">//硬件I2C发送寄存器地址</span></span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);				<span class="comment">//等待EV8_2</span></span><br><span class="line">	</span><br><span class="line">	I2C_GenerateSTART(I2C2, ENABLE);										<span class="comment">//硬件I2C生成重复起始条件</span></span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);					<span class="comment">//等待EV5</span></span><br><span class="line">	</span><br><span class="line">	I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Receiver);		<span class="comment">//硬件I2C发送从机地址，方向为接收</span></span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);		<span class="comment">//等待EV6</span></span><br><span class="line">	</span><br><span class="line">	I2C_AcknowledgeConfig(I2C2, DISABLE);									<span class="comment">//在接收最后一个字节之前提前将应答失能</span></span><br><span class="line">	I2C_GenerateSTOP(I2C2, ENABLE);											<span class="comment">//在接收最后一个字节之前提前申请停止条件</span></span><br><span class="line">	</span><br><span class="line">	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED);				<span class="comment">//等待EV7</span></span><br><span class="line">	Data = I2C_ReceiveData(I2C2);											<span class="comment">//接收数据寄存器</span></span><br><span class="line">	</span><br><span class="line">	I2C_AcknowledgeConfig(I2C2, ENABLE);									<span class="comment">//将应答恢复为使能，为了不影响后续可能产生的读取多字节操作</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：MPU6050初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);		<span class="comment">//开启I2C2的时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);					<span class="comment">//将PB10和PB11引脚初始化为复用开漏输出</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*I2C初始化*/</span></span><br><span class="line">	I2C_InitTypeDef I2C_InitStructure;						<span class="comment">//定义结构体变量</span></span><br><span class="line">	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;				<span class="comment">//模式，选择为I2C模式</span></span><br><span class="line">	I2C_InitStructure.I2C_ClockSpeed = <span class="number">50000</span>;				<span class="comment">//时钟速度，选择为50KHz</span></span><br><span class="line">	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;		<span class="comment">//时钟占空比，选择Tlow/Thigh = 2</span></span><br><span class="line">	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;				<span class="comment">//应答，选择使能</span></span><br><span class="line">	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;	</span><br><span class="line">    <span class="comment">//应答地址，选择7位，从机模式下才有效</span></span><br><span class="line">	I2C_InitStructure.I2C_OwnAddress1 = <span class="number">0x00</span>;				<span class="comment">//自身地址，从机模式下才有效</span></span><br><span class="line">	I2C_Init(I2C2, &amp;I2C_InitStructure);						<span class="comment">//将结构体变量交给I2C_Init，配置I2C2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*I2C使能*/</span></span><br><span class="line">	I2C_Cmd(I2C2, ENABLE);									<span class="comment">//使能I2C2，开始运行</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*MPU6050寄存器初始化，需要对照MPU6050手册的寄存器描述配置，此处仅配置了部分重要的寄存器*/</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_1, <span class="number">0x01</span>);				<span class="comment">//电源管理寄存器1，取消睡眠模式，选择时钟源为X轴陀螺仪</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_2, <span class="number">0x00</span>);				<span class="comment">//电源管理寄存器2，保持默认值0，所有轴均不待机</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_SMPLRT_DIV, <span class="number">0x09</span>);				<span class="comment">//采样率分频寄存器，配置采样率</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_CONFIG, <span class="number">0x06</span>);					<span class="comment">//配置寄存器，配置DLPF</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_GYRO_CONFIG, <span class="number">0x18</span>);			<span class="comment">//陀螺仪配置寄存器，选择满量程为±2000°/s</span></span><br><span class="line">	MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, <span class="number">0x18</span>);			<span class="comment">//加速度计配置寄存器，选择满量程为±16g</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：MPU6050获取ID号</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：MPU6050的ID号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);		<span class="comment">//返回WHO_AM_I寄存器的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：MPU6050获取数据</span></span><br><span class="line"><span class="comment">  * 参    数：AccX AccY AccZ 加速度计X、Y、Z轴的数据，使用输出参数的形式返回，范围：-32768~32767</span></span><br><span class="line"><span class="comment">  * 参    数：GyroX GyroY GyroZ 陀螺仪X、Y、Z轴的数据，使用输出参数的形式返回，范围：-32768~32767</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX, <span class="type">int16_t</span> *AccY, <span class="type">int16_t</span> *AccZ, </span></span><br><span class="line"><span class="params">						<span class="type">int16_t</span> *GyroX, <span class="type">int16_t</span> *GyroY, <span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> DataH, DataL;								<span class="comment">//定义数据高8位和低8位的变量</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);		<span class="comment">//读取加速度计X轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);		<span class="comment">//读取加速度计X轴的低8位数据</span></span><br><span class="line">	*AccX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);		<span class="comment">//读取加速度计Y轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);		<span class="comment">//读取加速度计Y轴的低8位数据</span></span><br><span class="line">	*AccY = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);		<span class="comment">//读取加速度计Z轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);		<span class="comment">//读取加速度计Z轴的低8位数据</span></span><br><span class="line">	*AccZ = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);		<span class="comment">//读取陀螺仪X轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);		<span class="comment">//读取陀螺仪X轴的低8位数据</span></span><br><span class="line">	*GyroX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);		<span class="comment">//读取陀螺仪Y轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);		<span class="comment">//读取陀螺仪Y轴的低8位数据</span></span><br><span class="line">	*GyroY = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);		<span class="comment">//读取陀螺仪Z轴的高8位数据</span></span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);		<span class="comment">//读取陀螺仪Z轴的低8位数据</span></span><br><span class="line">	*GyroZ = (DataH &lt;&lt; <span class="number">8</span>) | DataL;						<span class="comment">//数据拼接，通过输出参数返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="第十一章：SPI通信"><a href="#第十一章：SPI通信" class="headerlink" title="第十一章：SPI通信"></a>第十一章：SPI通信</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><ul>
<li>SPI（Serial Peripheral Interface）是由Motorola公司开发的一种通用数据总线</li>
<li>四根通信线：SCK（时钟信号）、SS（从机选择线）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）</li>
</ul>
<blockquote>
<p>Master Output Slave Input ：主机输出，从机输入</p>
</blockquote>
<ul>
<li>同步，全双工</li>
<li>支持总线挂载多设备（一主多从）</li>
</ul>
<p>SPI和I2C对比：</p>
<p>I2C硬件资源（通讯线）少，但是要花费较多的软件资源</p>
<p>SPI硬件资源（通讯线）多，但是有时可能会浪费硬件资源</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509102828117.png" alt="image-20240509102828117"></p>
<p>图一：W25Q64</p>
<p>图二：SPI通信的OIED</p>
<p>图三：2.4G无线通信，NRF24L01</p>
<p>图四:SD卡</p>
<h2 id="硬件电路-3"><a href="#硬件电路-3" class="headerlink" title="硬件电路"></a>硬件电路</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509103049131.png" alt="image-20240509103049131"></p>
<ul>
<li>所有SPI设备的SCK、MOSI、MISO分别连在一起</li>
<li>主机另外引出多条SS控制线，分别接到各从机的SS引脚（指定需要通信的设备）</li>
</ul>
<blockquote>
<p>主机和所有从机都有一条SS线，所有从机共用SCK,MISO,MOSI线向主机通信</p>
</blockquote>
<ul>
<li>输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入</li>
<li>当从机的SS引脚为高电平（未被选中）时，MISO必须切换为高阻态（相当于断开引脚）</li>
</ul>
<h2 id="移位示意图"><a href="#移位示意图" class="headerlink" title="移位示意图"></a>移位示意图</h2><p>波特率发生器 的上升沿，主机和从机的移位寄存器从左移一位，移出去的位放到引脚上</p>
<blockquote>
<p>此时，两个移位寄存器都有一个空位</p>
</blockquote>
<p>波特率发生器 的下降沿，引脚上的位，采样输入到移位寄存器的最低位</p>
<blockquote>
<p>即，   把主机上移出的位 放到从机寄存器的空位上</p>
<p>同时，把从机上移出的位 放到主机寄存器的空位上</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509105119664.png" alt="image-20240509105119664"></p>
<p>最后实现，主机和从机一个字节的<strong>数据交换</strong></p>
<p>SPI就是基于这种 <strong>数据交换</strong> 实现 发送和接收</p>
<blockquote>
<p>发送数据时，会收到 原来 从机寄存器 存的数据（不看即可）</p>
<p>接收数据，也要发送数据给从机，此时我们可以发0X00 或0XFF</p>
</blockquote>
<h2 id="SPI时序"><a href="#SPI时序" class="headerlink" title="SPI时序"></a>SPI时序</h2><h3 id="起始条件-1"><a href="#起始条件-1" class="headerlink" title="起始条件"></a>起始条件</h3><p>SS从高电平切换到低电平</p>
<h3 id="终止条件-1"><a href="#终止条件-1" class="headerlink" title="终止条件"></a>终止条件</h3><p>SS从低电平切换到高电平</p>
<blockquote>
<p>SS处于低电平时，表示主机正在通信</p>
</blockquote>
<h3 id="SPI时序单元，交换一个字节"><a href="#SPI时序单元，交换一个字节" class="headerlink" title="SPI时序单元，交换一个字节"></a>SPI时序单元，交换一个字节</h3><p>SPI时序单元有四种模式，用 CPOL和CPHA 置1&#x2F;0选择模式</p>
<h4 id="模式0"><a href="#模式0" class="headerlink" title="模式0"></a>模式0</h4><p>CPOL&#x3D;0：空闲状态时，SCK为低电平<br>CPHA&#x3D;0：SCK第一个边沿移入数据，第二个边沿移出数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509111851243.png" alt="image-20240509111851243"></p>
<blockquote>
<p>在此模式下 MOSI和MISO 要在第一个边沿之前 移出一个数据（放到引脚上），以便于 在 第一个边沿 时，移入数据</p>
</blockquote>
<h4 id="模式1"><a href="#模式1" class="headerlink" title="模式1"></a>模式1</h4><p>CPOL&#x3D;0：空闲状态时，SCK为低电平<br>CPHA&#x3D;1：SCK第一个边沿移出数据，第二个边沿移入数据</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509112340952.png" alt="image-20240509112340952" style="zoom:80%;" />

<h4 id="模式2"><a href="#模式2" class="headerlink" title="模式2"></a>模式2</h4><p>CPOL&#x3D;1：空闲状态时，SCK为高电平<br>CPHA&#x3D;0：SCK第一个边沿移入数据，第二个边沿移出数据</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509112353643.png" alt="image-20240509112353643" style="zoom: 80%;" />

<h4 id="模式3"><a href="#模式3" class="headerlink" title="模式3"></a>模式3</h4><p>CPOL&#x3D;1：空闲状态时，SCK为高电平<br>CPHA&#x3D;1：SCK第一个边沿移出数据，第二个边沿移入数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509112413965.png" alt="image-20240509112413965"></p>
<h3 id="指定地址写-1"><a href="#指定地址写-1" class="headerlink" title="指定地址写"></a>指定地址写</h3><p>向SS指定的设备，发送写指令（0x02），随后在指定地址下，写入指定数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509113017480.png" alt="image-20240509113017480"></p>
<h3 id="指定地址读-1"><a href="#指定地址读-1" class="headerlink" title="指定地址读"></a>指定地址读</h3><p>向SS指定的设备，发送读指令（0x03），随后在指定地址下，读取从机数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509113036596.png" alt="image-20240509113036596"></p>
<h2 id="W25Q64"><a href="#W25Q64" class="headerlink" title="W25Q64"></a>W25Q64</h2><ul>
<li>W25Qxx系列是一种低成本、小型化、使用简单的非易失性（掉电不丢失）存储器，常应用于数据存储、字库存储、固件程序存储等场景<br>存储介质：Nor Flash（闪存）<br>时钟频率：80MHz &#x2F; 160MHz (Dual SPI) &#x2F; 320MHz (Quad SPI)</li>
<li>存储容量（24位地址）：<br>W25Q40：	  4Mbit &#x2F; 512KByte<br>W25Q80：	  8Mbit &#x2F; 1MByte<br>W25Q16：	  16Mbit &#x2F; 2MByte<br>W25Q32：	  32Mbit &#x2F; 4MByte<br>W25Q64：	  64Mbit &#x2F; 8MByte<br>W25Q128：  128Mbit &#x2F; 16MByte<br>W25Q256：  256Mbit &#x2F; 32MByte</li>
</ul>
<h3 id="硬件电路-4"><a href="#硬件电路-4" class="headerlink" title="硬件电路"></a>硬件电路</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509114451650.png" alt="image-20240509114451650"></p>
<h3 id="Flash使用注意事项"><a href="#Flash使用注意事项" class="headerlink" title="Flash使用注意事项"></a>Flash使用注意事项</h3><ul>
<li>写入操作时：<ul>
<li>写入操作前，必须先进行写使能</li>
<li>每个数据位只能由1改写为0，不能由0改写为1</li>
<li>写入数据前必须先擦除，擦除后，所有数据位变为1</li>
<li>擦除必须按最小擦除单元进行（全部擦除，按扇区擦除，按块擦除）</li>
<li>连续写入多字节时，最多写入一页的数据，超过页尾位置的数据，会回到页首覆盖写入</li>
<li>写入操作结束后，芯片进入忙状态，不响应新的读写操作</li>
</ul>
</li>
<li>读取操作时：<ul>
<li>直接调用读取时序，无需使能，无需额外操作，没有页的限制，读取操作结束后不会进入忙状态，但不能在忙状态时读取</li>
</ul>
</li>
</ul>
<h2 id="软件SPI读写W25Q64"><a href="#软件SPI读写W25Q64" class="headerlink" title="软件SPI读写W25Q64"></a>软件SPI读写W25Q64</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509120635494.png" alt="image-20240509120635494"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">myspi</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*引脚配置层*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：SPI写SS引脚电平</span></span><br><span class="line"><span class="comment">  * 参    数：BitValue 协议层传入的当前需要写入SS的电平，范围0~1</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数需要用户实现内容，当BitValue为0时，需要置SS为低电平，当BitValue为1时，需要置SS为高电平</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOA, GPIO_Pin_4, (BitAction)BitValue);		<span class="comment">//根据BitValue，设置SS引脚的电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：SPI写SCK引脚电平</span></span><br><span class="line"><span class="comment">  * 参    数：BitValue 协议层传入的当前需要写入SCK的电平，范围0~1</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数需要用户实现内容，当BitValue为0时，需要置SCK为低电平，当BitValue为1时，需要置SCK为高电平</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SCK</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOA, GPIO_Pin_5, (BitAction)BitValue);		<span class="comment">//根据BitValue，设置SCK引脚的电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：SPI写MOSI引脚电平</span></span><br><span class="line"><span class="comment">  * 参    数：BitValue 协议层传入的当前需要写入MOSI的电平，范围0~0xFF</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数需要用户实现内容，当BitValue为0时，需要置MOSI为低电平，当BitValue非0时，需要置MOSI为高电平</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_MOSI</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOA, GPIO_Pin_7, (BitAction)BitValue);		</span><br><span class="line">    <span class="comment">//根据BitValue，设置MOSI引脚的电平，BitValue要实现非0即1的特性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：I2C读MISO引脚电平</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：协议层需要得到的当前MISO的电平，范围0~1</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数需要用户实现内容，当前MISO为低电平时，返回0，当前MISO为高电平时，返回1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_R_MISO</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6);			<span class="comment">//读取MISO电平并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：SPI初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数需要用户实现内容，实现SS、SCK、MOSI和MISO引脚的初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO初始化*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA4、PA5和PA7引脚初始化为推挽输出</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					<span class="comment">//将PA6引脚初始化为上拉输入</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*设置默认电平*/</span></span><br><span class="line">	MySPI_W_SS(<span class="number">1</span>);											<span class="comment">//SS默认高电平</span></span><br><span class="line">	MySPI_W_SCK(<span class="number">0</span>);											<span class="comment">//SCK默认低电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*协议层*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：SPI起始</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MySPI_W_SS(<span class="number">0</span>);				<span class="comment">//拉低SS，开始时序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：SPI终止</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MySPI_W_SS(<span class="number">1</span>);				<span class="comment">//拉高SS，终止时序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：SPI交换传输一个字节，使用SPI模式0</span></span><br><span class="line"><span class="comment">  * 参    数：ByteSend 要发送的一个字节</span></span><br><span class="line"><span class="comment">  * 返 回 值：接收的一个字节</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i, ByteReceive = <span class="number">0x00</span>;					<span class="comment">//定义接收的数据，并赋初值0x00，此处必须赋初值0x00，后面会用到</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)						<span class="comment">//循环8次，依次交换每一位数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		MySPI_W_MOSI(ByteSend &amp; (<span class="number">0x80</span> &gt;&gt; i));		<span class="comment">//使用掩码的方式取出ByteSend的指定一位数据并写入到MOSI线</span></span><br><span class="line">		MySPI_W_SCK(<span class="number">1</span>);								<span class="comment">//拉高SCK，上升沿移出数据</span></span><br><span class="line">		<span class="keyword">if</span> (MySPI_R_MISO() == <span class="number">1</span>)&#123;ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);&#125;	<span class="comment">//读取MISO数据，并存储到Byte变量</span></span><br><span class="line">		<span class="comment">//当MISO为1时，置变量指定位为1，当MISO为0时，不做处理，指定位为默认的初值0</span></span><br><span class="line">		MySPI_W_SCK(<span class="number">0</span>);								<span class="comment">//拉低SCK，下降沿移入数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ByteReceive;								<span class="comment">//返回接收到的一个字节数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">w25q64.c</span><br><span class="line">    </span><br><span class="line"><span class="comment">//W25Q64初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MySPI_Init();					<span class="comment">//先初始化底层的SPI</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MPU6050读取ID号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span> *MID, <span class="type">uint16_t</span> *DID)</span></span><br><span class="line">&#123;</span><br><span class="line">	MySPI_Start();								<span class="comment">//SPI起始</span></span><br><span class="line">	MySPI_SwapByte(W25Q64_JEDEC_ID);			<span class="comment">//交换发送读取ID的指令</span></span><br><span class="line">	*MID = MySPI_SwapByte(W25Q64_DUMMY_BYTE);	<span class="comment">//交换接收MID，通过输出参数返回</span></span><br><span class="line">	*DID = MySPI_SwapByte(W25Q64_DUMMY_BYTE);	<span class="comment">//交换接收DID高8位</span></span><br><span class="line">	*DID &lt;&lt;= <span class="number">8</span>;									<span class="comment">//高8位移到高位</span></span><br><span class="line">	*DID |= MySPI_SwapByte(W25Q64_DUMMY_BYTE);	<span class="comment">//或上交换接收DID的低8位，通过输出参数返回</span></span><br><span class="line">	MySPI_Stop();								<span class="comment">//SPI终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//W25Q64写使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WriteEnable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MySPI_Start();								<span class="comment">//SPI起始</span></span><br><span class="line">	MySPI_SwapByte(W25Q64_WRITE_ENABLE);		<span class="comment">//交换发送写使能的指令</span></span><br><span class="line">	MySPI_Stop();								<span class="comment">//SPI终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//W25Q64等待忙</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WaitBusy</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> Timeout;</span><br><span class="line">	MySPI_Start();								<span class="comment">//SPI起始</span></span><br><span class="line">	MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1);				<span class="comment">//交换发送读状态寄存器1的指令</span></span><br><span class="line">	Timeout = <span class="number">100000</span>;							<span class="comment">//给定超时计数时间</span></span><br><span class="line">	<span class="keyword">while</span> ((MySPI_SwapByte(W25Q64_DUMMY_BYTE) &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)	<span class="comment">//循环等待忙标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Timeout --;								<span class="comment">//等待时，计数值自减</span></span><br><span class="line">		<span class="keyword">if</span> (Timeout == <span class="number">0</span>)						<span class="comment">//自减到0后，等待超时</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*超时的错误处理代码，可以添加到此处*/</span></span><br><span class="line">			<span class="keyword">break</span>;								<span class="comment">//跳出等待，不等了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	MySPI_Stop();								<span class="comment">//SPI终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：W25Q64页编程</span></span><br><span class="line"><span class="comment">  * 参    数：Address 页编程的起始地址，范围：0x000000~0x7FFFFF</span></span><br><span class="line"><span class="comment">  * 参    数：DataArray	用于写入数据的数组</span></span><br><span class="line"><span class="comment">  * 参    数：Count 要写入数据的数量，范围：0~256</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：写入的地址范围不能跨页</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> *DataArray, <span class="type">uint16_t</span> Count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> i;</span><br><span class="line">	</span><br><span class="line">	W25Q64_WriteEnable();						<span class="comment">//写使能</span></span><br><span class="line">	</span><br><span class="line">	MySPI_Start();								<span class="comment">//SPI起始</span></span><br><span class="line">	MySPI_SwapByte(W25Q64_PAGE_PROGRAM);		<span class="comment">//交换发送页编程的指令</span></span><br><span class="line">	MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);				<span class="comment">//交换发送地址23~16位</span></span><br><span class="line">	MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>);				<span class="comment">//交换发送地址15~8位</span></span><br><span class="line">	MySPI_SwapByte(Address);					<span class="comment">//交换发送地址7~0位</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Count; i ++)				<span class="comment">//循环Count次</span></span><br><span class="line">	&#123;</span><br><span class="line">		MySPI_SwapByte(DataArray[i]);			<span class="comment">//依次在起始地址后写入数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	MySPI_Stop();								<span class="comment">//SPI终止</span></span><br><span class="line">	</span><br><span class="line">	W25Q64_WaitBusy();							<span class="comment">//等待忙</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：W25Q64扇区擦除（4KB）</span></span><br><span class="line"><span class="comment">  * 参    数：Address 指定扇区的地址，范围：0x000000~0x7FFFFF</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	W25Q64_WriteEnable();						<span class="comment">//写使能</span></span><br><span class="line">	</span><br><span class="line">	MySPI_Start();								<span class="comment">//SPI起始</span></span><br><span class="line">	MySPI_SwapByte(W25Q64_SECTOR_ERASE_4KB);	<span class="comment">//交换发送扇区擦除的指令</span></span><br><span class="line">	MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);				<span class="comment">//交换发送地址23~16位</span></span><br><span class="line">	MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>);				<span class="comment">//交换发送地址15~8位</span></span><br><span class="line">	MySPI_SwapByte(Address);					<span class="comment">//交换发送地址7~0位</span></span><br><span class="line">	MySPI_Stop();								<span class="comment">//SPI终止</span></span><br><span class="line">	</span><br><span class="line">	W25Q64_WaitBusy();							<span class="comment">//等待忙</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：W25Q64读取数据</span></span><br><span class="line"><span class="comment">  * 参    数：Address 读取数据的起始地址，范围：0x000000~0x7FFFFF</span></span><br><span class="line"><span class="comment">  * 参    数：DataArray 用于接收读取数据的数组，通过输出参数返回</span></span><br><span class="line"><span class="comment">  * 参    数：Count 要读取数据的数量，范围：0~0x800000</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> *DataArray, <span class="type">uint32_t</span> Count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	MySPI_Start();								<span class="comment">//SPI起始</span></span><br><span class="line">	MySPI_SwapByte(W25Q64_READ_DATA);			<span class="comment">//交换发送读取数据的指令</span></span><br><span class="line">	MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);				<span class="comment">//交换发送地址23~16位</span></span><br><span class="line">	MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>);				<span class="comment">//交换发送地址15~8位</span></span><br><span class="line">	MySPI_SwapByte(Address);					<span class="comment">//交换发送地址7~0位</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Count; i ++)				<span class="comment">//循环Count次</span></span><br><span class="line">	&#123;</span><br><span class="line">		DataArray[i] = MySPI_SwapByte(W25Q64_DUMMY_BYTE);	<span class="comment">//依次在起始地址后读取数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	MySPI_Stop();								<span class="comment">//SPI终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> MID;							<span class="comment">//定义用于存放MID号的变量</span></span><br><span class="line"><span class="type">uint16_t</span> DID;							<span class="comment">//定义用于存放DID号的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ArrayWrite[] = &#123;<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>&#125;;	<span class="comment">//定义要写入数据的测试数组</span></span><br><span class="line"><span class="type">uint8_t</span> ArrayRead[<span class="number">4</span>];								<span class="comment">//定义要读取数据的测试数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();						<span class="comment">//OLED初始化</span></span><br><span class="line">	W25Q64_Init();						<span class="comment">//W25Q64初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;MID:   DID:&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;W:&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;R:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示ID号*/</span></span><br><span class="line">	W25Q64_ReadID(&amp;MID, &amp;DID);			<span class="comment">//获取W25Q64的ID号</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>, <span class="number">5</span>, MID, <span class="number">2</span>);		<span class="comment">//显示MID</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>, <span class="number">12</span>, DID, <span class="number">4</span>);		<span class="comment">//显示DID</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*W25Q64功能函数测试*/</span></span><br><span class="line">	W25Q64_SectorErase(<span class="number">0x000000</span>);					<span class="comment">//扇区擦除</span></span><br><span class="line">	W25Q64_PageProgram(<span class="number">0x000000</span>, ArrayWrite, <span class="number">4</span>);	<span class="comment">//将写入数据的测试数组写入到W25Q64中</span></span><br><span class="line">	</span><br><span class="line">	W25Q64_ReadData(<span class="number">0x000000</span>, ArrayRead, <span class="number">4</span>);		<span class="comment">//读取刚写入的测试数据到读取数据的测试数组中</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示数据*/</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>, <span class="number">3</span>, ArrayWrite[<span class="number">0</span>], <span class="number">2</span>);		<span class="comment">//显示写入数据的测试数组</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>, <span class="number">6</span>, ArrayWrite[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>, <span class="number">9</span>, ArrayWrite[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>, <span class="number">12</span>, ArrayWrite[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>, <span class="number">3</span>, ArrayRead[<span class="number">0</span>], <span class="number">2</span>);			<span class="comment">//显示读取数据的测试数组</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>, <span class="number">6</span>, ArrayRead[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>, <span class="number">9</span>, ArrayRead[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>, <span class="number">12</span>, ArrayRead[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SPI通信外设"><a href="#SPI通信外设" class="headerlink" title="SPI通信外设"></a>SPI通信外设</h2><h2 id="硬件SPI读写W25Q64"><a href="#硬件SPI读写W25Q64" class="headerlink" title="硬件SPI读写W25Q64"></a>硬件SPI读写W25Q64</h2><h1 id="第十二章：-RTC实时时钟"><a href="#第十二章：-RTC实时时钟" class="headerlink" title="第十二章： RTC实时时钟"></a>第十二章： RTC实时时钟</h1><h2 id="Unix时间戳"><a href="#Unix时间戳" class="headerlink" title="Unix时间戳"></a>Unix时间戳</h2><ul>
<li>Unix 时间戳（Unix Timestamp）定义为从UTC&#x2F;GMT的1970年1月1日0时0分0秒开始所经过的秒数，不考虑闰秒</li>
</ul>
<blockquote>
<p>1970年从0秒  开始加  ，现在已经加到 16亿了</p>
<p>用软件资源计算现在的时间</p>
</blockquote>
<ul>
<li>时间戳存储在一个秒计数器中，秒计数器为32位&#x2F;64位的整型变量</li>
<li>世界上所有时区的秒计数器相同，不同时区通过添加偏移来得到当地时间</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509145941452.png" alt="image-20240509145941452"></p>
<h2 id="GMT-UTC"><a href="#GMT-UTC" class="headerlink" title="GMT&#x2F;UTC"></a>GMT&#x2F;UTC</h2><p>GMT（Greenwich Mean Time）格林尼治标准时间是一种以地球自转为基础的时间计量系统。它将地球自转一周的时间间隔等分为24小时，以此确定计时标准</p>
<p>UTC（Universal Time Coordinated）协调世界时是一种以原子钟为基础的时间计量系统。它规定铯133原子基态的两个超精细能级间在零磁场下跃迁辐射9,192,631,770周所持续的时间为1秒。当原子钟计时一天的时间与地球自转一周的时间相差超过0.9秒时，UTC会执行闰秒来保证其计时与地球自转的协调一致</p>
<h2 id="时间戳转换-time-h"><a href="#时间戳转换-time-h" class="headerlink" title="时间戳转换 time.h"></a>时间戳转换 time.h</h2><p>C语言的time.h模块提供了时间获取和时间戳转换的相关函数，可以方便地进行秒计数器、日期时间和字符串之间的转换</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-standard-library-time-h.html">https://www.runoob.com/cprogramming/c-standard-library-time-h.html</a></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>time_t time(time_t*);</td>
<td>获取系统时钟</td>
</tr>
<tr>
<td>struct tm* gmtime(const time_t*);</td>
<td>秒计数器转换为日期时间（格林尼治时间）</td>
</tr>
<tr>
<td>struct tm* localtime(const time_t*);</td>
<td>秒计数器转换为日期时间（当地时间）</td>
</tr>
<tr>
<td>time_t mktime(struct tm*);</td>
<td>日期时间转换为秒计数器（当地时间）</td>
</tr>
<tr>
<td>char* ctime(const time_t*);</td>
<td>秒计数器转换为字符串（默认格式）</td>
</tr>
<tr>
<td>char* asctime(const struct tm*);</td>
<td>日期时间转换为字符串（默认格式）</td>
</tr>
<tr>
<td>size_t strftime(char*, size_t, const char*, const struct tm*);</td>
<td>日期时间转换为字符串（自定义格式）</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509150932982.png" alt="image-20240509150932982" style="zoom:50%;" />

<h2 id="BKP备份寄存器"><a href="#BKP备份寄存器" class="headerlink" title="BKP备份寄存器"></a>BKP备份寄存器</h2><ul>
<li>BKP（Backup Registers）备份寄存器</li>
<li>BKP可用于存储用户应用程序数据。当VDD（2.0<del>3.6V）电源（主电源）被切断，他们仍然由VBAT（1.8</del>3.6V）（备用电池电源）维持供电。当系统在待机模式下被唤醒，或系统复位或电源复位时，他们也不会被复位</li>
<li>TAMPER引脚产生的侵入事件将所有备份寄存器内容清除</li>
<li>RTC引脚输出RTC校准时钟、RTC闹钟脉冲或者秒脉冲</li>
<li>存储RTC时钟校准寄存器</li>
<li>用户数据存储容量：<br>20字节（中容量和小容量）&#x2F; 84字节（大容量和互联型）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509153401592.png" alt="image-20240509153401592"></p>
<h2 id="RTC简介"><a href="#RTC简介" class="headerlink" title="RTC简介"></a>RTC简介</h2><ul>
<li>RTC（Real Time Clock）实时时钟</li>
<li>RTC是一个独立的定时器，可为系统提供时钟和日历的功能</li>
<li>RTC和时钟配置系统处于后备区域，系统复位时数据不清零，VDD（2.0<del>3.6V）断电后可借助VBAT（1.8</del>3.6V）供电继续走时</li>
<li>32位的可编程计数器，可对应<strong>Unix时间戳</strong>的秒计数器（只有一个 秒 寄存器）——&gt; 通过 软件计算（调 time.h）获取时间</li>
<li>20位的可编程预分频器，可适配不同频率的输入时钟</li>
<li>可选择三种RTC时钟源：<ul>
<li>​	HSE时钟除以128（通常为8MHz&#x2F;128）</li>
<li>​	LSE振荡器时钟（通常为32.768KHz）</li>
<li>​	LSI振荡器时钟（40KHz）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509154655238.png" alt="image-20240509154655238"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509154735194.png" alt="image-20240509154735194"></p>
<p>STM32最小系统板中，需要添加备用电池和外部低速晶振（外部电路）</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>执行以下操作将使能对BKP和RTC的访问：<br>    设置RCC_APB1ENR的PWREN和BKPEN，使能PWR和BKP时钟<br>    设置PWR_CR的DBP，使能对BKP和RTC的访问<br>若在读取RTC寄存器时，RTC的APB1接口曾经处于禁止状态，则软件首先必须等待RTC_CRL寄存器中的RSF位（寄存器同步标志）被硬件置1<br>必须设置RTC_CRL寄存器中的CNF位，使RTC进入配置模式后，才能写入RTC_PRL、RTC_CNT、RTC_ALR寄存器<br>对RTC任何寄存器的写操作，都必须在前一次写操作结束后进行。可以通过查询RTC_CR寄存器中的RTOFF状态位，判断RTC寄存器是否处于更新中。仅当RTOFF状态位是1时，才可以写入RTC寄存器</p>
<h2 id="读写备份寄存器"><a href="#读写备份寄存器" class="headerlink" title="读写备份寄存器"></a>读写备份寄存器</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509160541578.png" alt="image-20240509160541578"></p>
<p>VB引脚可以接 纽扣电池</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">uint16_t</span> ArrayWrite[] = &#123;<span class="number">0x1234</span>, <span class="number">0x5678</span>&#125;;	<span class="comment">//定义要写入数据的测试数组</span></span><br><span class="line">	<span class="type">uint16_t</span> ArrayRead[<span class="number">2</span>];						<span class="comment">//定义要读取数据的测试数组</span></span><br><span class="line"></span><br><span class="line">	OLED_Init();				<span class="comment">//OLED初始化</span></span><br><span class="line">	Key_Init();					<span class="comment">//按键初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);		<span class="comment">//开启BKP的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*备份寄存器访问使能*/</span></span><br><span class="line">	PWR_BackupAccessCmd(ENABLE);							<span class="comment">//使用PWR开启对备份寄存器的访问</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KeyNum = Key_GetNum();		<span class="comment">//获取按键键码</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">1</span>)			<span class="comment">//按键1按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			ArrayWrite[<span class="number">0</span>] ++;		<span class="comment">//测试数据自增</span></span><br><span class="line">			ArrayWrite[<span class="number">1</span>] ++;</span><br><span class="line">			</span><br><span class="line">			BKP_WriteBackupRegister(BKP_DR1, ArrayWrite[<span class="number">0</span>]);	<span class="comment">//写入测试数据到备份寄存器</span></span><br><span class="line">			BKP_WriteBackupRegister(BKP_DR2, ArrayWrite[<span class="number">1</span>]);</span><br><span class="line">			</span><br><span class="line">			OLED_ShowHexNum(<span class="number">1</span>, <span class="number">3</span>, ArrayWrite[<span class="number">0</span>], <span class="number">4</span>);		<span class="comment">//显示写入的测试数据</span></span><br><span class="line">			OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, ArrayWrite[<span class="number">1</span>], <span class="number">4</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ArrayRead[<span class="number">0</span>] = BKP_ReadBackupRegister(BKP_DR1);		<span class="comment">//读取备份寄存器的数据</span></span><br><span class="line">		ArrayRead[<span class="number">1</span>] = BKP_ReadBackupRegister(BKP_DR2);</span><br><span class="line">		</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">3</span>, ArrayRead[<span class="number">0</span>], <span class="number">4</span>);				<span class="comment">//显示读取的备份寄存器数据</span></span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>, <span class="number">8</span>, ArrayRead[<span class="number">1</span>], <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实时时钟"><a href="#实时时钟" class="headerlink" title="实时时钟"></a>实时时钟</h2><p>基本步骤</p>
<ul>
<li>使能PWR和BKP时钟，使能 对BKP 和RTC 的访问</li>
<li>启动RTC时钟(LSE)</li>
<li>配置RTCCLK</li>
<li>等待同步，等待上一步操作完成</li>
<li>配置预分频器，给PRL分频值</li>
<li>配置CNT</li>
<li>（非必要）配置闹钟或中断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> MyRTC_Time[] = &#123;<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">55</span>&#125;;	<span class="comment">//定义全局的时间数组，数组内容分别为年、月、日、时、分、秒</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span>;				<span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RTC初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);		<span class="comment">//开启BKP的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*备份寄存器访问使能*/</span></span><br><span class="line">	PWR_BackupAccessCmd(ENABLE);							<span class="comment">//使用PWR开启对备份寄存器的访问</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xA5A5</span>)			<span class="comment">//通过写入备份寄存器的标志位，判断RTC是否是第一次配置</span></span><br><span class="line">															<span class="comment">//if成立则执行第一次的RTC配置</span></span><br><span class="line">	&#123;</span><br><span class="line">		RCC_LSEConfig(RCC_LSE_ON);							<span class="comment">//开启LSE时钟</span></span><br><span class="line">		<span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);	<span class="comment">//等待LSE准备就绪</span></span><br><span class="line">		</span><br><span class="line">		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);				<span class="comment">//选择RTCCLK来源为LSE</span></span><br><span class="line">		RCC_RTCCLKCmd(ENABLE);								<span class="comment">//RTCCLK使能</span></span><br><span class="line">		</span><br><span class="line">		RTC_WaitForSynchro();								<span class="comment">//等待同步</span></span><br><span class="line">		RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line">		</span><br><span class="line">		RTC_SetPrescaler(<span class="number">32768</span> - <span class="number">1</span>);						<span class="comment">//设置RTC预分频器，预分频后的计数频率为1Hz</span></span><br><span class="line">		RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line">		</span><br><span class="line">		MyRTC_SetTime();									<span class="comment">//设置时间，调用此函数，全局数组里时间值刷新到RTC硬件电路</span></span><br><span class="line">		</span><br><span class="line">		BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xA5A5</span>);			</span><br><span class="line">        <span class="comment">//在备份寄存器写入自己规定的标志位，用于判断RTC是不是第一次执行配置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>													<span class="comment">//RTC不是第一次配置</span></span><br><span class="line">	&#123;</span><br><span class="line">		RTC_WaitForSynchro();								<span class="comment">//等待同步</span></span><br><span class="line">		RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果LSE无法起振导致程序卡死在初始化函数中</span></span><br><span class="line"><span class="comment">//可将初始化函数替换为下述代码，使用LSI当作RTCCLK</span></span><br><span class="line"><span class="comment">//LSI无法由备用电源供电，故主电源掉电时，RTC走时会暂停</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">void MyRTC_Init(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span></span><br><span class="line"><span class="comment">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	PWR_BackupAccessCmd(ENABLE);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	if (BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		RCC_LSICmd(ENABLE);</span></span><br><span class="line"><span class="comment">		while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span></span><br><span class="line"><span class="comment">		RCC_RTCCLKCmd(ENABLE);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		RTC_WaitForSynchro();</span></span><br><span class="line"><span class="comment">		RTC_WaitForLastTask();</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		RTC_SetPrescaler(40000 - 1);</span></span><br><span class="line"><span class="comment">		RTC_WaitForLastTask();</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		MyRTC_SetTime();</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	else</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		RCC_LSICmd(ENABLE);				//即使不是第一次配置，也需要再次开启LSI时钟</span></span><br><span class="line"><span class="comment">		while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span></span><br><span class="line"><span class="comment">		RCC_RTCCLKCmd(ENABLE);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		RTC_WaitForSynchro();</span></span><br><span class="line"><span class="comment">		RTC_WaitForLastTask();</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RTC设置时间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">time_t</span> time_cnt;		<span class="comment">//定义秒计数器数据类型</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span>	<span class="comment">//定义日期时间数据类型</span></span><br><span class="line">	</span><br><span class="line">	time_date.tm_year = MyRTC_Time[<span class="number">0</span>] - <span class="number">1900</span>;		<span class="comment">//将数组的时间赋值给日期时间结构体</span></span><br><span class="line">	time_date.tm_mon = MyRTC_Time[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">	time_date.tm_mday = MyRTC_Time[<span class="number">2</span>];</span><br><span class="line">	time_date.tm_hour = MyRTC_Time[<span class="number">3</span>];</span><br><span class="line">	time_date.tm_min = MyRTC_Time[<span class="number">4</span>];</span><br><span class="line">	time_date.tm_sec = MyRTC_Time[<span class="number">5</span>];</span><br><span class="line">	</span><br><span class="line">	time_cnt = mktime(&amp;time_date) - <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;	<span class="comment">//调用mktime函数，将日期时间转换为秒计数器格式</span></span><br><span class="line">													<span class="comment">//- 8 * 60 * 60为东八区的时区调整</span></span><br><span class="line">	</span><br><span class="line">	RTC_SetCounter(time_cnt);						<span class="comment">//将秒计数器写入到RTC的CNT中</span></span><br><span class="line">	RTC_WaitForLastTask();							<span class="comment">//等待上一次操作完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RTC读取时间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">time_t</span> time_cnt;		<span class="comment">//定义秒计数器数据类型</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span>	<span class="comment">//定义日期时间数据类型</span></span><br><span class="line">	</span><br><span class="line">	time_cnt = RTC_GetCounter() + <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;		<span class="comment">//读取RTC的CNT，获取当前的秒计数器</span></span><br><span class="line">													<span class="comment">//+ 8 * 60 * 60为东八区的时区调整</span></span><br><span class="line">	</span><br><span class="line">	time_date = *localtime(&amp;time_cnt);				<span class="comment">//使用localtime函数，将秒计数器转换为日期时间格式</span></span><br><span class="line">	</span><br><span class="line">	MyRTC_Time[<span class="number">0</span>] = time_date.tm_year + <span class="number">1900</span>;		<span class="comment">//将日期时间结构体赋值给数组的时间</span></span><br><span class="line">	MyRTC_Time[<span class="number">1</span>] = time_date.tm_mon + <span class="number">1</span>;</span><br><span class="line">	MyRTC_Time[<span class="number">2</span>] = time_date.tm_mday;</span><br><span class="line">	MyRTC_Time[<span class="number">3</span>] = time_date.tm_hour;</span><br><span class="line">	MyRTC_Time[<span class="number">4</span>] = time_date.tm_min;</span><br><span class="line">	MyRTC_Time[<span class="number">5</span>] = time_date.tm_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		MyRTC_ReadTime();							<span class="comment">//RTC读取时间，最新的时间存储到MyRTC_Time数组中</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">0</span>], <span class="number">4</span>);		<span class="comment">//显示MyRTC_Time数组中的时间值，年</span></span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">11</span>, MyRTC_Time[<span class="number">1</span>], <span class="number">2</span>);		<span class="comment">//月</span></span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">14</span>, MyRTC_Time[<span class="number">2</span>], <span class="number">2</span>);		<span class="comment">//日</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">3</span>], <span class="number">2</span>);		<span class="comment">//时</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">9</span>, MyRTC_Time[<span class="number">4</span>], <span class="number">2</span>);		<span class="comment">//分</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">12</span>, MyRTC_Time[<span class="number">5</span>], <span class="number">2</span>);		<span class="comment">//秒</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);	<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">		OLED_ShowNum(<span class="number">4</span>, <span class="number">6</span>, RTC_GetDivider(), <span class="number">10</span>);	<span class="comment">//显示余数寄存器</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第十三章：PWR电源控制"><a href="#第十三章：PWR电源控制" class="headerlink" title="第十三章：PWR电源控制"></a>第十三章：PWR电源控制</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h2><ul>
<li>PWR（Power Control）电源控制</li>
<li>PWR负责管理STM32内部的电源供电部分，可以实现可编程电压监测器和低功耗模式的功能</li>
<li>可编程电压监测器（PVD）可以监控VDD电源电压，当VDD下降到PVD阀值以下或上升到PVD阀值之上时，PVD会触发中断，用于执行紧急关闭任务</li>
<li>低功耗模式包括睡眠模式（Sleep）、停机模式（Stop）和待机模式（Standby），可在系统空闲时，降低STM32的功耗，延长设备使用时间</li>
</ul>
<h2 id="低功耗模式"><a href="#低功耗模式" class="headerlink" title="低功耗模式"></a>低功耗模式</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509170757130.png" alt="image-20240509170757130" style="zoom:80%;" />

<blockquote>
<p>HSI，HSE  ：低速时钟，RTC 和 看门狗</p>
</blockquote>
<p>从上至下 越睡越深</p>
<p>睡眠模式，关闭CPU时钟，程序暂停运行</p>
<blockquote>
<p>WFI 等待中断</p>
<p>WFE 等待事件，从睡的地方，继续运行</p>
</blockquote>
<p>停机模式，关闭CPU时钟，外设也关闭，但存储器和寄存器数据保持</p>
<p>待机模式，能关的全关掉</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509171948093.png" alt="image-20240509171948093"></p>
<h3 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h3><ul>
<li>执行完WFI&#x2F;WFE指令后，STM32进入睡眠模式，程序暂停运行，唤醒后程序从暂停的地方继续运行</li>
<li>SLEEPONEXIT位决定STM32执行完WFI或WFE后，是立刻进入睡眠，还是等STM32从最低优先级的中断处理程序中退出时进入睡眠</li>
<li>在睡眠模式下，所有的I&#x2F;O引脚都保持它们在运行模式时的状态</li>
<li>WFI指令进入睡眠模式，可被任意一个NVIC响应的中断唤醒</li>
<li>WFE指令进入睡眠模式，可被唤醒事件唤醒</li>
</ul>
<h3 id="停机模式"><a href="#停机模式" class="headerlink" title="停机模式"></a>停机模式</h3><ul>
<li>执行完WFI&#x2F;WFE指令后，STM32进入停止模式，程序暂停运行，唤醒后程序从暂停的地方继续运行</li>
<li>1.8V供电区域的所有时钟都被停止，PLL、HSI和HSE被禁止，SRAM和寄存器内容被保留下来</li>
<li>在停止模式下，所有的I&#x2F;O引脚都保持它们在运行模式时的状态</li>
<li>当一个中断或唤醒事件导致退出停止模式时，HSI被选为系统时钟</li>
<li>当电压调节器处于低功耗模式下，系统从停止模式退出时，会有一段额外的启动延时</li>
<li>WFI指令进入停止模式，可被任意一个EXTI中断唤醒</li>
<li>WFE指令进入停止模式，可被任意一个EXTI事件唤醒</li>
</ul>
<h3 id="待机模式"><a href="#待机模式" class="headerlink" title="待机模式"></a>待机模式</h3><ul>
<li>执行完WFI&#x2F;WFE指令后，STM32进入待机模式，唤醒后程序从头开始运行</li>
<li>整个1.8V供电区域被断电，PLL、HSI和HSE也被断电，SRAM和寄存器内容丢失，只有备份的寄存器和待机电路维持供电</li>
<li>在待机模式下，所有的I&#x2F;O引脚变为高阻态（浮空输入）</li>
<li>WKUP引脚的上升沿、RTC闹钟事件的上升沿、NRST引脚上外部复位、IWDG复位退出待机模式</li>
</ul>
<h2 id="修改主频"><a href="#修改主频" class="headerlink" title="修改主频"></a>修改主频</h2><p>带 锁 的为只读文件, 右键 属性 去除“只读”的 √</p>
<p>start:system_stm32f10x.c —&gt;配置RCC 时钟树</p>
<p>SystemCoreClock  主频</p>
<p>（115行）主频从72M 调成 36M</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509180157367.png" alt="image-20240509180157367"></p>
<h2 id="睡眠模式-串口收发"><a href="#睡眠模式-串口收发" class="headerlink" title="睡眠模式+串口收发"></a>睡眠模式+串口收发</h2><p>串口接线</p>
<p>加个 __WFI(); 即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509180726199.png" alt="image-20240509180726199"></p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509182353362.png" alt="image-20240509182353362" style="zoom:80%;" />

<h2 id="停止模式-对射式红外传感器计次"><a href="#停止模式-对射式红外传感器计次" class="headerlink" title="停止模式+对射式红外传感器计次"></a>停止模式+对射式红外传感器计次</h2><p>外部中断接线</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509183334141.png" alt="image-20240509183334141"></p>
<h2 id="待机模式-实时时钟"><a href="#待机模式-实时时钟" class="headerlink" title="待机模式+实时时钟"></a>待机模式+实时时钟</h2><p>PA0唤醒待机模式</p>
<p>待机模式唤醒后，程序从头执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240509174135947.png" alt="image-20240509174135947"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	MyRTC_Init();		<span class="comment">//RTC初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟</span></span><br><span class="line">															<span class="comment">//停止模式和待机模式一定要记得开启</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;ALR :&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;ALRF:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*使能WKUP引脚 ，不需要GPIO初始化*/</span></span><br><span class="line">	PWR_WakeUpPinCmd(ENABLE);						<span class="comment">//使能位于PA0的WKUP引脚，WKUP引脚上升沿唤醒待机模式</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*设定闹钟*/</span></span><br><span class="line">	<span class="type">uint32_t</span> Alarm = RTC_GetCounter() + <span class="number">10</span>;			<span class="comment">//闹钟为唤醒后当前时间的后10s</span></span><br><span class="line">	RTC_SetAlarm(Alarm);							<span class="comment">//写入闹钟值到RTC的ALR寄存器</span></span><br><span class="line">	OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, Alarm, <span class="number">10</span>);					<span class="comment">//显示闹钟值</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);	<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">		OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetFlagStatus(RTC_FLAG_ALR), <span class="number">1</span>);		<span class="comment">//显示闹钟标志位</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);			<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;STANDBY&quot;</span>);			<span class="comment">//OLED闪烁STANDBY，指示即将进入待机模式</span></span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		OLED_Clear();								<span class="comment">//OLED清屏，模拟关闭外部所有的耗电设备，以达到极度省电</span></span><br><span class="line">		</span><br><span class="line">		PWR_EnterSTANDBYMode();						<span class="comment">//STM32进入停止模式，并等待指定的唤醒事件（WKUP上升沿或RTC闹钟）</span></span><br><span class="line">		<span class="comment">/*待机模式唤醒后，程序会重头开始运行*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="第十四章：看门狗"><a href="#第十四章：看门狗" class="headerlink" title="第十四章：看门狗"></a>第十四章：看门狗</h1><ul>
<li>WDG（Watchdog）看门狗<ul>
<li>看门狗可以监控程序的运行状态，当程序因为设计漏洞、硬件故障、电磁干扰等原因，出现卡死或跑飞现象时，看门狗能及时复位程序，避免程序陷入长时间的罢工状态，保证系统的可靠性和安全性</li>
<li>即 出现程序卡死 &#x2F; 跑飞时 复位</li>
<li>看门狗本质上是一个定时器，当指定时间范围内，程序没有执行喂狗（重置计数器）操作时，看门狗硬件电路就自动产生复位信号</li>
</ul>
</li>
<li>STM32内置两个看门狗<ul>
<li>独立看门狗（IWDG）：独立工作，对时间精度要求较低（要求在时间间隔内喂狗）<ul>
<li>时钟 为专用的LSI ，内部低速时钟，可以预防主时钟出现问题时的情况</li>
</ul>
</li>
<li>窗口看门狗（WWDG）：要求看门狗在精确计时窗口起作用(在窗口时间要求内喂狗，复位时间早了&#x2F;晚了 都会复位)</li>
</ul>
</li>
</ul>
<h2 id="IWDG"><a href="#IWDG" class="headerlink" title="IWDG"></a>IWDG</h2><p>需 要手动重装</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517172247035.png" alt="image-20240517172247035"></p>
<h3 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h3><p>即: 定时器 溢出时间</p>
<p>超时时间：TIWDG &#x3D; TLSI × PR预分频系数 × (RL + 1)<br>其中：TLSI &#x3D; 1 &#x2F; FLSI</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517173409952.png" alt="image-20240517173409952"></p>
<h3 id="IWDG键寄存器"><a href="#IWDG键寄存器" class="headerlink" title="IWDG键寄存器"></a>IWDG键寄存器</h3><ul>
<li>键寄存器本质上是控制寄存器，用于控制硬件电路的工作</li>
<li>在可能<strong>存在干扰</strong>的情况下，一般通过在<strong>整个</strong>键寄存器写入<strong>特定值</strong>来代替控制寄存器写入一位的功能，以降低硬件电路受到干扰的概率</li>
</ul>
<table>
<thead>
<tr>
<th><strong>写入键寄存器的值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0xCCCC</td>
<td>启用独立看门狗</td>
</tr>
<tr>
<td>0xAAAA</td>
<td>IWDG_RLR中的值重新加载到计数器（喂狗）</td>
</tr>
<tr>
<td>0x5555</td>
<td>解除IWDG_PR和IWDG_RLR的写保护</td>
</tr>
<tr>
<td>0x5555之外的其他值</td>
<td>启用IWDG_PR和IWDG_RLR的写保护</td>
</tr>
</tbody></table>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517175123674.png" alt="image-20240517175123674"></p>
<p>初始化流程：</p>
<ul>
<li>LSI开启时钟（无需 软件配置）</li>
<li>解除 IWDG_PR和IWDG_RLR的写保护</li>
<li>写入 预分频值 和重装值</li>
<li>启动独立看门狗</li>
<li>主循环 喂狗</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;IWDG TEST&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*判断复位信号来源*/</span></span><br><span class="line">	<span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET)	<span class="comment">//如果是独立看门狗复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;IWDGRST&quot;</span>);			<span class="comment">//OLED闪烁IWDGRST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		RCC_ClearFlag();							<span class="comment">//清除标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>											<span class="comment">//否则，即为其他复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);				<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*IWDG初始化*/</span></span><br><span class="line">	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);	<span class="comment">//独立看门狗写使能</span></span><br><span class="line">	IWDG_SetPrescaler(IWDG_Prescaler_16);			<span class="comment">//设置预分频为16</span></span><br><span class="line">	IWDG_SetReload(<span class="number">2499</span>);							<span class="comment">//设置重装值为2499，独立看门狗的超时时间为1000ms</span></span><br><span class="line">	IWDG_ReloadCounter();							<span class="comment">//重装计数器，喂狗</span></span><br><span class="line">	IWDG_Enable();									<span class="comment">//独立看门狗使能</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Key_GetNum();								<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line">		</span><br><span class="line">		IWDG_ReloadCounter();						<span class="comment">//重装计数器，喂狗</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);				<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">		Delay_ms(<span class="number">200</span>);								<span class="comment">//喂狗间隔为200+600=800ms</span></span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">600</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="WWDG"><a href="#WWDG" class="headerlink" title="WWDG"></a>WWDG</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517173653353.png" alt="image-20240517173653353"></p>
<p>WWDG_CR：6位 递减计数器 ，T6为溢出 标志位，T6 &#x3D; 0 ，复位</p>
<p>WDGA:看门狗使能位</p>
<p>WWDG_CFR ：配置 窗口</p>
<h3 id="工作特性"><a href="#工作特性" class="headerlink" title="工作特性"></a>工作特性</h3><ul>
<li>递减计数器T[6:0]的值小于0x40时，WWDG产生复位</li>
<li>递减计数器T[6:0]在窗口W[6:0]外被重新装载时，WWDG产生复位</li>
<li>递减计数器T[6:0]等于0x40时可以产生早期唤醒中断（EWI），用于重装载计数器以避免WWDG复位</li>
<li>定期写入WWDG_CR寄存器（喂狗）以避免WWDG复位</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517174210728.png" alt="image-20240517174210728"></p>
<h3 id="超时时间-1"><a href="#超时时间-1" class="headerlink" title="超时时间"></a>超时时间</h3><p>​	TWWDG &#x3D; TPCLK1 × 4096 × WDGTB预分频系数 × (T[5:0] + 1)<br>窗口时间：<br>​	TWIN &#x3D; TPCLK1 × 4096 × WDGTB预分频系数 × (T[5:0] - W[5:0])<br>其中：TPCLK1 &#x3D; 1 &#x2F; FPCLK1</p>
<blockquote>
<p>T[5;0]   —&gt;  T5 到 T0</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240517174429606.png" alt="image-20240517174429606"></p>
<h3 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h3><p>初始化流程：</p>
<ul>
<li>开启APB1时钟（软件配置）</li>
<li>写入 预分频值， 窗口值</li>
<li>启动窗口看门狗 同时 写入 控制寄存器CR </li>
<li>主循环 喂狗</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;WWDG TEST&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*判断复位信号来源*/</span></span><br><span class="line">	<span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET)	<span class="comment">//如果是窗口看门狗复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;WWDGRST&quot;</span>);			<span class="comment">//OLED闪烁WWDGRST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		RCC_ClearFlag();							<span class="comment">//清除标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>											<span class="comment">//否则，即为其他复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);				<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);	<span class="comment">//开启WWDG的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*WWDG初始化*/</span></span><br><span class="line">	WWDG_SetPrescaler(WWDG_Prescaler_8);			<span class="comment">//设置预分频为8</span></span><br><span class="line">	WWDG_SetWindowValue(<span class="number">0x40</span> | <span class="number">21</span>);					<span class="comment">//设置窗口值，窗口时间为30ms</span></span><br><span class="line">	WWDG_Enable(<span class="number">0x40</span> | <span class="number">54</span>);							<span class="comment">//使能并第一次喂狗，超时时间为50ms</span></span><br><span class="line">	<span class="comment">/*0x40 = 100 0000   高位 为溢出标志位*/</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Key_GetNum();								<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);				<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">		Delay_ms(<span class="number">20</span>);								<span class="comment">//喂狗间隔为20+20=40ms</span></span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">		WWDG_SetCounter(<span class="number">0x40</span> | <span class="number">54</span>);					<span class="comment">//重装计数器，喂狗</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="IWWG-和-WWDG-的比较"><a href="#IWWG-和-WWDG-的比较" class="headerlink" title="IWWG 和 WWDG 的比较"></a>IWWG 和 WWDG 的比较</h2><table>
<thead>
<tr>
<th>** **</th>
<th><strong>IWDG****独立看门狗</strong></th>
<th><strong>WWDG****窗口看门狗</strong></th>
</tr>
</thead>
<tbody><tr>
<td>复位</td>
<td>计数器减到0后</td>
<td>计数器T[5:0]减到0后、过早重装计数器</td>
</tr>
<tr>
<td>中断</td>
<td>无</td>
<td>早期唤醒中断</td>
</tr>
<tr>
<td>时钟源</td>
<td>LSI（40KHz）</td>
<td>PCLK1（36MHz）</td>
</tr>
<tr>
<td>预分频系数</td>
<td>4、8、32、64、128、256</td>
<td>1、2、4、8</td>
</tr>
<tr>
<td>计数器</td>
<td>12位</td>
<td>6位（有效计数）</td>
</tr>
<tr>
<td>超时时间</td>
<td>0.1ms~26214.4ms</td>
<td>113us~58.25ms</td>
</tr>
<tr>
<td>喂狗方式</td>
<td>写入键寄存器，重装固定值RLR</td>
<td>直接写入计数器，写多少重装多少</td>
</tr>
<tr>
<td>防误操作</td>
<td>键寄存器和写保护</td>
<td>无</td>
</tr>
<tr>
<td>用途</td>
<td>独立工作，对时间精度要求较低</td>
<td>要求看门狗在精确计时窗口起作用</td>
</tr>
</tbody></table>
<p>大部分时间，使用 独立看门狗 </p>
<h1 id="第十五章：Flash程序存储器闪存"><a href="#第十五章：Flash程序存储器闪存" class="headerlink" title="第十五章：Flash程序存储器闪存"></a>第十五章：Flash程序存储器闪存</h1><ul>
<li>Flash，非易失性存储器（掉电不丢失）</li>
<li>STM32F1系列的FLASH包含<strong>程序存储器</strong>、<strong>系统存储器</strong>和<strong>选项字节</strong>三个部分</li>
<li>通过闪存存储器接口（FPEC）可以对程序存储器和选项字节进行擦除和编程</li>
<li>读写FLASH的用途：<ul>
<li>利用程序存储器的剩余空间来保存掉电不丢失的用户数据</li>
<li>通过在程序中编程（<strong>IAP</strong>），实现程序的自我更新（？）</li>
</ul>
</li>
<li>在线编程（In-Circuit Programming – ICP）用于更新程序存储器的全部内容，它通过JTAG、SWD协议下载程序(仿真器，STLink下载程序)或系统加载程序（Bootloader）下载程序（串口下载程序，ICP下载方式）</li>
<li>在程序中编程（In-Application Programming – IAP）可以使用微控制器支持的任一种通信接口下载程序</li>
<li>Flash 的先 擦除 后写入</li>
</ul>
<blockquote>
<p>IAP  ：在程序存储器  中 找到 程序更新时不会覆盖的地方（Bootloader，接收 通信协议 传过来的数据） ，在更新时跳转到Bootloader里，实现 在程序中编程</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522113214966.png" alt="image-20240522113214966" style="zoom:80%;" />

<h2 id="基本结构-2"><a href="#基本结构-2" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522113434869.png" alt="image-20240522113434869"></p>
<h2 id="擦除和编程的基本步骤"><a href="#擦除和编程的基本步骤" class="headerlink" title="擦除和编程的基本步骤"></a>擦除和编程的基本步骤</h2><h3 id="FPEC的解锁和加锁"><a href="#FPEC的解锁和加锁" class="headerlink" title="FPEC的解锁和加锁"></a>FPEC的解锁和加锁</h3><p>FPEC共有三个键值：</p>
<ul>
<li>​	RDPRT键 &#x3D; 0x000000A5</li>
<li>​	KEY1 &#x3D; 0x45670123</li>
<li>​	KEY2 &#x3D; 0xCDEF89AB</li>
</ul>
<p>解锁：<br>    复位后，FPEC被保护，不能写入FLASH_CR<br>    在FLASH_KEYR先写入KEY1，再写入KEY2，解锁<br>    错误的操作序列会在下次复位前锁死FPEC和FLASH_CR<br>加锁：<br>    设置FLASH_CR中的LOCK位锁住FPEC和FLASH_CR</p>
<h3 id="使用指针访问存储器"><a href="#使用指针访问存储器" class="headerlink" title="使用指针访问存储器"></a>使用指针访问存储器</h3><p>STM32内部的存储器，直接挂在总线上，可直接通过指针访问</p>
<ul>
<li><p>使用指针读指定地址下的存储器：</p>
<ul>
<li>uint16_t Data &#x3D; *((__IO uint16_t *)(0x08000000));</li>
</ul>
</li>
<li><p>使用指针写指定地址下的存储器：</p>
<ul>
<li>​	*((__IO uint16_t *)(0x08000000)) &#x3D; 0x1234;</li>
</ul>
</li>
</ul>
<p>其中：<br>    #define    __IO    volatile</p>
<blockquote>
<p>volatile ：防止编译器优化</p>
</blockquote>
<h3 id="程序存储器编程"><a href="#程序存储器编程" class="headerlink" title="程序存储器编程"></a>程序存储器编程</h3><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522114748963.png" alt="image-20240522114748963" style="zoom:67%;" />

<h3 id="程序存储器页擦除"><a href="#程序存储器页擦除" class="headerlink" title="程序存储器页擦除"></a>程序存储器页擦除</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522114802443.png" alt="image-20240522114802443"></p>
<h3 id="程序存储器全擦除"><a href="#程序存储器全擦除" class="headerlink" title="程序存储器全擦除"></a>程序存储器全擦除</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522114812361.png" alt="image-20240522114812361"></p>
<h3 id="选项字节"><a href="#选项字节" class="headerlink" title="选项字节"></a>选项字节</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522115214696.png" alt="image-20240522115214696"></p>
<ul>
<li>RDP：写入RDPRT键（0x000000A5）后解除读保护</li>
<li>USER：配置硬件看门狗和进入停机&#x2F;待机模式是否产生复位</li>
<li>Data0&#x2F;1：用户可自定义使用</li>
<li>WRP0&#x2F;1&#x2F;2&#x2F;3：配置写保护，每一个位对应保护4个存储页（中容量）</li>
</ul>
<h4 id="选项字节编程"><a href="#选项字节编程" class="headerlink" title="选项字节编程"></a>选项字节编程</h4><ul>
<li>检查FLASH_SR的BSY位，以确认没有其他正在进行的编程操作</li>
<li>解锁FLASH_CR的OPTWRE位</li>
<li>设置FLASH_CR的OPTPG位为1</li>
<li>写入要编程的半字到指定的地址</li>
<li>等待BSY位变为0</li>
<li>读出写入的地址并验证数据</li>
</ul>
<h4 id="选项字节擦除"><a href="#选项字节擦除" class="headerlink" title="选项字节擦除"></a>选项字节擦除</h4><ul>
<li>检查FLASH_SR的BSY位，以确认没有其他正在进行的闪存操作</li>
<li>解锁FLASH_CR的OPTWRE位</li>
<li>设置FLASH_CR的OPTER位为1</li>
<li>设置FLASH_CR的STRT位为1</li>
<li>等待BSY位变为0</li>
<li>读出被擦除的选择字节并做验证</li>
</ul>
<h3 id="器件电子签名"><a href="#器件电子签名" class="headerlink" title="器件电子签名"></a>器件电子签名</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522115607783.png" alt="image-20240522115607783"></p>
<h2 id="读写内部FLASH程序"><a href="#读写内部FLASH程序" class="headerlink" title="读写内部FLASH程序"></a>读写内部FLASH程序</h2><p>读写，擦除，编程</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240522120543506.png" alt="image-20240522120543506"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">myflash.c</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：FLASH读取一个32位的字</span></span><br><span class="line"><span class="comment">  * 参    数：Address 要读取数据的字地址</span></span><br><span class="line"><span class="comment">  * 返 回 值：指定地址下的数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">MyFLASH_ReadWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *((__IO <span class="type">uint32_t</span> *)(Address));	<span class="comment">//使用指针访问指定地址下的数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FLASH读取一个16位的半字</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">MyFLASH_ReadHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *((__IO <span class="type">uint16_t</span> *)(Address));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FLASH读取一个8位的字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyFLASH_ReadByte</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *((__IO <span class="type">uint8_t</span> *)(Address));	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FLASH全擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLASH_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	FLASH_Unlock();					<span class="comment">//解锁</span></span><br><span class="line">	FLASH_EraseAllPages();			<span class="comment">//全擦除</span></span><br><span class="line">	FLASH_Lock();					<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FLASH页擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLASH_ErasePage</span><span class="params">(<span class="type">uint32_t</span> PageAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">	FLASH_Unlock();					<span class="comment">//解锁</span></span><br><span class="line">	FLASH_ErasePage(PageAddress);	<span class="comment">//页擦除</span></span><br><span class="line">	FLASH_Lock();					<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：FLASH编程字</span></span><br><span class="line"><span class="comment">  * 参    数：Address 要写入数据的字地址</span></span><br><span class="line"><span class="comment">  * 参    数：Data 要写入的32位数据</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLASH_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	FLASH_Unlock();							<span class="comment">//解锁</span></span><br><span class="line">	FLASH_ProgramWord(Address, Data);		<span class="comment">//编程字</span></span><br><span class="line">	FLASH_Lock();							<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：FLASH编程半字</span></span><br><span class="line"><span class="comment">  * 参    数：Address 要写入数据的半字地址</span></span><br><span class="line"><span class="comment">  * 参    数：Data 要写入的16位数据</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLASH_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	FLASH_Unlock();							<span class="comment">//解锁</span></span><br><span class="line">	FLASH_ProgramHalfWord(Address, Data);	<span class="comment">//编程半字</span></span><br><span class="line">	FLASH_Lock();							<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>用SRAM缓存数组来管理Flsah的最后一页，实现数据的任意读取和保存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">store.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFLASH.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_START_ADDRESS		0x0800FC00		<span class="comment">//存储的起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_COUNT				512				<span class="comment">//存储数据的个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Store_Data[STORE_COUNT];				<span class="comment">//定义SRAM数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*判断是不是第一次使用*/</span></span><br><span class="line">	<span class="keyword">if</span> (MyFLASH_ReadHalfWord(STORE_START_ADDRESS) != <span class="number">0xA5A5</span>)	</span><br><span class="line">        <span class="comment">//读取第一个半字的标志位，if成立，则执行第一次使用的初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyFLASH_ErasePage(STORE_START_ADDRESS);					<span class="comment">//擦除指定页</span></span><br><span class="line">		MyFLASH_ProgramHalfWord(STORE_START_ADDRESS, <span class="number">0xA5A5</span>);	</span><br><span class="line">        <span class="comment">//在第一个半字写入自己规定的标志位，用于判断是不是第一次使用</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)				<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">		&#123;</span><br><span class="line">			MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, <span class="number">0x0000</span>);		<span class="comment">//除了标志位的有效数据全部清0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*上电时，将闪存数据加载回SRAM数组，实现SRAM数组的掉电不丢失*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)					<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Store_Data[i] = MyFLASH_ReadHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>);		<span class="comment">//将闪存的数据加载回SRAM数组</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：(参数存储模块)  SRAM数组 保存数据到闪存</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Save</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyFLASH_ErasePage(STORE_START_ADDRESS);				<span class="comment">//擦除指定页</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)			<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, Store_Data[i]);	<span class="comment">//将SRAM数组的数据备份保存到闪存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块将所有有效数据清0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)			<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Store_Data[i] = <span class="number">0x0000</span>;							<span class="comment">//SRAM数组有效数据清0</span></span><br><span class="line">	&#125;</span><br><span class="line">	Store_Save();										<span class="comment">//保存数据到闪存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="STM32-ST-Link-Utility"><a href="#STM32-ST-Link-Utility" class="headerlink" title="STM32 ST-Link Utility"></a>STM32 ST-Link Utility</h2><p>9-6</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/yuena.blog/images/IMG_4653.PNG">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
      </div>
  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/yuena.blog/2023/12/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%A7%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0/" rel="prev" title="软件安全大作业笔记">
                  <i class="fa fa-angle-left"></i> 软件安全大作业笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/yuena.blog/2024/04/05/%E7%99%BE%E7%9F%A5/" rel="next" title="百知">
                  百知 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">chouzhen</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">219k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:19</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/yuena.blog/js/comments.js"></script><script src="/yuena.blog/js/utils.js"></script><script src="/yuena.blog/js/motion.js"></script><script src="/yuena.blog/js/next-boot.js"></script>

  




  <script src="/yuena.blog/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






<!--页面点击小桃心-->

  <script type="text/javascript" src="/js/love.js"></script>





<script src="/yuena.blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/yuena.blog/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
