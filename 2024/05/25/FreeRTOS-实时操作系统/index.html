<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/yuena.blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/yuena.blog/images/yuena.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/yuena.blog/images/yuena.ico">
  <link rel="mask-icon" href="/yuena.blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/yuena.blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-flat-top.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dmyuena.github.io","root":"/yuena.blog/","images":"/yuena.blog/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/yuena.blog/js/config.js"></script>

    <meta name="description" content="v9.0.0  https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1UTg6FM4AEkFR7iPMeHiqPA?pwd&#x3D;7kwp  C8T6总的堆栈大小改为10*1024  正在学习编程风格">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS_实时操作系统">
<meta property="og:url" content="https://dmyuena.github.io/yuena.blog/2024/05/25/FreeRTOS-%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="YueNa&#39;s Blog">
<meta property="og:description" content="v9.0.0  https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1UTg6FM4AEkFR7iPMeHiqPA?pwd&#x3D;7kwp  C8T6总的堆栈大小改为10*1024  正在学习编程风格">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529114216236.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529115052086.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529115134110.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529115904049.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529120606897.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529121117709.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626121153367.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626121850223.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626151007183.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626151150147.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626152043157.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626154406941.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626152908619.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626154623026.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626155046461.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626162821717.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626163027278.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626210747444.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627000619896.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627111218022.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627112641710.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627113804848.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627114523332.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627153014435.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627172634936.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627172650644.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627172711148.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627172730019.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627183300024.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627191937299.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628162009349.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628163648117.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628164007948.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628164504270.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628165027686.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628165551469.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628165941361.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628165955381.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204047048.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204121336.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204144867.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204212134.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204230037.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628211632904.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628213325503.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628213506376.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628213551938.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628215005019.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628215301699.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629155709426.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629160521332.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629182330948.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629191423740.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629191648789.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629192337074.png">
<meta property="article:published_time" content="2024-05-25T14:11:11.000Z">
<meta property="article:modified_time" content="2024-06-30T14:18:36.021Z">
<meta property="article:author" content="chouzhen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529114216236.png">


<link rel="canonical" href="https://dmyuena.github.io/yuena.blog/2024/05/25/FreeRTOS-%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dmyuena.github.io/yuena.blog/2024/05/25/FreeRTOS-%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","path":"2024/05/25/FreeRTOS-实时操作系统/","title":"FreeRTOS_实时操作系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>FreeRTOS_实时操作系统 | YueNa's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/yuena.blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/yuena.blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">YueNa's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">秋窗犹曙色,落木更天风</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/yuena.blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/yuena.blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%A3%E5%9C%A8%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">正在学习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="nav-number">2.</span> <span class="nav-text">编程风格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D"><span class="nav-number">2.2.</span> <span class="nav-text">变量名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%90%8D"><span class="nav-number">2.3.</span> <span class="nav-text">函数名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">2.4.</span> <span class="nav-text">宏</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A7%BB%E6%A4%8D%E6%96%87%E4%BB%B6%E5%A4%B9-%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">移植文件夹 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RTOS%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">3.1.</span> <span class="nav-text">RTOS文件夹</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Source-%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">3.1.1.</span> <span class="nav-text">Source 文件夹</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#portblle-%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">portblle  文件夹</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RVDS-%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">3.1.1.1.1.</span> <span class="nav-text">RVDS 文件夹</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MemMang-%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">3.1.1.1.2.</span> <span class="nav-text">MemMang 文件夹</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A7%BB%E6%A4%8D"><span class="nav-number">4.</span> <span class="nav-text">移植</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOSConfig-h%E6%96%87%E4%BB%B6"><span class="nav-number">4.1.</span> <span class="nav-text">FreeRTOSConfig.h文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SysTick%E6%96%87%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">SysTick文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">main函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA"><span class="nav-number">5.</span> <span class="nav-text">任务创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1"><span class="nav-number">5.1.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">实现过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%A0%88"><span class="nav-number">5.2.1.</span> <span class="nav-text">任务栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.2.</span> <span class="nav-text">定义任务函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">5.2.3.</span> <span class="nav-text">定义任务控制块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%92%8C%E5%88%97%E8%A1%A8%E9%A1%B9"><span class="nav-number">5.2.4.</span> <span class="nav-text">列表和列表项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E9%A1%B9"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">列表项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%B7%E4%BD%A0%E5%88%97%E8%A1%A8%E9%A1%B9"><span class="nav-number">5.2.4.3.</span> <span class="nav-text">迷你列表项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.2.5.</span> <span class="nav-text">列表初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E9%A1%B9%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.2.6.</span> <span class="nav-text">列表项初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E9%A1%B9%E6%8F%92%E5%85%A5"><span class="nav-number">5.2.7.</span> <span class="nav-text">列表项插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E9%A1%B9%E6%9C%AB%E5%B0%BE%E6%8F%92%E5%85%A5"><span class="nav-number">5.2.8.</span> <span class="nav-text">列表项末尾插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">5.2.9.</span> <span class="nav-text">列表项的删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">5.2.10.</span> <span class="nav-text">列表的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">实现任务创建函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xTaskCreateStatic-%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.1.</span> <span class="nav-text">xTaskCreateStatic()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#prvInitialiseNewTask-%E5%87%BD%E6%95%B0-%E5%88%9B%E5%BB%BA%E6%96%B0%E4%BB%BB%E5%8A%A1"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">prvInitialiseNewTask()函数 创建新任务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pxPortInitialiseStack%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%BB%E5%8A%A1%E6%A0%88"><span class="nav-number">5.3.1.1.1.</span> <span class="nav-text">pxPortInitialiseStack（）函数 初始化任务栈</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%B0%B1%E7%BB%AA%E5%88%97%E8%A1%A8"><span class="nav-number">5.4.</span> <span class="nav-text">实现就绪列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%B1%E7%BB%AA%E5%88%97%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.4.1.</span> <span class="nav-text">就绪列表的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E4%BB%BB%E5%8A%A1%E6%8F%92%E5%85%A5%E5%88%B0%E5%B0%B1%E7%BB%AA%E5%88%97%E8%A1%A8"><span class="nav-number">5.4.2.</span> <span class="nav-text">将任务插入到就绪列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">5.5.</span> <span class="nav-text">实现调度器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8-vTaskStartScheduler-%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.1.</span> <span class="nav-text">调度器的启动 vTaskStartScheduler()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xPortStartScheduler"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">xPortStartScheduler()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#prvStartFirstTask"><span class="nav-number">5.5.1.1.1.</span> <span class="nav-text">prvStartFirstTask()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vPortSVCHandler-%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.1.2.</span> <span class="nav-text">vPortSVCHandler()函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="nav-number">5.6.</span> <span class="nav-text">任务切换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E2%80%94%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">任务创建—静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0-1"><span class="nav-number">6.1.</span> <span class="nav-text">定义任务函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1%E5%A0%86%E6%A0%88%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">空闲任务与定时器任务堆栈函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1%E6%A0%88%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">6.3.</span> <span class="nav-text">定义任务栈和任务控制块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="nav-number">6.4.</span> <span class="nav-text">静态创建任务函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1"><span class="nav-number">6.5.</span> <span class="nav-text">启动任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main-c"><span class="nav-number">6.6.</span> <span class="nav-text">main.c</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E2%80%94%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">任务创建—动态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">7.1.</span> <span class="nav-text">动态内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">动态创建任务函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="nav-number">7.3.</span> <span class="nav-text">主函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeRTOS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">FreeRTOS启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">8.1.</span> <span class="nav-text">任务的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">8.2.</span> <span class="nav-text">任务的调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0-1"><span class="nav-number">8.3.</span> <span class="nav-text">主函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">任务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%80%E4%BB%8B"><span class="nav-number">9.1.</span> <span class="nav-text">任务简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">9.2.</span> <span class="nav-text">任务调度器简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E7%AE%80%E4%BB%8B"><span class="nav-number">9.3.</span> <span class="nav-text">任务状态简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E4%BB%BB%E5%8A%A1API%E5%87%BD%E6%95%B0"><span class="nav-number">9.4.</span> <span class="nav-text">常用任务API函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="nav-number">9.4.1.</span> <span class="nav-text">任务挂起函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vTaskSuspend"><span class="nav-number">9.4.1.1.</span> <span class="nav-text">vTaskSuspend()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vTaskSuspendAll"><span class="nav-number">9.4.1.2.</span> <span class="nav-text">vTaskSuspendAll()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%81%A2%E5%A4%8D%E5%87%BD%E6%95%B0"><span class="nav-number">9.4.2.</span> <span class="nav-text">任务恢复函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vTaskResume"><span class="nav-number">9.4.2.1.</span> <span class="nav-text">vTaskResume()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xTaskResumeFromISR"><span class="nav-number">9.4.2.2.</span> <span class="nav-text">xTaskResumeFromISR()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xTaskResumeAll"><span class="nav-number">9.4.2.3.</span> <span class="nav-text">xTaskResumeAll()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="nav-number">9.4.3.</span> <span class="nav-text">任务删除函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vTaskDelete"><span class="nav-number">9.4.3.1.</span> <span class="nav-text">vTaskDelete()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="nav-number">9.4.4.</span> <span class="nav-text">任务延时函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vTaskDelay"><span class="nav-number">9.4.4.1.</span> <span class="nav-text">vTaskDelay()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vTaskDelayUntil"><span class="nav-number">9.4.4.2.</span> <span class="nav-text">vTaskDelayUntil()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9"><span class="nav-number">9.5.</span> <span class="nav-text">任务的设计要点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A0%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">9.5.1.</span> <span class="nav-text">①中断服务函数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A1%E4%BB%BB%E5%8A%A1%EF%BC%9A"><span class="nav-number">9.5.2.</span> <span class="nav-text">②任务：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A2%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%EF%BC%9A"><span class="nav-number">9.5.3.</span> <span class="nav-text">③空闲任务：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A3%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%EF%BC%9A"><span class="nav-number">9.5.4.</span> <span class="nav-text">④任务的执行时间：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">9.6.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%93-%E4%BB%BB%E5%8A%A1%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">10.</span> <span class="nav-text">消息队列–&gt;任务间的数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">10.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">10.1.1.</span> <span class="nav-text">消息队列数据存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%98%BB%E5%A1%9E%E6%9C%BA%E5%88%B6"><span class="nav-number">10.1.2.</span> <span class="nav-text">消息队列阻塞机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E9%98%9F%E9%98%BB%E5%A1%9E"><span class="nav-number">10.1.2.1.</span> <span class="nav-text">出队阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A5%E9%98%9F%E9%98%BB%E5%A1%9E"><span class="nav-number">10.1.2.2.</span> <span class="nav-text">入队阻塞</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%E5%9B%BE%E7%A4%BA"><span class="nav-number">10.1.3.</span> <span class="nav-text">消息队列操作图示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">10.1.4.</span> <span class="nav-text">消息队列控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8API%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.</span> <span class="nav-text">常用API函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.1.</span> <span class="nav-text">消息队列创建函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.2.</span> <span class="nav-text">消息队列静态创建函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.3.</span> <span class="nav-text">消息队列删除函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.4.</span> <span class="nav-text">向消息队列发送消息函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueSend-%E4%B8%8E-xQueueSendToBack"><span class="nav-number">10.2.4.1.</span> <span class="nav-text">xQueueSend()与 xQueueSendToBack()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueSendFromISR-%E4%B8%8E-xQueueSendToBackFromISR"><span class="nav-number">10.2.4.2.</span> <span class="nav-text">xQueueSendFromISR()与 xQueueSendToBackFromISR()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueSendToFront"><span class="nav-number">10.2.4.3.</span> <span class="nav-text">xQueueSendToFront()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueSendToFrontFromISR"><span class="nav-number">10.2.4.4.</span> <span class="nav-text">xQueueSendToFrontFromISR()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#xQueueGenericSend"><span class="nav-number">10.2.4.4.1.</span> <span class="nav-text">xQueueGenericSend()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#xQueueGenericSendFromISR"><span class="nav-number">10.2.4.4.2.</span> <span class="nav-text">xQueueGenericSendFromISR()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%96%E6%B6%88%E6%B6%88%E6%81%AF%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.5.</span> <span class="nav-text">从消息队列取消消息函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueReceive-%E4%B8%8E-xQueuePeek"><span class="nav-number">10.2.5.1.</span> <span class="nav-text">xQueueReceive()与 xQueuePeek()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueReceiveFromISR-%E4%B8%8E-xQueuePeekFromISR"><span class="nav-number">10.2.5.2.</span> <span class="nav-text">xQueueReceiveFromISR()与 xQueuePeekFromISR()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">10.3.</span> <span class="nav-text">使用注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.4.</span> <span class="nav-text">软件实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">11.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%AE%80%E4%BB%8B"><span class="nav-number">11.1.</span> <span class="nav-text">信号量简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">11.1.1.</span> <span class="nav-text">二值信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">11.1.2.</span> <span class="nav-text">计数信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">11.1.3.</span> <span class="nav-text">互斥信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">11.1.4.</span> <span class="nav-text">递归信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">11.1.5.</span> <span class="nav-text">二值信号量应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">11.1.6.</span> <span class="nav-text">二值信号量运作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">11.1.7.</span> <span class="nav-text">计数信号量运作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">11.1.8.</span> <span class="nav-text">信号量控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8FAPI%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.</span> <span class="nav-text">常用信号量API函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.1.</span> <span class="nav-text">创建信号量函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F-xSemaphoreCreateBinary"><span class="nav-number">11.2.1.1.</span> <span class="nav-text">创建二值信号量  xSemaphoreCreateBinary()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F-xSemaphoreCreateCounting"><span class="nav-number">11.2.1.2.</span> <span class="nav-text">创建计数信号量  xSemaphoreCreateCounting()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.2.</span> <span class="nav-text">信号量删除函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.3.</span> <span class="nav-text">信号量释放函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreGive"><span class="nav-number">11.2.3.1.</span> <span class="nav-text">xSemaphoreGive()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreGiveFromISR"><span class="nav-number">11.2.3.2.</span> <span class="nav-text">xSemaphoreGiveFromISR()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.4.</span> <span class="nav-text">信号量获取函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreTake"><span class="nav-number">11.2.4.1.</span> <span class="nav-text">xSemaphoreTake()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreTakeFromISR"><span class="nav-number">11.2.4.2.</span> <span class="nav-text">xSemaphoreTakeFromISR()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">11.3.</span> <span class="nav-text">软件实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F-1"><span class="nav-number">11.3.1.</span> <span class="nav-text">二值信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F-1"><span class="nav-number">11.3.2.</span> <span class="nav-text">计数信号量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">12.</span> <span class="nav-text">互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E7%AE%80%E4%BB%8B"><span class="nav-number">12.1.</span> <span class="nav-text">互斥量简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6"><span class="nav-number">12.1.1.</span> <span class="nav-text">优先级继承机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">12.1.2.</span> <span class="nav-text">互斥量应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">12.1.3.</span> <span class="nav-text">互斥量运作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">12.1.4.</span> <span class="nav-text">互斥量控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8FAPI"><span class="nav-number">12.2.</span> <span class="nav-text">常用互斥量API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.1.</span> <span class="nav-text">互斥量创建函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreCreateMutex"><span class="nav-number">12.2.1.1.</span> <span class="nav-text">xSemaphoreCreateMutex()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%87%8F%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.2.</span> <span class="nav-text">递归互斥量创建函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreCreateRecursiveMutex"><span class="nav-number">12.2.2.1.</span> <span class="nav-text">xSemaphoreCreateRecursiveMutex()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.3.</span> <span class="nav-text">互斥量删除函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vSemaphoreDelete"><span class="nav-number">12.2.3.1.</span> <span class="nav-text">vSemaphoreDelete()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.4.</span> <span class="nav-text">互斥量获取函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreTake-1"><span class="nav-number">12.2.4.1.</span> <span class="nav-text">xSemaphoreTake()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%87%8F%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.5.</span> <span class="nav-text">递归互斥量获取函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreTakeRecursive"><span class="nav-number">12.2.5.1.</span> <span class="nav-text">xSemaphoreTakeRecursive()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.6.</span> <span class="nav-text">互斥量释放函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreGive-1"><span class="nav-number">12.2.6.1.</span> <span class="nav-text">xSemaphoreGive()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%87%8F%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.7.</span> <span class="nav-text">递归互斥量释放函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xSemaphoreGiveRecursive"><span class="nav-number">12.2.7.1.</span> <span class="nav-text">xSemaphoreGiveRecursive()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">12.3.</span> <span class="nav-text">软件实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC"><span class="nav-number">12.3.1.</span> <span class="nav-text">模拟优先级翻转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F-1"><span class="nav-number">12.3.2.</span> <span class="nav-text">互斥量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">13.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">13.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOS-%E6%8F%90%E4%BE%9B%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%85%B7%E6%9C%89%E5%A6%82%E4%B8%8B%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">13.1.1.</span> <span class="nav-text">FreeRTOS 提供的事件具有如下特点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">13.1.2.</span> <span class="nav-text">事件应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">13.1.3.</span> <span class="nav-text">事件运作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">13.1.4.</span> <span class="nav-text">事件控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6API%E5%87%BD%E6%95%B0"><span class="nav-number">13.2.</span> <span class="nav-text">常用事件API函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-number">13.2.1.</span> <span class="nav-text">事件创建函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xEventGroupCreate"><span class="nav-number">13.2.1.1.</span> <span class="nav-text">xEventGroupCreate()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="nav-number">13.2.2.</span> <span class="nav-text">事件删除函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vEventGroupDelete"><span class="nav-number">13.2.2.1.</span> <span class="nav-text">vEventGroupDelete()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%84%E7%BD%AE%E4%BD%8D%E5%87%BD%E6%95%B01"><span class="nav-number">13.2.3.</span> <span class="nav-text">事件组置位函数1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xEventGroupSetBits"><span class="nav-number">13.2.3.1.</span> <span class="nav-text">xEventGroupSetBits()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%84%E7%BD%AE%E4%BD%8D%E5%87%BD%E6%95%B02"><span class="nav-number">13.2.4.</span> <span class="nav-text">事件组置位函数2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xEventGroupSetBitsFromISR"><span class="nav-number">13.2.4.1.</span> <span class="nav-text">xEventGroupSetBitsFromISR()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0"><span class="nav-number">13.2.5.</span> <span class="nav-text">等待事件函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xEventGroupWaitBits"><span class="nav-number">13.2.5.1.</span> <span class="nav-text">xEventGroupWaitBits()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E4%BA%8B%E4%BB%B6%E7%BB%84%E6%8C%87%E5%AE%9A%E7%9A%84%E4%BD%8D"><span class="nav-number">13.2.6.</span> <span class="nav-text">清除事件组指定的位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xEventGroupClearBits"><span class="nav-number">13.2.6.1.</span> <span class="nav-text">xEventGroupClearBits()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xEventGroupClearBitsFromISR"><span class="nav-number">13.2.6.2.</span> <span class="nav-text">xEventGroupClearBitsFromISR()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">13.3.</span> <span class="nav-text">软件实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">14.</span> <span class="nav-text">软件定时器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5"><span class="nav-number">15.</span> <span class="nav-text">任务通知</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">16.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="nav-number">17.</span> <span class="nav-text">中断管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU%E5%88%A9%E7%94%A8%E7%8E%87%E7%BB%9F%E8%AE%A1"><span class="nav-number">18.</span> <span class="nav-text">CPU利用率统计</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chouzhen"
      src="/yuena.blog/images/yuena.gif">
  <p class="site-author-name" itemprop="name">chouzhen</p>
  <div class="site-description" itemprop="description">YueNa的博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/yuena.blog/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dmyuena" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dmyuena" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2237076291@qq.com" title="E-Mail → mailto:2237076291@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title">
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="ttps://xbww38261.xyz/" title="ttps:&#x2F;&#x2F;xbww38261.xyz&#x2F;" rel="noopener" target="_blank">梯子</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://jycblog.gitee.io/#indexCard" title="https:&#x2F;&#x2F;jycblog.gitee.io&#x2F;#indexCard" rel="noopener" target="_blank">一言</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://dhndzwxj.vercel.app/" title="https:&#x2F;&#x2F;dhndzwxj.vercel.app&#x2F;" rel="noopener" target="_blank">揭晓</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://namic00.github.io/" title="https:&#x2F;&#x2F;namic00.github.io&#x2F;" rel="noopener" target="_blank">C/C</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dmyuena.github.io/yuena.blog/2024/05/25/FreeRTOS-%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yuena.blog/images/yuena.gif">
      <meta itemprop="name" content="chouzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YueNa's Blog">
      <meta itemprop="description" content="YueNa的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="FreeRTOS_实时操作系统 | YueNa's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          FreeRTOS_实时操作系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-25 22:11:11" itemprop="dateCreated datePublished" datetime="2024-05-25T22:11:11+08:00">2024-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-30 22:18:36" itemprop="dateModified" datetime="2024-06-30T22:18:36+08:00">2024-06-30</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>67k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:01</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>v9.0.0</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1UTg6FM4AEkFR7iPMeHiqPA?pwd=7kwp">https://pan.baidu.com/s/1UTg6FM4AEkFR7iPMeHiqPA?pwd=7kwp</a> </p>
<p>C8T6总的堆栈大小改为10*1024</p>
</blockquote>
<h1 id="正在学习"><a href="#正在学习" class="headerlink" title="正在学习"></a>正在学习</h1><h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529114216236.png" alt="image-20240529114216236"></p>
<h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>在 FreeRTOS 中， 定义变量的时候往往会把变量的类型当作前缀加在变量上，这样的好处是让用户一看到这个变量就知道该变量的类型。</p>
<ul>
<li>char 型变量的前缀是 c</li>
<li>short 型变量的前缀是 s</li>
<li>long 型变量的前缀是 l</li>
<li>portBASE_TYPE 类型变量的前缀是 x。 还有其他的数据类型， 比如数据结构， 任务句柄， 队列句柄等定义的变量名的前缀也是 x。  </li>
<li>无符号型的变量 前缀是 u</li>
<li>指针变量前缀 p</li>
</ul>
<h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>函数名包含了函数返回值的类型、 函数所在的文件名和函数的功能</p>
<p>私有的函数则会加一个 prv（private） 的前缀。 </p>
<p>特别的， 在函数名中加入了函数所在的文件名， 这极大的帮助了用户提高寻找函数定义的效率和了解函数作用的目的</p>
<p>①vTaskPrioritySet()函数的返回值为 void 型， 在 task.c 这个文件中定义。<br>②xQueueReceive()函数的返回值为 portBASE_TYPE 型， 在 queue.c 这个文件中定义。<br>③vSemaphoreCreateBinary()函数的返回值为 void 型， 在 semphr.h 这个文件中定义。  </p>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529115052086.png" alt="image-20240529115052086"></p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529115134110.png" alt="image-20240529115134110" style="zoom:150%;" />

<h1 id="移植文件夹-结构"><a href="#移植文件夹-结构" class="headerlink" title="移植文件夹 结构"></a>移植文件夹 结构</h1><h2 id="RTOS文件夹"><a href="#RTOS文件夹" class="headerlink" title="RTOS文件夹"></a>RTOS文件夹</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529115904049.png" alt="image-20240529115904049" style="zoom:80%;" />

<ul>
<li>Demo 文件夹： 里面包含了 FreeRTOS 官方为各个单片机移植好的工程代码，FreeRTOS 为了推广自己， 会给各种半导体厂商的评估板写好完整的工程程序，这些程序就放在 Demo 这个目录下， 这部分 Demo 非常有参考价值。 我们把FreeRTOS 到 STM32 的时候， <strong>FreeRTOSConfig.h</strong> 这个头文件就是从这里拷贝过来的。</li>
</ul>
<blockquote>
<p>主要是  CORTEX_STM32F103_Keil 下的 FreeRTOSConfig.h 文件</p>
</blockquote>
<ul>
<li>License 文件夹： 这个文件夹里面就是相关的许可信息， 要用 FreeRTOS 做产品的得仔细看看， 尤其是要出口的产品。  （不重要）</li>
<li>Source 文件夹： 里面包含的是 FreeRTOS 内核的源代码， 我们移植 FreeRTOS的时候就需要这部分源代码。</li>
</ul>
<h3 id="Source-文件夹"><a href="#Source-文件夹" class="headerlink" title="Source 文件夹"></a>Source 文件夹</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529120606897.png" alt="image-20240529120606897"></p>
<ul>
<li>编号①和③包含的是 FreeRTOS 的通用的头文件和 C 文件， 这两部分的文件适用于各种编译器和处理器， 是通用的。  </li>
<li>编号②  portblle 文件夹  包含的是与编译器相关的文件夹， 在不同的编译器中使用不同的支持文件</li>
</ul>
<h4 id="portblle-文件夹"><a href="#portblle-文件夹" class="headerlink" title="portblle  文件夹"></a>portblle  文件夹</h4><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240529121117709.png" alt="image-20240529121117709"></p>
<ul>
<li>编号①中的 KEIL 就是我们就是我们使用的编译器</li>
</ul>
<blockquote>
<p> 打开 KEIL 文件夹的时候， 你会看到一句话“See-also-the-RVDS-directory.txt” ， 不重要（对于 使用KEIL编译器时来说 ）</p>
</blockquote>
<ul>
<li><p>编号②MemMang 文件夹下存放的是跟内存管理相关的</p>
</li>
<li><p>编号③RVDS 文件夹里面存放的是处理器相关的文件夹</p>
</li>
</ul>
<h5 id="RVDS-文件夹"><a href="#RVDS-文件夹" class="headerlink" title="RVDS 文件夹"></a>RVDS 文件夹</h5><p>打开 RVDS 文件夹， 下面包含了各种处理器相关的文件夹， 有我们学习的 STM32 有 M0、 M3、 M4 等各种系列， FreeRTOS 是一个软件， 单片机是一个硬件， FreeRTOS 要想运行在一个单片机上面， 它们就必须关联在一起， 那么怎么关联？ 还是得通过写代码来关联， 这部分关联的文件叫接口文件， 通常由汇编和 C 联合编写。 这些接口文件都是跟硬件密切相关的，不同的硬件接口文件是不一样的， 但都大同小异。 编写这些接口文件的过程我们就叫移植， 移植的过程通常由 FreeRTOS 和 mcu 原厂的人来负责， 移植好的这些接口文件就放在 RVDS 这个文件夹的目录下  。</p>
<h5 id="MemMang-文件夹"><a href="#MemMang-文件夹" class="headerlink" title="MemMang 文件夹"></a>MemMang 文件夹</h5><p>MemMang 文件夹下存放的是跟内存管理相关的， 总共有五个 heap 文件以及一个 readme 说明文件， 这五个 heap 文件在移植的时候<strong>必须使用一个</strong>，因为 FreeRTOS 在创建内核对象的时候使用的是动态分配内存， 而这些动态内存分配的函数则在这几个文件里面实现， 不同的分配算法会导致不同的效率与结果。</p>
<h1 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h1><p>P9</p>
<ul>
<li>把 FreeRTOSConfig.h 加到 include 文件夹中</li>
<li>_core 文件夹 添加 原source 中的所有.c文件</li>
<li>_port 文件夹 添加 portable&#x2F;MemMang&#x2F;heap4.c  和 RVDV&#x2F;ARM.CM3&#x2F;port.c</li>
<li>添加 头文件路径 include文件夹 和 RVDV&#x2F;ARM.CM3&#x2F;</li>
</ul>
<blockquote>
<p>重定义</p>
<p>​	PendSV_Handler<br>​	SVC_Handler</p>
<p>需要注释</p>
<p>P10  编写STM32的配置文件中的systick_handler（ovid）——&gt;RTOS的系统时钟</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">修改 stm32 的 配置文件:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">xPortSysTickHandler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED)<span class="comment">//系统已经运行</span></span><br><span class="line">    &#123;</span><br><span class="line">        xPortSysTickHandler();	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FreeRTOSConfig-h文件"><a href="#FreeRTOSConfig-h文件" class="headerlink" title="FreeRTOSConfig.h文件"></a>FreeRTOSConfig.h文件</h2><h2 id="SysTick文件"><a href="#SysTick文件" class="headerlink" title="SysTick文件"></a>SysTick文件</h2><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><h1 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>在裸机系统中，系统的主体就是 main 函数里面顺序执行的无限循环，这个 无限循环里面 CPU 按照顺序完成各种事情。在多任务系统中，我们根据功能的 不同，把整个系统分割成一个个独立的且无法返回的函数，这个函数我们称为任 务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_entry</span> <span class="params">(<span class="type">void</span> *parg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 任务主体，无限循环且不能返回 */</span></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 任务主体代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="任务栈"><a href="#任务栈" class="headerlink" title="任务栈"></a>任务栈</h3><p>栈是单 片机 RAM 里面一段连续的内存空间，栈的大小一般在启动文件或者链接脚本里 面指定，最后由 C 库函数 main 进行初始化</p>
<p>但是，在<strong>多任务系统</strong>中，每个任务都是独立的，互不干扰的，所以要为每个 任务都<strong>分配独立的栈空间</strong>，这个栈空间通常是一个预先定义好的全局数组，也可 以是动态分配的一段内存空间，但它们都存在于 RAM 中。</p>
<p>在多任务系统中，有多 少个任务就需要定义多少个任务栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK1_STACK_SIZE 128</span></span><br><span class="line">StackType_t Task1Stack[TASK1_STACK_SIZE];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>任务栈其实就是一个预先定义好的全局数组，数据类型为 StackType_t，大小由 TASK1_STACK_SIZE 这个宏来定义，默认为 128，单位为 字，即 512 字节，这也是 FreeRTOS 推荐的最小的任务栈</p>
</blockquote>
<h3 id="定义任务函数"><a href="#定义任务函数" class="headerlink" title="定义任务函数"></a>定义任务函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	LED1=<span class="number">0</span>;</span><br><span class="line">	vTaskDelay(<span class="number">200</span>);</span><br><span class="line">	LED1=<span class="number">1</span>;</span><br><span class="line">	vTaskDelay(<span class="number">800</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义任务控制块"><a href="#定义任务控制块" class="headerlink" title="定义任务控制块"></a>定义任务控制块</h3><p>在多任务系统中， 任务的执行是由系统调度的。</p>
<p>系统为了顺利的调度任务，为每个任务都额外定义 了一个<strong>任务控制块</strong>，这个任务控制块就相当于任务的身份证，里面存有任务的所 有信息，比如任务的栈指针，任务名称，任务的形参等。</p>
<p>有了这个任务控制块之 后，以后系统对任务的全部操作都可以通过这个任务控制块来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个任务控制块的数据类型 task.c 中声明*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">volatile</span> StackType_t *pxTopOfStack; <span class="comment">/* 栈顶 */</span> (<span class="number">1</span>)</span><br><span class="line">ListItem_t xStateListItem; <span class="comment">/* 任务节点 */</span> (<span class="number">2</span>)</span><br><span class="line">StackType_t *pxStack; <span class="comment">/* 任务栈起始地址 */</span> (<span class="number">3</span>)</span><br><span class="line"><span class="comment">/* 任务名称，字符串形式 */</span>(<span class="number">4</span>)</span><br><span class="line"><span class="type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ];</span><br><span class="line">&#125; tskTCB;</span><br></pre></td></tr></table></figure>

<p><strong>代码(1)：****栈顶指针</strong>，作为 TCB 的第一个成员。</p>
<p> <strong>代码(2)：</strong>任务节点，这是一个内置在 TCB 控制块中的链表节点，通过这个 节点，可以将任务控制块挂接到各种链表中。这个节点就类似晾衣架的钩子，TCB 就是衣服。</p>
<p> <strong>代码(3)：</strong>任务栈起始地址。</p>
<p> <strong>代码(4)：</strong>任务名称，字符串形式，长度由宏 configMAX_TASK_NAME_LEN 来 控制，该宏在 FreeRTOSConfig.h 中定义，默认为 16。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="comment">/*为任务定义 任务控制块*/</span></span><br><span class="line">StaticTask_t Task1TaskTCB;</span><br></pre></td></tr></table></figure>

<h3 id="列表和列表项"><a href="#列表和列表项" class="headerlink" title="列表和列表项"></a>列表和列表项</h3><p>列表和列表项是 FreeRTOS 的一个数据结构， FreeRTOS 大量使用到了列表和列表项，它是 FreeRTOS 的基石</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表被用来 跟踪 FreeRTOS 中的任务。</p>
<p>与列表相关的全部东西都在文件 list.c 和 list.h 中。在 list.h 中定义了一个叫 List_t 的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*list.h*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">listFIRST_LIST_INTEGRITY_CHECK_VALUE (<span class="number">1</span>)</span><br><span class="line">configLIST_VOLATILE UBaseType_t uxNumberOfItems; (<span class="number">2</span>)</span><br><span class="line">ListItem_t * configLIST_VOLATILE pxIndex; (<span class="number">3</span>)</span><br><span class="line">MiniListItem_t xListEnd; (<span class="number">4</span>)</span><br><span class="line">listSECOND_LIST_INTEGRITY_CHECK_VALUE (<span class="number">5</span>)</span><br><span class="line">&#125; List_t;</span><br></pre></td></tr></table></figure>

<p>代码(1)和(5)：这两个都是用来检查列表完整性的，需要将宏 configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 设置为 1，开启以后会向这两个 地方分别添加一个变量 xListIntegrityValue1 和 xListIntegrityValue2，在 初始化列表的时候会这两个变量中写入一个特殊的值，默认不开启这个功能。 </p>
<p>代码(2)：uxNumberOfItems 用来记录列表中<strong>列表项的数量</strong>。 </p>
<p>代码(3)：pxIndex 用来记录<strong>当前列表项索引号</strong>，用于遍历列表。 </p>
<p>代码(4)：<strong>列表中最后一个列表项，用来表示列表结束</strong>，此变量类型为 MiniListItem_t，这是一个迷你列表项</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626121153367.png" alt="image-20240626121153367"></p>
<h4 id="列表项"><a href="#列表项" class="headerlink" title="列表项"></a>列表项</h4><p>列表项就是存放在列表中的项目，FreeRTOS 提供了两种列表项：<strong>列表项</strong>和 <strong>迷你列表项</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*list.h 中定义，列表项*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE (<span class="number">1</span>)</span><br><span class="line">configLIST_VOLATILE TickType_t xItemValue; (<span class="number">2</span>)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span> (<span class="number">3</span>)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span> (<span class="number">4</span>)</span><br><span class="line"><span class="type">void</span> * pvOwner; (<span class="number">5</span>)</span><br><span class="line"><span class="type">void</span> * configLIST_VOLATILE pvContainer; (<span class="number">6</span>)</span><br><span class="line">listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE (<span class="number">7</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> <span class="title">ListItem_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>代码(1)和(7)：用法和列表一样，用来检查列表项完整性的。</p>
<p>代码(2)：xItemValue 为<strong>列表项值</strong>。</p>
<p> 代码(3)：pxNext <strong>指向下一个列表项</strong>。</p>
<p> 代码(4)：pxPrevious <strong>指向前一个列表项</strong>，和 pxNext 配合起来实现类似双 向链表的功能。 </p>
<p>代码(5)：pvOwner 记录此链表项归谁拥有，通常是<strong>任务控制块</strong>。 </p>
<p>代码(6)：pvContainer 用来记录此列表项归哪个列表。</p>
<p>注意pvContainer和 pvOwner 的 区别，在前面讲解任务控制块 TCB_t 的时候说了在 TCB_t 中有两个变量 xStateListItem 和 xEventListItem，这两个变量的类型就是 ListItem_t，也 就是说这两个成员变量都是列表项。以 xStateListItem 为例，当创建一个任务 以后 xStateListItem 的 pvOwner 变量就指向这个任务的任务控制块，表示 xSateListItem 属于此任务。当任务就绪态以后 xStateListItem 的变量 pvContainer 就指向就绪列表，表明此列表项在就绪列表中。</p>
<blockquote>
<p>举个通俗一点的例 子：小王在上二年级，他的父亲是老王。如果把小王比作列表项，那么小王的 pvOwner 属性值就是老王，小王的 pvContainer 属性值就是二年级</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626121850223.png" alt="image-20240626121850223"></p>
<h4 id="迷你列表项"><a href="#迷你列表项" class="headerlink" title="迷你列表项"></a>迷你列表项</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE (<span class="number">1</span>)</span><br><span class="line">configLIST_VOLATILE TickType_t xItemValue; (<span class="number">2</span>)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span> (<span class="number">3</span>)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span> (<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span> <span class="title">MiniListItem_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>代码(1)： 用于检查迷你列表项的完整性。<br>代码(2)： xItemValue 记录列表项值。<br>代码(3)： pxNext 指向下一个列表项。<br>代码(4)： pxPrevious 指向上一个列表项。  </p>
<blockquote>
<p>有些情况下我们不需要列表项这么全的功能， 可能只需要其中的某几个成员变量， 如果此时用列表项的话会造成内存浪费！ </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626151007183.png" alt="image-20240626151007183"></p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>新创建或者定义的列表需要对其做初始化处理， 列表的初始化其实就是初始化列表结构体 List_t 中的各个成员变量  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInitialise</span><span class="params">( List_t * <span class="type">const</span> pxList )</span></span><br><span class="line">&#123;</span><br><span class="line">pxList-&gt;pxIndex = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); (<span class="number">1</span>)</span><br><span class="line">pxList-&gt;xListEnd.xItemValue = portMAX_DELAY; (<span class="number">2</span>)</span><br><span class="line">pxList-&gt;xListEnd.pxNext = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); (<span class="number">3</span>)</span><br><span class="line">pxList-&gt;xListEnd.pxPrevious = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );(<span class="number">4</span>)</span><br><span class="line">pxList-&gt;uxNumberOfItems = ( UBaseType_t ) <span class="number">0U</span>; (<span class="number">5</span>)</span><br><span class="line">listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList ); (<span class="number">6</span>)</span><br><span class="line">listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList ); (<span class="number">7</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码(1)： xListEnd 用来表示列表的末尾， 而 pxIndex 表示列表项的索引号， 此时列表只有一个列表项， 那就是 xListEnd， 所以 pxIndex 指向 xListEnd。<br>代码(2)： xListEnd 的列表项值初始化为 portMAX_DELAY， portMAX_DELAY是个宏， 在文件 portmacro.h 中有定义。 根据所使用的 MCU 的不同，portMAX_DELAY 值也不相同， 可以为 0xffff 或者 0xffffffffUL， 本教程中为0xffffffffUL。<br>代码(3)： 初始化列表项 xListEnd 的 pxNext 变量， 因为此时列表只有一  个列表项 xListEnd， 因此 pxNext 只能指向自身。<br>代码(4)： 同(3)一样， 初始化 xListEnd 的 pxPrevious 变量， 指向xListEnd 自身。<br>代码(5)： 由于此时没有其他的列表项， 因此 uxNumberOfItems 为 0， 注意，这里没有算 xListEnd。<br>代码(6)和(7)： 初始化列表项中用于完整性检查字段， 只有宏<br>configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 为 1 的时候才有效。 同样的根据所选的 MCU 不同其写入的值也不同， 可以为 0x5a5a 或者 0x5a5a5a5aUL。<br>STM32 是 32 位系统写入的是 0x5a5a5a5aUL， 列表初始化完以后如下图所示：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626151150147.png" alt="image-20240626151150147"></p>
<h3 id="列表项初始化"><a href="#列表项初始化" class="headerlink" title="列表项初始化"></a>列表项初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInitialiseItem</span><span class="params">( ListItem_t * <span class="type">const</span> pxItem )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化 pvContainer 为 NULL</span></span><br><span class="line">pxItem-&gt;pvContainer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//初始化用于完整性检查的变量， 如果开启了这个功能的话。</span></span><br><span class="line">listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );</span><br><span class="line">listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>列表项的初始化很简单， 只是将列表项成员变量 pvContainer 初始化为NULL， 并且给用于完整性检查的变量赋值  </p>
<p>其他的根据实际情况来初始化</p>
<h3 id="列表项插入"><a href="#列表项插入" class="headerlink" title="列表项插入"></a>列表项插入</h3><p>列表项的插入操作通过函数 vListInsert()来完成  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626152043157.png" alt="image-20240626152043157"></p>
<p>要插入的<strong>位置</strong>由<strong>列表项中成员变量</strong> xItemValue 来决定。 列表项的插入根据xItemValue 的值按照升序的方式排列！  </p>
<blockquote>
<p> vListInsert()的实现 手册P61</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626154406941.png" alt="image-20240626154406941"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626152908619.png" alt="image-20240626152908619"></p>
<h3 id="列表项末尾插入"><a href="#列表项末尾插入" class="headerlink" title="列表项末尾插入"></a>列表项末尾插入</h3><p>列表末尾插入列表项的操作通过函数 vListInsertEnd ()来完成，</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626154623026.png" alt="image-20240626154623026"></p>
<blockquote>
<p> vListInsertEnd () 的实现 手册P64</p>
</blockquote>
<h3 id="列表项的删除"><a href="#列表项的删除" class="headerlink" title="列表项的删除"></a>列表项的删除</h3><p>列表项的删除通过函数uxListRemove()来完成 </p>
<p>注意， 列表项的删除只是将指定的列表项从列表中删除掉， 并不会将这个列表项的内存给释放掉！ 如果这个列表项是动态分配内存的话。   </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626155046461.png" alt="image-20240626155046461"></p>
<blockquote>
<p>uxListRemove()的实现 手册P66</p>
</blockquote>
<h3 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h3><p>listGET_OWNER_OF_NEXT_ENTRY()  </p>
<p>每调用一次这个函数，列表的 pxIndex 变量就会指向下一个列表项， 并且返回这个列表项的 pxOwner 变量值。 这个函数本质<br>上是一个宏， 这个宏在文件 list.h 中如下定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )  (1)</span></span><br><span class="line">&#123; </span><br><span class="line">List_t * <span class="type">const</span> pxConstList = ( pxList ); </span><br><span class="line">( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;\(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>( ( <span class="type">void</span> * ) ( pxConstList )-&gt;pxIndex == ( <span class="type">void</span> * )&amp;( ( pxConstList )-&gt;xListEnd ) ) (<span class="number">3</span>)</span><br><span class="line">&#123; </span><br><span class="line">    ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;   (<span class="number">4</span>)</span><br><span class="line">&#125; </span><br><span class="line">( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner; (<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码(1)： pxTCB 用来保存 pxIndex 所指向的列表项的 pvOwner 变量值，也就是这个列表项属于谁的？ 通常是一个任务的任务控制块。 pxList 表示要遍历的列表。<br>代码(2)： 列表的 pxIndex 变量指向下一个列表项。<br>代码(3)： 如果 pxIndex 指向了列表的 xListEnd 成员变量， 表示到了列表末尾。<br>代码(4)： 如果到了列表末尾的话就跳过 xListEnd， pxIndex 再一次重新指向处于列表头的列表项， 这样就完成了一次对列表的遍历。<br>代码(5)： 将 pxIndex 所指向的新列表项的 pvOwner 赋值给 pxTCB。</p>
<p><strong>此函数用于从多个同优先级的就绪任务中查找下一个要运行的任务。</strong>  </p>
<h2 id="实现任务创建函数"><a href="#实现任务创建函数" class="headerlink" title="实现任务创建函数"></a>实现任务创建函数</h2><p>任务的栈， 任务的函数实体， 任务的控制块最终需要联系起来才能由系统进行统一调度。 那么这个联系的工作就由任务创建函数 xTaskCreateStatic()来实现， 该函数在 task.c 中定义， 在 task.h 中声明， 所有跟任务相关的函数都在这个文件定义。</p>
<blockquote>
<p>使用此函数 需要 configSUPPORT_STATIC_ALLOCATION &#x3D; 1  静态分配内存</p>
</blockquote>
<h3 id="xTaskCreateStatic-函数"><a href="#xTaskCreateStatic-函数" class="headerlink" title="xTaskCreateStatic()函数"></a>xTaskCreateStatic()函数</h3><p>重要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">( TaskFunction_t pxTaskCode, (<span class="number">1</span>)</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, (<span class="number">2</span>)</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth, (<span class="number">3</span>)</span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvParameters, (<span class="number">4</span>)</span></span><br><span class="line"><span class="params">UBaseType_t uxPriority, (<span class="number">5</span>)</span></span><br><span class="line"><span class="params">StackType_t * <span class="type">const</span> puxStackBuffer,(<span class="number">6</span>)</span></span><br><span class="line"><span class="params">StaticTask_t * <span class="type">const</span> pxTaskBuffer )</span><span class="params">(<span class="number">7</span>)</span></span><br></pre></td></tr></table></figure>

<p>代码(1)： 任务入口， 即任务的函数名称。 TaskFunction_t 是在 projdefs.h中重定义的一个数据类型， 实际就是空指针。  </p>
<p>代码(2)： 任务名称， 字符串形式， 方便调试。<br>代码(3)： 任务栈大小， 单位为字。<br>代码(4)： 任务形参。<br>代码(5)： 任务优先级。</p>
<blockquote>
<p>0 是 空闲任务</p>
<p>31 是中断任务</p>
<p>1—&gt;31 优先级 从低到高</p>
</blockquote>
<p>代码(6)： 任务栈起始地址。<br>代码(7)： 任务控制块指针 </p>
<h4 id="prvInitialiseNewTask-函数-创建新任务"><a href="#prvInitialiseNewTask-函数-创建新任务" class="headerlink" title="prvInitialiseNewTask()函数 创建新任务"></a>prvInitialiseNewTask()函数 创建新任务</h4><h5 id="pxPortInitialiseStack（）函数-初始化任务栈"><a href="#pxPortInitialiseStack（）函数-初始化任务栈" class="headerlink" title="pxPortInitialiseStack（）函数 初始化任务栈"></a>pxPortInitialiseStack（）函数 初始化任务栈</h5><h2 id="实现就绪列表"><a href="#实现就绪列表" class="headerlink" title="实现就绪列表"></a>实现就绪列表</h2><p>任务创建好之后， 我们需要把任务添加到就绪列表里面， 表示任务已经就绪，系统随时可以调度。 就绪列表在 task.c 中定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List_t pxReadyTasksLists[ configMAX_PRIORITIES ];</span><br></pre></td></tr></table></figure>

<p>就绪列表实际上就是一个 List_t 类型的数组， 数组的大小由决定最大任务优先级的宏 configMAX_PRIORITIES 决定， configMAX_PRIORITIES 在FreeRTOSConfig.h 中默认定义为 32， 最大支持 256 个优先级。 </p>
<p>数组的下标对应了任务的优先级， 同一优先级的任务统一插入到就绪列表的同一条链表中。</p>
<p> 一个空的就绪<strong>列表</strong>如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626162821717.png" alt="image-20240626162821717"></p>
<h3 id="就绪列表的初始化"><a href="#就绪列表的初始化" class="headerlink" title="就绪列表的初始化"></a>就绪列表的初始化</h3><p>prvInitialiseTaskLists()  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626163027278.png" alt="image-20240626163027278"></p>
<h3 id="将任务插入到就绪列表"><a href="#将任务插入到就绪列表" class="headerlink" title="将任务插入到就绪列表"></a>将任务插入到就绪列表</h3><p><strong>任务控制块</strong>里面有一个 <strong>xStateListItem</strong> 成员， 数据类型为 ListItem_t，我们将任务插入到就绪列表里面， 就是通过将任务控制块的 xStateListItem 这个节点插入到就绪列表中来实现的。 如果把就绪列表比作是晾衣架， 任务是衣服，那 xStateListItem 就是晾衣架上面的钩子， 每个任务都自带晾衣架钩子， 就是为了把自己挂在各种不同的链表中  </p>
<p>任务创建好之后， 紧跟着将任务插入到就绪列表。  </p>
<p>vListInsertEnd （）实现</p>
<h2 id="实现调度器"><a href="#实现调度器" class="headerlink" title="实现调度器"></a>实现调度器</h2><p>调度器是操作系统的核心， 其主要功能就是实现任务的切换， 即从就绪列表里面找到优先级最高的任务， 然后去执行该任务。 </p>
<p>从代码上来看， 调度器无非也就是由几个全局变量和一些可以实现任务切换的函数组成， 全部都在 task.c 文件中实现  </p>
<h3 id="调度器的启动-vTaskStartScheduler-函数"><a href="#调度器的启动-vTaskStartScheduler-函数" class="headerlink" title="调度器的启动 vTaskStartScheduler()函数"></a>调度器的启动 vTaskStartScheduler()函数</h3><h4 id="xPortStartScheduler"><a href="#xPortStartScheduler" class="headerlink" title="xPortStartScheduler()"></a>xPortStartScheduler()</h4><p>调用此函数来初始化跟调度器启动有关的硬件， 比如滴答定时器、 FPU 单元和 PendSV 中断等等  </p>
<h5 id="prvStartFirstTask"><a href="#prvStartFirstTask" class="headerlink" title="prvStartFirstTask()"></a>prvStartFirstTask()</h5><p>调用函数 prvStartFirstTask()启动第一个任务， 启动成功后，则不再返回， 该函数由汇编编写， 在 port.c 实现  </p>
<h4 id="vPortSVCHandler-函数"><a href="#vPortSVCHandler-函数" class="headerlink" title="vPortSVCHandler()函数"></a>vPortSVCHandler()函数</h4><p>SVC 中断要想被成功响应， 其函数名必须与向量表注册的名称一致， 在启动文件的向量表中， SVC 的中断服务函数注册的名称是 SVC_Handler， 所以 SVC 中断服务函数的名称我们应该写成 SVC_Handler， 但是在 FreeRTOS 中， 官方版本写的是 vPortSVCHandler()， 为了能够顺利的响应 SVC 中断， 我们有两个选择：<br>1，改中断向量表中 SVC 的注册的函数名称或者改 FreeRTOS 中 SVC 的中断服务,名称。 </p>
<p>2.在 FreeRTOSConfig.h 中添加添加宏定义的方法来修改（使用）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler PendSV_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler SVC_Handler</span></span><br></pre></td></tr></table></figure>

<h2 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h2><p>任务切换就是在就绪列表中寻找优先级最高的就绪任务， 然后去执行该任务。 </p>
<p>任务切换由函数 taskYIELD()实现</p>
<p>xPortPendSVHandler()函数  </p>
<blockquote>
<p>手册P90</p>
</blockquote>
<h1 id="任务创建—静态方法"><a href="#任务创建—静态方法" class="headerlink" title="任务创建—静态方法"></a>任务创建—静态方法</h1><p>两个LED闪烁</p>
<h2 id="定义任务函数-1"><a href="#定义任务函数-1" class="headerlink" title="定义任务函数"></a>定义任务函数</h2><p>任务实际上就是一个无限循环且不带返回值的 C 函数  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务 1 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">LED1=<span class="number">0</span>;</span><br><span class="line">vTaskDelay(<span class="number">200</span>); </span><br><span class="line">LED1=<span class="number">1</span>;</span><br><span class="line">vTaskDelay(<span class="number">800</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; /</span><br><span class="line"><span class="comment">//任务 2 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED2=<span class="number">0</span>;</span><br><span class="line">vTaskDelay(<span class="number">800</span>);</span><br><span class="line">LED2=<span class="number">1</span>;</span><br><span class="line">vTaskDelay(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>任务里面的延时函数必须使用 FreeRTOS 里面提供的延时函数，并不能使用我们裸机编程中的那种延时。 </p>
<p>这两种的延时的区别是 FreeRTOS 里面的延时是阻塞延时， 即<strong>调用 vTaskDelay()函数的时候， 当前任务会被挂起， 调度器会切换到其它就绪的任务， 从而实现多任务</strong>。 如果还是使用裸机编程中的那种延时， 那么整个任务就成为了一个死循环， 如果恰好该任务的优先级是最高的，那么系统永远都是在这个任务中运行， 比它优先级更低的任务无法运行， 根本无法实现多任务。 </p>
<p>但 FreeRTOS 中的延时最小值只能是 ms， 对于 us 级别的延时， 可以使用 <strong>SysTick.c</strong> 文件中的延时函数亦可， 包括 ms 和 us 级延时， 这两个延时函数与裸机实验中是不一样的， 所以不要搞混。  </p>
<blockquote>
<p>使用SysTick 的延时函数时 ，delay_xms（）和 delay_us（） 不会产生任务的调度</p>
</blockquote>
<h2 id="空闲任务与定时器任务堆栈函数"><a href="#空闲任务与定时器任务堆栈函数" class="headerlink" title="空闲任务与定时器任务堆栈函数"></a>空闲任务与定时器任务堆栈函数</h2><p>当我们使用了静态创建任务的时候， configSUPPORT_STATIC_ALLOCATION 这个宏定义必须为 1（在 FreeRTOSConfig.h 文件中） </p>
<p>并且我们需要实现两个函数： <strong>vApplicationGetIdleTaskMemory</strong>()与<strong>vApplicationGetTimerTaskMemory</strong>()， 这两个函数是用户设定的空闲（Idle） 任务与定时器（Timer） 任务的堆栈大小， 必须由用户自己分配， 而不能是动态分配  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 空闲任务任务堆栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t Idle_Task_Stack[configMINIMAL_STACK_SIZE];</span><br><span class="line"><span class="comment">/* 定时器任务堆栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t Timer_Task_Stack[configTIMER_TASK_STACK_DEPTH];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 空闲任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t Idle_Task_TCB;	</span><br><span class="line"><span class="comment">/* 定时器任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t Timer_Task_TCB;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取空闲任务地任务堆栈和任务控制块内存，因为本例程使用的</span></span><br><span class="line"><span class="comment">//静态内存，因此空闲任务的任务堆栈和任务控制块的内存就应该</span></span><br><span class="line"><span class="comment">//有用户来提供，FreeRTOS提供了接口函数vApplicationGetIdleTaskMemory()</span></span><br><span class="line"><span class="comment">//实现此函数即可。</span></span><br><span class="line"><span class="comment">//ppxIdleTaskTCBBuffer:任务控制块内存</span></span><br><span class="line"><span class="comment">//ppxIdleTaskStackBuffer:任务堆栈内存</span></span><br><span class="line"><span class="comment">//pulIdleTaskStackSize:任务堆栈大小</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetIdleTaskMemory</span><span class="params">(StaticTask_t **ppxIdleTaskTCBBuffer, </span></span><br><span class="line"><span class="params">								   StackType_t **ppxIdleTaskStackBuffer, </span></span><br><span class="line"><span class="params">								   <span class="type">uint32_t</span> *pulIdleTaskStackSize)</span></span><br><span class="line">&#123;</span><br><span class="line">	*ppxIdleTaskTCBBuffer=&amp;Idle_Task_TCB;</span><br><span class="line">	*ppxIdleTaskStackBuffer=Idle_Task_Stack;</span><br><span class="line">	*pulIdleTaskStackSize=configMINIMAL_STACK_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取定时器任务的任务堆栈和任务控制块内存</span></span><br><span class="line"><span class="comment">//ppxTimerTaskTCBBuffer	:		任务控制块内存</span></span><br><span class="line"><span class="comment">//ppxTimerTaskStackBuffer:	任务堆栈内存</span></span><br><span class="line"><span class="comment">//pulTimerTaskStackSize	:		任务堆栈大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetTimerTaskMemory</span><span class="params">(StaticTask_t **ppxTimerTaskTCBBuffer, </span></span><br><span class="line"><span class="params">									StackType_t **ppxTimerTaskStackBuffer, </span></span><br><span class="line"><span class="params">									<span class="type">uint32_t</span> *pulTimerTaskStackSize)</span></span><br><span class="line">&#123;</span><br><span class="line">	*ppxTimerTaskTCBBuffer=&amp;Timer_Task_TCB;<span class="comment">/* 任务控制块内存 */</span></span><br><span class="line">	*ppxTimerTaskStackBuffer=Timer_Task_Stack;<span class="comment">/* 任务堆栈内存 */</span></span><br><span class="line">	*pulTimerTaskStackSize=configTIMER_TASK_STACK_DEPTH;<span class="comment">/* 任务堆栈大小 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义任务栈和任务控制块"><a href="#定义任务栈和任务控制块" class="headerlink" title="定义任务栈和任务控制块"></a>定义任务栈和任务控制块</h2><p>目前我们只创建了 2 个任务， 当任务进入延时的时候， 因为没有另外就绪的用户任务， 那么系统就会进入<strong>空闲任务</strong>， 空闲任务是 FreeRTOS 系统自己启动的一个任务， 优先级最低。 </p>
<p>当整个系统都没有就绪任务的时候， 系统必须保证有一个任务在运行， 空闲任务就是为这个设计的。 当用户任务延时到期， 又会从空闲任务切换回用户任务。</p>
<p>在 FreeRTOS 系统中， 每一个任务都是独立的， 他们的运行环境都单独的保存在他们的栈空间当中。 那么在定义好任务函数之后， 我们还要为任务定义一个栈， 目前我们使用的是静态内存， 所以任务栈是一个独立的全局变量， 具体见代码。</p>
<p> 任务的栈占用的是 MCU 内部的 RAM， 当任务越多的时候， 需要使用的栈空间就越大， 即需要使用的 RAM 空间就越多。 一个 MCU 能够支持多少任务， 就得看芯片的 RAM 空间有多少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ASK1任务堆栈大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK1_STK_SIZE 128</span></span><br><span class="line"><span class="comment">//任务堆栈</span></span><br><span class="line">StackType_t Task1TaskStack[TASK1_STK_SIZE];</span><br><span class="line"><span class="comment">// Task2任务堆栈大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK2_STK_SIZE 128</span></span><br><span class="line"><span class="comment">//任务堆栈</span></span><br><span class="line">StackType_t Task2TaskStack[TASK2_STK_SIZE];</span><br></pre></td></tr></table></figure>

<p> 定义好任务函数和任务栈之后， 我们还需要为任务定义一个任务控制块， 通常我们称这个任务控制块为任务的身份证。 在 C 代码上， 任务控制块就是一个结构体， 里面有非常多的成员， 这些成员共同描述了任务的全部信息。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Task1任务控制块</span></span><br><span class="line">StaticTask_t Task1TaskTCB;</span><br><span class="line"><span class="comment">//Task2任务控制块</span></span><br><span class="line">StaticTask_t Task2TaskTCB;</span><br></pre></td></tr></table></figure>

<h2 id="静态创建任务函数"><a href="#静态创建任务函数" class="headerlink" title="静态创建任务函数"></a>静态创建任务函数</h2><p>一个任务的三要素是任务主体函数， 任务栈， 任务控制块，静态任务创建函数xTaskCreateStatic()将任务主体函数， 任务栈（静态的）<br>和任务控制块（静态的） 这三者联系在一起， 让任务可以随时被系统启动，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建开始任务</span></span><br><span class="line">StartTask_Handler=xTaskCreateStatic((TaskFunction_t )start_task, <span class="comment">//任务函数 (1)</span></span><br><span class="line">(<span class="type">const</span> <span class="type">char</span>* )<span class="string">&quot;start_task&quot;</span>,<span class="comment">//任务名称 (2)</span></span><br><span class="line">(<span class="type">uint32_t</span> )START_STK_SIZE,<span class="comment">//任务堆栈大小(3)</span></span><br><span class="line">(<span class="type">void</span>* )<span class="literal">NULL</span>,<span class="comment">//传递给任务函数的参数 (4)</span></span><br><span class="line">(UBaseType_t )START_TASK_PRIO, <span class="comment">//任务优先级 (5)</span></span><br><span class="line">(StackType_t* )StartTaskStack,<span class="comment">//任务堆栈 (6)</span></span><br><span class="line">(StaticTask_t* )&amp;StartTaskTCB);<span class="comment">//任务控制块 (7)</span></span><br></pre></td></tr></table></figure>

<p>代码(1)： 任务入口函数， 即任务函数的名称， 需要我们自己定义并且实现。（start_task ， task1_task ， task2_task）<br>代码(2)： 任务名字， 字符串形式，任务名字最好要与任务函数入口名字一致， 方便进行调试。<br>代码(3)： 任务堆栈大小，<br>代码(4)： 任务入口函数形参， 不用的时候配置为 0 或者 NULL 即可。<br>代码(5)： 任务的优先级。 在 FreeRTOS 中， 数值越大优先级越高， 0 代表最低优先级。<br>代码(6)： 任务栈起始地址， 只有在使用静态内存的时候才需要提供， 在使用动态内存的时候会根据提供的任务栈大小自动创建。<br>代码(7)： 任务控制块指针， 在使用静态内存的时候， 需要给任务初始化函数 xTaskCreateStatic()传递预先定义好的任务控制块的指针。 在使用动态内存的时候， 任务创建函数 xTaskCreate()会返回一个指针指向任务控制块， 该任务控制块是 xTaskCreate()函数里面动态分配的一块内存。  </p>
<h2 id="启动任务"><a href="#启动任务" class="headerlink" title="启动任务"></a>启动任务</h2><p>当任务创建好后， 是处于任务就绪（Ready） ， 在<strong>就绪态</strong>的任务可以参与操作系统的调度。 但是此时任务仅仅是创建了， 还未开启任务调度器， 也没创建空闲任务与定时器任务（如果使能了 configUSE_TIMERS 这个宏定义） ， 那<strong>这两个任务就是在启动任务调度器中实现， 每个操作系统， 任务调度器只启动一次， 之后就不会再次执行了</strong>， FreeRTOS 中启动任务调度器的函数是vTaskStartScheduler()， 并且启动任务调度器的时候就不会返回， 从此任务管理都由 FreeRTOS 管理， 此时才是真正进入实时操作系统中的第一步。</p>
<blockquote>
<p>在main函数的结尾vTaskStartScheduler();          &#x2F;&#x2F;开启任务调度  </p>
</blockquote>
<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240626210747444.png" alt="image-20240626210747444" style="zoom:200%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;system.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SysTick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* START_TASK*/</span></span><br><span class="line"><span class="comment">//任务优先级</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> START_TASK_PRIO		1</span></span><br><span class="line"><span class="comment">//任务堆栈大小	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> START_STK_SIZE 		128  </span></span><br><span class="line"><span class="comment">//任务堆栈</span></span><br><span class="line">StackType_t StartTaskStack[START_STK_SIZE];</span><br><span class="line"><span class="comment">//任务控制块</span></span><br><span class="line">StaticTask_t StartTaskTCB;</span><br><span class="line"><span class="comment">//任务句柄</span></span><br><span class="line">TaskHandle_t StartTask_Handler;</span><br><span class="line"><span class="comment">//任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TASK1_TASK*/</span></span><br><span class="line"><span class="comment">//任务优先级</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK1_TASK_PRIO		2</span></span><br><span class="line"><span class="comment">//任务堆栈大小	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK1_STK_SIZE 		128  </span></span><br><span class="line"><span class="comment">//任务堆栈</span></span><br><span class="line">StackType_t Task1TaskStack[TASK1_STK_SIZE];</span><br><span class="line"><span class="comment">//任务控制块</span></span><br><span class="line">StaticTask_t Task1TaskTCB;</span><br><span class="line"><span class="comment">//任务句柄</span></span><br><span class="line">TaskHandle_t Task1Task_Handler;</span><br><span class="line"><span class="comment">//任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*TASK2_TASK*/</span></span><br><span class="line"><span class="comment">//任务优先级</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK2_TASK_PRIO		3</span></span><br><span class="line"><span class="comment">//任务堆栈大小	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK2_STK_SIZE 		128 </span></span><br><span class="line"><span class="comment">//任务堆栈</span></span><br><span class="line">StackType_t Task2TaskStack[TASK2_STK_SIZE];</span><br><span class="line"><span class="comment">//任务控制块</span></span><br><span class="line">StaticTask_t Task2TaskTCB;</span><br><span class="line"><span class="comment">//任务句柄</span></span><br><span class="line">TaskHandle_t Task2Task_Handler;</span><br><span class="line"><span class="comment">//任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 空闲任务任务堆栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t Idle_Task_Stack[configMINIMAL_STACK_SIZE];</span><br><span class="line"><span class="comment">/* 定时器任务堆栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t Timer_Task_Stack[configTIMER_TASK_STACK_DEPTH];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 空闲任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t Idle_Task_TCB;	</span><br><span class="line"><span class="comment">/* 定时器任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t Timer_Task_TCB;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取空闲任务地任务堆栈和任务控制块内存，因为本例程使用的</span></span><br><span class="line"><span class="comment">//静态内存，因此空闲任务的任务堆栈和任务控制块的内存就应该</span></span><br><span class="line"><span class="comment">//有用户来提供，FreeRTOS提供了接口函数vApplicationGetIdleTaskMemory()</span></span><br><span class="line"><span class="comment">//实现此函数即可。</span></span><br><span class="line"><span class="comment">//ppxIdleTaskTCBBuffer:任务控制块内存</span></span><br><span class="line"><span class="comment">//ppxIdleTaskStackBuffer:任务堆栈内存</span></span><br><span class="line"><span class="comment">//pulIdleTaskStackSize:任务堆栈大小</span></span><br><span class="line"><span class="comment">/*重写此函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetIdleTaskMemory</span><span class="params">(StaticTask_t **ppxIdleTaskTCBBuffer, </span></span><br><span class="line"><span class="params">								   StackType_t **ppxIdleTaskStackBuffer, </span></span><br><span class="line"><span class="params">								   <span class="type">uint32_t</span> *pulIdleTaskStackSize)</span></span><br><span class="line">&#123;</span><br><span class="line">	*ppxIdleTaskTCBBuffer=&amp;Idle_Task_TCB;</span><br><span class="line">	*ppxIdleTaskStackBuffer=Idle_Task_Stack;</span><br><span class="line">	*pulIdleTaskStackSize=configMINIMAL_STACK_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取定时器任务的任务堆栈和任务控制块内存</span></span><br><span class="line"><span class="comment">//ppxTimerTaskTCBBuffer	:		任务控制块内存</span></span><br><span class="line"><span class="comment">//ppxTimerTaskStackBuffer:	任务堆栈内存</span></span><br><span class="line"><span class="comment">//pulTimerTaskStackSize	:		任务堆栈大小</span></span><br><span class="line"><span class="comment">/*重写此函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetTimerTaskMemory</span><span class="params">(StaticTask_t **ppxTimerTaskTCBBuffer, </span></span><br><span class="line"><span class="params">									StackType_t **ppxTimerTaskStackBuffer, </span></span><br><span class="line"><span class="params">									<span class="type">uint32_t</span> *pulTimerTaskStackSize)</span></span><br><span class="line">&#123;</span><br><span class="line">	*ppxTimerTaskTCBBuffer=&amp;Timer_Task_TCB;<span class="comment">/* 任务控制块内存 */</span></span><br><span class="line">	*ppxTimerTaskStackBuffer=Timer_Task_Stack;<span class="comment">/* 任务堆栈内存 */</span></span><br><span class="line">	*pulTimerTaskStackSize=configTIMER_TASK_STACK_DEPTH;<span class="comment">/* 任务堆栈大小 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名         : main</span></span><br><span class="line"><span class="comment">* 函数功能		   : 主函数</span></span><br><span class="line"><span class="comment">* 输    入         : 无</span></span><br><span class="line"><span class="comment">* 输    出         : 无</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick_Init(<span class="number">72</span>);</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);<span class="comment">//设置系统中断优先级分组4</span></span><br><span class="line">	LED_Init();</span><br><span class="line">	USART1_Init(<span class="number">115200</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建开始任务 start_task</span></span><br><span class="line">	StartTask_Handler=xTaskCreateStatic((TaskFunction_t	)start_task,		<span class="comment">//任务函数</span></span><br><span class="line">										(<span class="type">const</span> <span class="type">char</span>* 	)<span class="string">&quot;start_task&quot;</span>,		<span class="comment">//任务名称</span></span><br><span class="line">										(<span class="type">uint32_t</span> 		)START_STK_SIZE,	<span class="comment">//任务堆栈大小</span></span><br><span class="line">										(<span class="type">void</span>* 		  	)<span class="literal">NULL</span>,				<span class="comment">//传递给任务函数的参数</span></span><br><span class="line">										(UBaseType_t 	)START_TASK_PRIO, 	<span class="comment">//任务优先级</span></span><br><span class="line">										(StackType_t*   )StartTaskStack,	<span class="comment">//任务堆栈</span></span><br><span class="line">										(StaticTask_t*  )&amp;StartTaskTCB);	<span class="comment">//任务控制块              </span></span><br><span class="line">    vTaskStartScheduler();          <span class="comment">//开启任务调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始任务任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();           <span class="comment">//进入临界区</span></span><br><span class="line">    <span class="comment">//创建TASK1任务 task1_task</span></span><br><span class="line">	Task1Task_Handler=xTaskCreateStatic((TaskFunction_t	)task1_task,		</span><br><span class="line">										(<span class="type">const</span> <span class="type">char</span>* 	)<span class="string">&quot;task1_task&quot;</span>,		</span><br><span class="line">										(<span class="type">uint32_t</span> 		)TASK1_STK_SIZE,	</span><br><span class="line">										(<span class="type">void</span>* 		  	)<span class="literal">NULL</span>,				</span><br><span class="line">										(UBaseType_t 	)TASK1_TASK_PRIO, 	</span><br><span class="line">										(StackType_t*   )Task1TaskStack,	</span><br><span class="line">										(StaticTask_t*  )&amp;Task1TaskTCB);	</span><br><span class="line">    <span class="comment">//创建TASK2任务  task2_task</span></span><br><span class="line">	Task2Task_Handler=xTaskCreateStatic((TaskFunction_t	)task2_task,		</span><br><span class="line">										(<span class="type">const</span> <span class="type">char</span>* 	)<span class="string">&quot;task2_task&quot;</span>,		</span><br><span class="line">										(<span class="type">uint32_t</span> 		)TASK2_STK_SIZE,	</span><br><span class="line">										(<span class="type">void</span>* 		  	)<span class="literal">NULL</span>,				</span><br><span class="line">										(UBaseType_t 	)TASK2_TASK_PRIO, 	</span><br><span class="line">										(StackType_t*   )Task2TaskStack,	</span><br><span class="line">										(StaticTask_t*  )&amp;Task2TaskTCB);</span><br><span class="line">    vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">    taskEXIT_CRITICAL();            <span class="comment">//退出临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务1函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED1=<span class="number">0</span>;</span><br><span class="line">        vTaskDelay(<span class="number">200</span>);</span><br><span class="line">        LED1=<span class="number">1</span>;</span><br><span class="line">        vTaskDelay(<span class="number">800</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务2函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED2=<span class="number">0</span>;</span><br><span class="line">        vTaskDelay(<span class="number">800</span>);</span><br><span class="line">        LED2=<span class="number">1</span>;</span><br><span class="line">        vTaskDelay(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="任务创建—动态方法"><a href="#任务创建—动态方法" class="headerlink" title="任务创建—动态方法"></a>任务创建—动态方法</h1><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>在使用静态方法创建任务的例程中， 任务控制块和任务栈的内存空间都是从内部的 SRAM 里面分配的， 具体分配到哪个地址由编译器决定。</p>
<p>动态内存， 即堆， 其实堆也是内存， 也属于 SRAM。 FreeRTOS 做法是在 SRAM 里面定义一个大数组， 也就是堆内存， 供 FreeRTOS 的动态内存分配函数使用， 在第一次使用的时候， 系统会将定义的堆内存进行初始化， 这些代码在 FreeRTOS提供的内存管理方案中实现（heap_1.c、 heap_2.c、 heap_4.c 等， 具体的内存管理方案后面详细讲解） ， 具体见代码。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统所有总的堆大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ((size_t)(36*1024)) (1)</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ]; (<span class="number">2</span>)</span><br><span class="line"><span class="comment">/* 如果这是第一次调用 malloc 那么堆将需要初始化， 以设置空闲块列表。 */</span></span><br><span class="line"><span class="keyword">if</span> ( pxEnd == <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line">	prvHeapInit(); 								(<span class="number">3</span>)</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	mtCOVERAGE_TEST_MARKER();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码(1)： 堆内存的大小为 configTOTAL_HEAP_SIZE ， 在 FreeRTOSConfig.h中由我们自己定义， configSUPPORT_DYNAMIC_ALLOCATION 这个宏定义在使用FreeRTOS 操作系统的时候必须开启， 且关闭configSUPPORT_STATIC_ALLOCATION 这个宏。<br>代码(2)： 从内部 SRAMM 里面定义一个静态数组 ucHeap， 大小由configTOTAL_HEAP_SIZE 这个宏决定， 目前定义为 36KB。 定义的堆大小不能超过内部 SRAM 的总大小。<br>代码(3)： 如果这是第一次调用 malloc 那么需要将堆进行初始化， 以设置空闲块列表， 方便以后分配内存， 初始化完成之后会取得堆的结束地址， 在MemMang 中的 5 个内存分配 heap_x.c 文件中实现。  </p>
<h2 id="动态创建任务函数"><a href="#动态创建任务函数" class="headerlink" title="动态创建任务函数"></a>动态创建任务函数</h2><p>xTaskCreate()函数来创建任务  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建开始任务</span></span><br><span class="line">xTaskCreate((TaskFunction_t )start_task, <span class="comment">//任务函数 (1)</span></span><br><span class="line">(<span class="type">const</span> <span class="type">char</span>* )<span class="string">&quot;start_task&quot;</span>, <span class="comment">//任务名称 (2)</span></span><br><span class="line">(<span class="type">uint16_t</span> )START_STK_SIZE, <span class="comment">//任务堆栈大小 (3)</span></span><br><span class="line">(<span class="type">void</span>* )<span class="literal">NULL</span>, <span class="comment">//传递给任务函数的参数 (4)</span></span><br><span class="line">(UBaseType_t )START_TASK_PRIO, <span class="comment">//任务优先级 (5)</span></span><br><span class="line">(TaskHandle_t* )&amp;StartTask_Handler); <span class="comment">//任务句柄 (6)</span></span><br></pre></td></tr></table></figure>

<p>代码(1)： 任务入口函数， 即任务函数的名称，  </p>
<p>代码(2)： 任务名字， 字符串形式，<br>代码(3)： 任务堆栈大小， 单位为字，<br>代码(4)： 任务入口函数形参， 不用的时候配置为 0 或者 NULL 即可。  </p>
<p>代码(5)： 任务的优先级。<br>代码(6)： 任务控制块指针， 在使用内存的时候， 需要给任务初始化函数xTaskCreateStatic()传递预先定义好的任务控制块的指针。 在使用动态内存的时候， 任务创建函数 xTaskCreate()会返回一个指针指向任务控制块， 该任务控制块是 xTaskCreate()函数里面动态分配的一块内存。  </p>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;system.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SysTick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务优先级</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> START_TASK_PRIO		1</span></span><br><span class="line"><span class="comment">//任务堆栈大小	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> START_STK_SIZE 		128  </span></span><br><span class="line"><span class="comment">//任务句柄</span></span><br><span class="line">TaskHandle_t StartTask_Handler;</span><br><span class="line"><span class="comment">//任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务优先级</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_TASK_PRIO		2</span></span><br><span class="line"><span class="comment">//任务堆栈大小	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_STK_SIZE 		50  </span></span><br><span class="line"><span class="comment">//任务句柄</span></span><br><span class="line">TaskHandle_t LED1Task_Handler;</span><br><span class="line"><span class="comment">//任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led1_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务优先级</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_TASK_PRIO		3</span></span><br><span class="line"><span class="comment">//任务堆栈大小	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_STK_SIZE 		50  </span></span><br><span class="line"><span class="comment">//任务句柄</span></span><br><span class="line">TaskHandle_t LED2Task_Handler;</span><br><span class="line"><span class="comment">//任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led2_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名         : main</span></span><br><span class="line"><span class="comment">* 函数功能		   : 主函数</span></span><br><span class="line"><span class="comment">* 输    入         : 无</span></span><br><span class="line"><span class="comment">* 输    出         : 无</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick_Init(<span class="number">72</span>);</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);<span class="comment">//设置系统中断优先级分组4</span></span><br><span class="line">	LED_Init();</span><br><span class="line">	USART1_Init(<span class="number">115200</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建开始任务</span></span><br><span class="line">    xTaskCreate((TaskFunction_t )start_task,            <span class="comment">//任务函数</span></span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;start_task&quot;</span>,          <span class="comment">//任务名称</span></span><br><span class="line">                (<span class="type">uint16_t</span>       )START_STK_SIZE,        <span class="comment">//任务堆栈大小</span></span><br><span class="line">                (<span class="type">void</span>*          )<span class="literal">NULL</span>,                  <span class="comment">//传递给任务函数的参数</span></span><br><span class="line">                (UBaseType_t    )START_TASK_PRIO,       <span class="comment">//任务优先级</span></span><br><span class="line">                (TaskHandle_t*  )&amp;StartTask_Handler);   <span class="comment">//任务句柄              </span></span><br><span class="line">    vTaskStartScheduler();          <span class="comment">//开启任务调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始任务任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();           <span class="comment">//进入临界区</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//创建LED1任务</span></span><br><span class="line">    xTaskCreate((TaskFunction_t )led1_task,     </span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;led1_task&quot;</span>,   </span><br><span class="line">                (<span class="type">uint16_t</span>       )LED1_STK_SIZE, </span><br><span class="line">                (<span class="type">void</span>*          )<span class="literal">NULL</span>,</span><br><span class="line">                (UBaseType_t    )LED1_TASK_PRIO,</span><br><span class="line">                (TaskHandle_t*  )&amp;LED1Task_Handler); </span><br><span class="line">				</span><br><span class="line">	<span class="comment">//创建LED2任务</span></span><br><span class="line">    xTaskCreate((TaskFunction_t )led2_task,     </span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;led2_task&quot;</span>,   </span><br><span class="line">                (<span class="type">uint16_t</span>       )LED2_STK_SIZE, </span><br><span class="line">                (<span class="type">void</span>*          )<span class="literal">NULL</span>,</span><br><span class="line">                (UBaseType_t    )LED2_TASK_PRIO,</span><br><span class="line">                (TaskHandle_t*  )&amp;LED2Task_Handler); </span><br><span class="line">				</span><br><span class="line">    vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">    taskEXIT_CRITICAL();            <span class="comment">//退出临界区</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//LED1任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led1_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED1=<span class="number">0</span>;</span><br><span class="line">        vTaskDelay(<span class="number">200</span>);</span><br><span class="line">        LED1=<span class="number">1</span>;</span><br><span class="line">        vTaskDelay(<span class="number">800</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LED2任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led2_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED2=<span class="number">0</span>;</span><br><span class="line">        vTaskDelay(<span class="number">800</span>);</span><br><span class="line">        LED2=<span class="number">1</span>;</span><br><span class="line">        vTaskDelay(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="FreeRTOS启动流程"><a href="#FreeRTOS启动流程" class="headerlink" title="FreeRTOS启动流程"></a>FreeRTOS启动流程</h1><p>动态分配内存</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627000619896.png" alt="image-20240627000619896"></p>
<h2 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h2><p>在系统上电的时候第一个执行的是启动文件里面由汇编编写的复位函数 Reset_Handler  </p>
<p>位函数的最后会调用 C 库函数 main_ ___。 __main _ 函数的主要工作是初始化系统的堆和栈， 最后调用 C 中 的 main 函数， 从而去到 C 的世界。<br>在 main()函数中， 我们直接进行创建任务操作， 因为 FreeRTOS 会自动帮我们做初始化的事情， 比如初始化堆内存。 FreeRTOS 的简单方便是在别的实时操作系统上都没有的， 像 RT-Tharead， 需要做很多事情。</p>
<p>这种简单的特点使得 FreeRTOS 在初学的时候变得很简单， 我们自己在main()函数中直接初始化我们的板载外设资源， 然后进行任务的创建即可。<br>**xTaskCreate()**， 在任务创建中， FreeRTOS 会帮我们进行一系列的系统初始化，在创建任务的时候， 会帮我们初始化堆内存，  </p>
<p>在未初始化内存的时候一旦调用了xTaskCreate()函数， FreeRTOS 就会帮我们自动进行内存的初始化， 可以打开工程查看。 注意， 此函数是 FreeRTOS 内部调用的， 目前我们暂时不用管这个函数的实现， 在后面我们会仔细讲解 FreeRTOS 的内存管理相关知识， 现在我们知道FreeRTOS 会帮我们初始化系统要用的东西即可。</p>
<h2 id="任务的调度"><a href="#任务的调度" class="headerlink" title="任务的调度"></a>任务的调度</h2><p>在创建完任务的时候， 我们需要开启调度器， 因为创建仅仅是把任务添加到系统中， 还没真正调度， 并且空闲任务也没实现， 定时器任务也没实现， 这些都是在开启调度函数 vTaskStartScheduler()中实现的。 </p>
<p>为什么要空闲任务？ 因为FreeRTOS 一旦启动， 就必须要保证系统中每时每刻都有一个任务处于运行态（Runing） ， 并且空闲任务不可以被挂起与删除， 空闲任务的优先级是最低的，以便系统中其他任务能随时抢占空闲任务的 CPU 使用权。 这些都是系统必要的<br>东西， 也无需用户自己实现， FreeRTOS 全部帮我们搞定了。 处理完这些必要的东西之后， 系统才真正开始启动。</p>
<h2 id="主函数-1"><a href="#主函数-1" class="headerlink" title="主函数"></a>主函数</h2><p>当我们拿到一个移植好 FreeRTOS 的例程的时候， 不出意外， 你首先看到的是 main 函数， 当你认真一看 main 函数里面只是创建并启动一些任务和硬件初始化。 而系统初始化这些工作不需要我们实现， 因为 FreeRTOS 在我们使用创建与开启调度的时候就已经偷偷帮我们做完了， 如果只是使用FreeRTOS 的话， 无需关注 FreeRTOS API 函数里面的实现过程， 但是如果有精力我们还是建议需要深入了解 FreeRTOS 然后再去使用， 避免出现问题 。</p>
<p><strong>当创建的应用任务的优先级比 start_task 任务的优先级高、 低或者相等时候， 程序是如何执行的？</strong> </p>
<p>假如像我们代码一样在临界区创建任务， 任务只能在退出临界区的时候才执行最高优先级任务。 假如没使用临界区的话， 就会分三种情<br>况： </p>
<p>1、 应用任务的优先级比初始任务的优先级高， 那创建完后立马去执行刚刚  创建的应用任务， 当应用任务被阻塞时， 继续回到初始任务被打断的地方继续往下执行， 直到所有应用任务创建完成， 最后初始任务把自己删除， 完成自己的使命； </p>
<p>2、 应用任务的优先级与初始任务的优先级一样， 那创建完后根据任务的时间片来执行， 直到所有应用任务创建完成， 最后初始任务把自己删除， 完成自己的使命；</p>
<p> 3、 应用任务的优先级比初始任务的优先级低， 那创建完后任务不会被执行， 如果还有应用任务紧接着创建应用任务， 如果应用任务的优先级出现了比初始任务高或者相等的情况， 请参考 1 和 2 的处理方式， 直到所有应用任务创建完成， 最后初始任务把自己删除， 完成自己的使命  </p>
<p>假如任务调度器启动没成功（大概率 是Task函数中有返回值）， 则通过 LR 寄存器指定的地址退出  </p>
<h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><h2 id="任务简介"><a href="#任务简介" class="headerlink" title="任务简介"></a>任务简介</h2><p>从系统的角度看， 任务是竞争系统资源的最小运行单元。 FreeRTOS 是一个支持多任务的操作系统。 在 FreeRTOS 中， 任务可以使用或等待 CPU、 使用内存空间等系统资源， 并独立于其它任务运行， 任何数量的任务可以共享同一个优先级， 如果宏 configUSE_TIME_SLICING 定义为 1， 处于就绪态的多个相同优先级任务将会以时间片切换的方式共享处理器。</p>
<p>简而言之： FreeRTOS 的任务可认为是一系列独立任务的集合。 每个任务在自己的环境中运行。 在任何时刻， 只有一个任务得到运行， FreeRTOS 调度器决定运行哪个任务。 调度器会不断的启动、 停止每一个任务， 宏观看上去所有的任务都在同时在执行。 作为任务， 不需要对调度器的活动有所了解， <strong>在任务切入切出时保存上下文环境（寄存器值、 堆栈内容） 是调度器主要的职责</strong>。 为了实现这点，<br>每个 FreeRTOS 任务都需要有自己的栈空间。当任务切出时， <strong>它的执行环境会被保存在该任务的栈空间中</strong>， 这样当任务再<br>次运行时， 就能从堆栈中正确的恢复上次的运行环境， 任务越多， 需要的堆栈空间就越大， 而一个系统能运行多少个任务， 取决于系统的可用的 SRAM。FreeRTOS 可以给用户提供多个任务单独享有独立的堆栈空间， 系统可以决定任务的状态， 决定任务是否可以运行， 同时还能运用内核的 IPC 通信资源，实现了任务之间的通信， 帮助用户管理业务程序流程。 这样用户可以将更多的精力投入到业务功能的实现中。</p>
<p>FreeRTOS 中的任务是<strong>抢占式调度机制</strong>， 高优先级的任务可打断低优先级任务， 低优先级任务必须在高优先级任务阻塞或结束后才能得到调度。 同时FreeRTOS 也支持<strong>时间片轮转调度方式</strong>， 只不过时间片的调度是不允许抢占任务的 CPU 使用权。</p>
<p>任务通常会运行在一个死循环中， 也不会退出， 如果一个任务不再需要， 可以调用 FreeRTOS 中的任务删除 API 函数接口显式地将其删除。  </p>
<h2 id="任务调度器简介"><a href="#任务调度器简介" class="headerlink" title="任务调度器简介"></a>任务调度器简介</h2><p>FreeRTOS 中提供的任务调度器是<strong>基于优先级的全抢占式调度</strong>： 在系统中除了中断处理函数、 调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的  </p>
<p>一个操作系统如果只是具备了高优先级任务能够“立即” 获得处理器并得到执行的特点， 那么它仍然不算是实时操作系统。 因为这个查找最高优先级任务的过程决定了调度时间是否具有确定性， 例如一个包含 n 个就绪任务的系统中<strong>，如果仅仅从头找到尾， 那么这个时间将直接和 n 相关， 而下一个就绪任务抉择时间的长短将会极大的影响系统的实时性</strong>。  </p>
<p>FreeRTOS 内核中采用两种方法寻找最高优先级的任务，</p>
<p> 第一种是通用的方法， 在就绪链表中查找从高优先级往低查找 uxTopPriority， 因为在创建任务的时候已经将优先级进行排序， 查找到的第一个 uxTopPriority 就是我们需要的任务， 然后通过 uxTopPriority 获取对应的任务控制块。</p>
<p> 第二种方法则是特殊方法， <strong>利用计算前导零指令 CLZ， 直接在 uxTopReadyPriority 这个 32 位的变量中直接得出 uxTopPriority， 这样子就知道哪一个优先级任务能够运行</strong>， 这种调度算法比普通方法更快捷， 但受限于平台（在 STM32 中我们就使用这种方法）。</p>
<p>FreeRTOS 内核中也允许创建相同优先级的任务。 相同优先级的任务采用<strong>时间片轮转</strong>方式进行调度（也就是通常说的<strong>分时调度器</strong>） ， 时间片轮转调度仅在当前系统中无更高优先级就绪任务存在的情况下才有效。 为了保证系统的实时性，系统尽最大可能地保证高优先级的任务得以运行。 任务调度的原则是一旦任务状态发生了改变， 并且当前运行的任务优先级小于优先级队列组中任务最高优先级时， 立刻进行任务切换（除非当前系统处于中断处理程序中或禁止任务切换的状  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627111218022.png" alt="image-20240627111218022"></p>
<h2 id="任务状态简介"><a href="#任务状态简介" class="headerlink" title="任务状态简介"></a>任务状态简介</h2><p>就绪（Ready） ： 该任务在就绪列表中， 就绪的任务已经具备执行的能力，只等待调度器进行调度， 新创建的任务会初始化为就绪态。</p>
<p>运行（Running） ： 该状态表明任务正在执行， 此时它占用处理器， FreeRTOS调度器选择运行的永远是处于最高优先级的就绪态任务， 当任务被运行的一刻，它的任务状态就变成了运行态。</p>
<p>阻塞（Blocked） ： 如果任务当前正在等待某个时序或外部中断， 我们就说这个任务处于阻塞状态， 该任务不在就绪列表中。 包含任务被挂起、 任务被延时、任务正在等待信号量、 读写队列或者等待读写事件等。</p>
<p>挂起态(Suspended)： 处于挂起态的任务对调度器而言是不可见的， 让一个任务进入挂起状态的唯一办法就是调用 vTaskSuspend()函数； 而把一个挂起状态的任务恢复的唯一途径就是调用 vTaskResume() 或 vTaskResumeFromISR()函数， 我们可以这么理解挂起态与阻塞态的区别， 当任务有较长的时间不允许运行的时候， 我们可以挂起任务， 这样子调度器就不会管这个任务的任何信息， 直到我们调用恢复任务的 API 函数； 而任务处于阻塞态的时候， 系统还需要判断阻塞态的任务是否超时， 是否可以解除阻塞。</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627112641710.png" alt="image-20240627112641710"></p>
<p>图(1)： 创建任务→就绪态（Ready） ： 任务创建完成后进入就绪态， 表明任务已准备就绪， 随时可以运行， 只等待调度器进行调度。</p>
<p>图(2)： 就绪态→运行态（Running） ： 发生任务切换时， 就绪列表中最高优先级的任务被执行， 从而进入运行态。</p>
<p>图(3)： 运行态→就绪态： 有更高优先级任务创建或者恢复后， 会发生任务调度， 此刻就绪列表中最高优先级任务变为运行态， 那么原先运行的任务由运行态变为就绪态， 依然在就绪列表中， 等待最高优先级的任务运行完毕继续运行原来的任务（此处可以看做是 CPU 使用权被更高优先级的任务抢占了） 。</p>
<p>图(4)： 运行态→阻塞态（Blocked） ： 正在运行的任务发生阻塞（挂起、 延时、 读信号量等待） 时， 该任务会从就绪列表中删除， 任务状态由运行态变成阻塞态， 然后发生任务切换， 运行就绪列表中当前最高优先级任务。</p>
<p>图(5)： 阻塞态→就绪态： 阻塞的任务被恢复后（任务恢复、 延时时间超时、读信号量超时或读到信号量等） ， 此时被恢复的任务会被加入就绪列表， 从而由阻塞态变成就绪态； 如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换， 将该任务将再次转换任务状态， 由就绪态变成运行态。</p>
<p>图(6)(7)(8)： 就绪态、 阻塞态、 运行态→挂起态（Suspended） ： 任务可以通过调用 vTaskSuspend() API 函数都可以将处于任何状态的任务挂起， 被挂起的任务得不到 CPU 的使用权， 也不会参与调度， 除非它从挂起态中解除。</p>
<p>图(9)： 挂起态→就绪态： 把一个挂起状态的任务恢复的唯一途径就是调用  vTaskResume() 或 vTaskResumeFromISR() API 函数， 如果此时被恢复任务的优先级高于正在运行任务的优先级， 则会发生任务切换， 将该任务将再次转换任务状态， 由就绪态变成运行态。  </p>
<h2 id="常用任务API函数"><a href="#常用任务API函数" class="headerlink" title="常用任务API函数"></a>常用任务API函数</h2><h3 id="任务挂起函数"><a href="#任务挂起函数" class="headerlink" title="任务挂起函数"></a>任务挂起函数</h3><p>任务挂起是我们经常使用的一个函数  </p>
<h4 id="vTaskSuspend"><a href="#vTaskSuspend" class="headerlink" title="vTaskSuspend()"></a>vTaskSuspend()</h4><p>挂起指定任务。 被挂起的任务绝不会得到 CPU 的使用权， 不管该任务具有什么优先级。 任务可以通过调用 vTaskSuspend()函数都可以将处于任何状态的任务挂起， 被挂起的任务得不到 CPU 的使用权， 也不会参与调度， 它相对于调度器而言是不可见的， 除非它从挂起态中解除 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627113804848.png" alt="image-20240627113804848"></p>
<p>任务可以调用 vTaskSuspend()这个函数来挂起任务自身， 但是在挂起自身的时候会进行一次任务上下文切换， 需要挂起自身就将 xTaskToSuspend 设置为 NULL 传递进来即可。 无论任务是什么状态都可以被挂起， 只要调用了vTaskSuspend()这个函数就会挂起成功， 不论是挂起其他任务还是挂起任务自身。</p>
<p>任务的挂起与恢复函数在很多时候都是很有用的， 比<strong>如我们想暂停某个任务运行一段时间， 但是我们又需要在其恢复的时候继续工作</strong>， 那么删除任务是不可能的， 因为删除了任务的话， 任务的所有的信息都是不可能恢复的了， 删除是完完全全删除了， 里面的资源都被系统释放掉， 但是挂起任务就不会这样子， 调用挂起任务函数， 仅仅是将任务进入挂起态， 其内部的资源都会保留下来， 同时也不会参与系统中任务的调度， 当<strong>调用恢复函数</strong>的时候， 整个任务立即从挂起态进入就绪态， 并且参与任务的调度， 如果该任务的优先级是当前就绪态优先级最高的任务， 那么立即会按照挂起前的任务状态继续执行该任务， 从而达到我们需要的效果， 注意， 是继续执行， 也就是说， 挂起任务之前是什么状态， 都会被系统保留下来， 在恢复的瞬间， 继续执行。 这个任务函数的使用方法是很简单的， 只需把<strong>任务句柄传递</strong>进来即可， vTaskSuspend()会根据任务句柄的信息将对应的任务挂起  </p>
<h4 id="vTaskSuspendAll"><a href="#vTaskSuspendAll" class="headerlink" title="vTaskSuspendAll()"></a>vTaskSuspendAll()</h4><p>这个函数将所有的任务都挂起，它将调度器锁定， 并且这个函数是可以进行嵌套的， 说白了挂起所有任务就是挂起任务调度器。 调度器被挂起后则不能进行上下文切换， 但是中断还是使能的。</p>
<p>当调度器被挂起的时候， 如果有中断需要进行上下文切换， 那么这个任务将会被  挂起， 在调度器恢复之后才执行切换任务。 </p>
<p> 调度器恢复可以调用 xTaskResumeAll() 函数， 调用了多少次的vTaskSuspendAll() 就要调用多少次 xTaskResumeAll()进行恢复，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure>

<h3 id="任务恢复函数"><a href="#任务恢复函数" class="headerlink" title="任务恢复函数"></a>任务恢复函数</h3><h4 id="vTaskResume"><a href="#vTaskResume" class="headerlink" title="vTaskResume()"></a>vTaskResume()</h4><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627114523332.png" alt="image-20240627114523332"></p>
<p>任务恢复就是让挂起的任务重新进入就绪状态， 恢复的任务会保留挂起前的状态信息， 在恢复的时候根据挂起时的状态继续运行。 如果被恢复任务在所有就绪态任务中， 处于最高优先级列表的第一位，那么系统将进行任务上下文的切换。 </p>
<blockquote>
<p>如果想要使用任务恢复函数 vTaskResume()则必须将宏定义INCLUDE_vTaskSuspend 配置为 1， 因为任务挂起只能通过调用 vTaskSuspend()函数进行挂起 ， 没挂起的任务就无需恢复， 当需要调用 vTaskSuspend()函数就必须使能 INCLUDE_vTaskSuspend 这个宏定义， 所以想要使用 FreeRTOS 的任务挂起与恢复函数就必须将这个宏定义配置为 1。  </p>
</blockquote>
<h4 id="xTaskResumeFromISR"><a href="#xTaskResumeFromISR" class="headerlink" title="xTaskResumeFromISR()"></a>xTaskResumeFromISR()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ( ( INCLUDE_xTaskResumeFromISR == 1 ) &amp;&amp; ( INCLUDE_vTaskSuspend == 1 ) ) </span></span><br><span class="line">BaseType_t <span class="title function_">xTaskResumeFromISR</span><span class="params">( TaskHandle_t xTaskToResume )</span>   <span class="comment">//xTaskToResume 是恢复指定任务的任务句柄</span></span><br></pre></td></tr></table></figure>

<p>xTaskResumeFromISR()与 vTaskResume()一样都是用于恢复被挂起的任务，不一样的是 xTaskResumeFromISR()专门用在<strong>中断服务程序</strong>中。 无论通过调用一次或多次 vTaskSuspend()函数而被挂起的任务， 也只需调用一次xTaskResumeFromISR()函数即可解挂。 要想使用该函数必须在FreeRTOSConfig.h 中 把 INCLUDE_vTaskSuspend 和INCLUDE_vTaskResumeFromISR 都定义为 1 才有效。</p>
<p> 任务还没有处于挂起态的时候， 调用 xTaskResumeFromISR()函数是没有任何意义的。</p>
<p>使用 xTaskResumeFromISR()的时候有几个需要注意的地方：<br>1.当函数的返回值为 pdTRUE 时： 恢复运行的任务的优先级等于或高于正在运行的任务， 表明在中断服务函数退出后必须进行一次上下文切换， 使用portYIELD_FROM_ISR()进行上下文切换。 </p>
<p>当函数的返回值为 pdFALSE 时： 恢复运行的任务的优先级低于当前正在运行的任务， 表明在中断服务函数退出后不需要进行上下文切换。</p>
<p>2.xTaskResumeFromISR()通常被认为是一个危险的函数， 因为它的调用并非是固定的， 中断可能随时来来临。 所以， xTaskResumeFromISR()不能用于任务和中断间的同步， 如果中断恰巧在任务被挂起之前到达， 这就会导致一次中断丢失  任务还没有挂起， 调用 xTaskResumeFromISR()函数是没有意义的， 只能等下一次中断） 。 这种情况下， 可以使用<strong>信号量</strong>或者任务通知来同步就以避免这种情况  </p>
<h4 id="xTaskResumeAll"><a href="#xTaskResumeAll" class="headerlink" title="xTaskResumeAll()"></a>xTaskResumeAll()</h4><p>当调用了vTaskSuspendAll()函数将调度器挂起， 想要恢复调度器的时候我们就需要调用xTaskResumeAll()函数，  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskResumeAll</span><span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure>

<p>xTaskResumeAll 函数的使用方法很简单， 但是要注意， 调用了多少次vTaskSuspendAll()函数就必须同样调用多少次 xTaskResumeAll()函数  </p>
<h3 id="任务删除函数"><a href="#任务删除函数" class="headerlink" title="任务删除函数"></a>任务删除函数</h3><h4 id="vTaskDelete"><a href="#vTaskDelete" class="headerlink" title="vTaskDelete()"></a>vTaskDelete()</h4><p>vTaskDelete()用于删除一个任务。 当一个任务删除另外一个任务时， 形参为要删除任务创建时返回的任务句柄， 如果是删除自身， 则形参为 NULL。 </p>
<p>要想使用该函数必须在 FreeRTOSConfig.h 中把 INCLUDE_vTaskDelete 定义为 1，删除的任务将从所有就绪， 阻塞， 挂起和事件列表中删除  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span></span><br></pre></td></tr></table></figure>

<h3 id="任务延时函数"><a href="#任务延时函数" class="headerlink" title="任务延时函数"></a>任务延时函数</h3><h4 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay()"></a>vTaskDelay()</h4><p>vTaskDelay()在我们任务中用得非常之多， 每个任务都必须是死循环， 并且是必须要有阻塞的情况， 否则低优先级的任务就无法被运行了。 要想使用FreeRTOS 中的 vTaskDelay()函数必须在 FreeRTOSConfig.h 中把INCLUDE_vTaskDelay 定义为 1 来使能  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span></span><br></pre></td></tr></table></figure>

<p>vTaskDelay()用于阻塞延时， 调用该函数后， 任务将进入阻塞状态， 进入阻塞态的任务将让出 CPU 资源。 延时的时长由形参 xTicksToDelay 决定， 单位为系统节拍周期  </p>
<p>vTaskDelay()延时是相对性的延时， 它指定的延时时间是从调用vTaskDelay()结束后开始计算的， 经过指定的时间后延时结束。 比如<br>vTaskDelay(100)， 从调用 vTaskDelay()结束后， 任务进入阻塞状态， 经过 100个系统时钟节拍周期后， 任务解除阻塞。 因此， vTaskDelay()并不适用与周期性执行任务的场合。 </p>
<p>此外， 其它任务和中断活动， 也会影响到 vTaskDelay()的调用（比如调用前高优先级任务抢占了当前任务） ， 进而影响到任务的下一次执行的时间  </p>
<h4 id="vTaskDelayUntil"><a href="#vTaskDelayUntil" class="headerlink" title="vTaskDelayUntil()"></a>vTaskDelayUntil()</h4><p>在 FreeRTOS 中， 除了相对延时函数， 还有绝对延时函数vTaskDelayUntil()， 这个绝对延时常用于较精确的周期运行任务， 比如我有一<br>个任务， 希望它以固定频率定期执行， 而不受外部的影响， 任务从上一次运行开始到下一次运行开始的时间间隔是绝对的， 而不是相对的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ( INCLUDE_vTaskDelayUntil == 1 )</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( TickType_t * <span class="type">const</span> pxPreviousWakeTime,</span></span><br><span class="line"><span class="params"><span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure>

<p>要想使用该函数必须在 FreeRTOSConfig.h 中把 INCLUDE_vTaskDelayUntil定义为 1 来使能。</p>
<p>vTaskDelayUntil()与 vTaskDelay ()一样都是用来实现任务的周期性延时。但 vTaskDelay ()的延时是相对的， 是不确定的， 它的延时是等 vTaskDelay ()调用完毕后开始计算的。 并且 vTaskDelay ()延时的时间到了之后， 如果有<strong>高优先级的任务或者中断正在执行</strong>， 被延时阻塞的任务并不会马上解除阻塞， 所以每次执行任务的周期并不完全确定。 </p>
<p>而 vTaskDelayUntil()延时是绝对的， 适用于周期性执行的任务。 当(*pxPreviousWakeTime + xTimeIncrement)时间到达后，vTaskDelayUntil()函数立刻返回， 如果任务是最高优先级的， 那么任务会立马解除阻塞， 所以说 vTaskDelayUntil()函数的延时是绝对性的</p>
<p>在使用的时候要将延时时间转化为系统节拍， 在任务主体之前要调用延时函数。 任务会先调用 vTaskDelayUntil()使任务进入阻塞态， 等到时间到了就从阻塞中解除， 然后执行主体代码， 任务主体代码执行完毕。 会继续调用vTaskDelayUntil()使任务进入阻塞态， 然后就是循环这样子执行。 即使任务在执行过程中发生中断， 那么也不会影响这个任务的运行周期， 仅仅是缩短了阻塞的时间而已， 到了要唤醒的时间依旧会将任务唤醒   </p>
<h2 id="任务的设计要点"><a href="#任务的设计要点" class="headerlink" title="任务的设计要点"></a>任务的设计要点</h2><p>作为设计人员，任务的优先级信息， 任务与中断的处理， 任务的运行时间、 逻辑、 状态等都要知道， 才能设计出好的系统， 所以， 在设计的时候需要根据需求制定框架。 在设计之初就应该考虑下面几点因素： 任务运行的上下文环境、 任务的执行时间合理设计。<br>FreeRTOS 中程序运行的上下文包括：<br>①中断服务函数。</p>
<p>②普通任务。</p>
<p>③空闲任务。</p>
<p>④任务执行时间</p>
<h3 id="①中断服务函数："><a href="#①中断服务函数：" class="headerlink" title="①中断服务函数："></a>①中断服务函数：</h3><p>中断服务函数是一种需要特别注意的上下文环境， 它运行在非任务的执行环境下（一般为芯片的一种特殊运行模式（也被称作特权模式） ） ， 在这个上下文环境中<strong>不能使用挂起当前任务的操作</strong>， <strong>不允许调用任何会阻塞运行的 API 函数接口</strong>。 </p>
<p>另外需要注意的是， 中断服务程序最好保持<strong>精简短小， 快进快出</strong>， 一般在中断服务函数中只做<strong>标记事件的发生</strong>， 然后通知任务， 让对应任务去执行相关处理， 因为中断服务函数的优先级高于任何优先级的任务， 如果中断处理时间过长，将会导致整个系统的任务无法正常运行。 所以在设计的时候必须考虑中断的频率、 中断的处理时间等重要因素， 以便配合对应中断处理任务的工作。</p>
<h3 id="②任务："><a href="#②任务：" class="headerlink" title="②任务："></a>②任务：</h3><p>任务看似没有什么限制程序执行的因素， 似乎所有的操作都可以执行。 但是做为一个<strong>优先级明确的实时系统</strong>， 如果一个任务中的程序出现了死循环操作（此处的死循环是指<strong>没有阻塞机制的任务循环体</strong>） ， 那么比这个任务优先级低的任务  都将无法执行， 当然也包括了空闲任务， 因为死循环的时候， 任务不会主动让出CPU， 低优先级的任务是不可能得到 CPU 的使用权的， 而高优先级的任务就可以<br>抢占 CPU。 </p>
<p>这个情况在实时操作系统中是必须注意的一点， 所以<strong>在任务中不允许出现死循环</strong>。 如果一个任务只有就绪态而无阻塞态， 势必会影响到其他低优先级任务的执行， 所以在进行任务设计时， 就应该保证任务在不活跃的时候， 任务可以进入阻塞态以交出 CPU 使用权， 这就需要我们自己明确知道什么情况下让任务进入阻塞态， 保证低优先级任务可以正常运行。 在实际设计中， 一般会将紧急的处理事件的任务优先级设置得高一些。</p>
<h3 id="③空闲任务："><a href="#③空闲任务：" class="headerlink" title="③空闲任务："></a>③空闲任务：</h3><p>空闲任务（idle 任务） 是 FreeRTOS 系统中没有其他工作进行时自动进入的系统任务。 因为处理器总是需要代码来执行——所以至少要有一个任务处于运行态。</p>
<p> FreeRTOS 为了保证这一点， 当调用 vTaskStartScheduler()时， 调度器会自动创建一个空闲任务， 空闲任务是一个非常短小的循环。 用户可以通过空闲任务钩子方式， 在空闲任务上钩入自己的功能函数。 通常这个空闲任务钩子能够完成一些额外的特殊功能， 例如<strong>系统运行状态的指示， 系统省电模式</strong>等。</p>
<p> 除了空闲任务钩子， FreeRTOS 系统还把空闲任务用于一些其他的功能， <strong>比如当系统删除一个任务或一个动态任务运行结束时</strong>， 在执行删除任务的时候， 并不会释放任务的内存空间， 只会将任务添加到结束列表中， <strong>真正的系统资源回收工作在空闲任务完成</strong>， 空闲任务是唯一一个不允许出现阻塞情况的任务， 因为 FreeRTOS 需要保证系统永远都有一个可运行的任务。</p>
<p>对于空闲任务钩子上挂接的空闲钩子函数， 它应该满足以下的条件：<br>· 永远不会挂起空闲任务；<br>· 不应该陷入死循环， 需要留出部分时间用于系统处理系统资源回收。</p>
<h3 id="④任务的执行时间："><a href="#④任务的执行时间：" class="headerlink" title="④任务的执行时间："></a>④任务的执行时间：</h3><p>任务的执行时间一般是指两个方面， 一是<strong>任务从开始到结束的时间</strong>， 二是<strong>任务的周期</strong>。</p>
<p>在系统设计的时候这两个时间候我们都需要考虑， 例如， 对于事件 A 对应的服务任务 Ta， 系统要求的实时响应指标是 10ms， 而 Ta 的最大运行时间是1ms， 那么 10ms 就是任务 Ta 的周期了， 1ms 则是任务的运行时间， <em>简单来说 任务 Ta 在 10ms 内完成对事件 A 的响应即可</em>。</p>
<p> 此时， 系统中还存在着以 50ms为周期的另一任务 Tb， 它每次运行的最大时间长度是 100us。 在这种情况下，即使把任务 Tb 的优先级抬到比 Ta 更高的位置， 对系统的实时性指标也没什么影响， 因为即使在 Ta 的运行过程中， Tb 抢占了 Ta 的资源， 等到 Tb 执行完毕， 消耗的时间也只不过是 100us， 还是在事件 A 规定的响应时间内(10ms)，Ta 能够安全完成对事件 A 的响应。 </p>
<p>但是假如系统中还存在任务 Tc， 其运行时间为 20ms， 假如将 Tc 的优先级设置比 Ta 更高， 那么在 Ta 运行的时候， 突然间被 Tc 打断， 等到 Tc 执行完毕， 那 Ta 已经错过对事件 A（10ms） 的响应了， 这是不允许的。 所以在我们设计的时候， 必须考虑任务的时间， 一般来说<strong>处理时间更短的任务优先级应设置更高一些</strong>。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627153014435.png" alt="image-20240627153014435"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LED1任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led1_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED1=<span class="number">0</span>;</span><br><span class="line">        vTaskDelay(<span class="number">200</span>);</span><br><span class="line">        LED1=<span class="number">1</span>;</span><br><span class="line">        vTaskDelay(<span class="number">800</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LED2任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led2_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED2=<span class="number">0</span>;</span><br><span class="line">        vTaskDelay(<span class="number">800</span>);</span><br><span class="line">        LED2=<span class="number">1</span>;</span><br><span class="line">        vTaskDelay(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		key = KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY_UP_PRESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;挂起LED任务！\n&quot;</span>);</span><br><span class="line">			vTaskSuspend(LED2Task_Handler);<span class="comment">/* 挂起LED任务 */</span> </span><br><span class="line">             <span class="comment">// LED2Task_Handler 为 led1_task的 任务句柄</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;挂起LED任务成功！\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(key==KEY1_PRESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;恢复LED任务！\n&quot;</span>);</span><br><span class="line">			vTaskResume(LED2Task_Handler);<span class="comment">/* 恢复LED任务！*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;恢复LED任务成功！\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		vTaskDelay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="消息队列–-任务间的数据传输"><a href="#消息队列–-任务间的数据传输" class="headerlink" title="消息队列–&gt;任务间的数据传输"></a>消息队列–&gt;任务间的数据传输</h1><p>消息队列是一种常用于任务间通信的数据结构。 通过消息队列服务， 任务或中断服务例程可以<strong>将一条或多条消息放入消息队列中， 同样， 一个或多个任务可以从消息队列中获得消息</strong>。 本章将向大家介绍 FreeRTOS 的消息队列， 通过本章的学习， 让大家对操作系统中<strong>任务间数据传输</strong>更加了解。 </p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>队列是为了<strong>任务与任务、 任务与中断之间的通信</strong>而准备的， 可以在任务与任务、 任务与中断之间传递消息， 队列中可以存储有限的、 大小固定的数据项目。</p>
<p>任务与任务、 任务与中断之间要交流的数据保存在队列中， 叫做<strong>队列项目</strong>。 </p>
<p>队列所能保存的最大数据项目数量叫做<strong>队列的长度</strong></p>
<p>创建队列的时候会指定数据项目的大小和队列的长度。 </p>
<p>由于队列用来传递消息的， 所以也称为消息队列。 </p>
<h3 id="消息队列数据存储"><a href="#消息队列数据存储" class="headerlink" title="消息队列数据存储"></a>消息队列数据存储</h3><p>通常队列采用先进先出(FIFO)的存储缓冲机制， 也就是往队列发送数据的时候(也叫入队)永远都是发送到队列的尾部， 而从队列提取数据的时候(也叫出队)是从队列的头部提取的。 </p>
<p>但是也可以使用 LIFO 的存储缓冲， 也就是后进先出，FreeRTOS 中的队列也提供了 LIFO 的存储缓冲机制。</p>
<p>数据发送到队列中会导致数据拷贝， 也就是将要发送的数据拷贝到队列中，这就意味着在队列中存储的是数据的原始值， 而不是原数据的引用(即只传递数据的指针)， 这个也叫做<strong>值传递</strong>。 </p>
<p>学过 UCOS 的同学应该知道， UCOS 的消息队列采用的是<strong>引用传递</strong>， 传递的是消息指针。 采用引用传递的话消息内容就必须一直保持可见性， 也就是消息内容必须有效， 那么局部变量这种可能会随时被删掉的东西就不能用来传递消息， 但是采用引用传递会节省时间！ 因为不用进行数据拷贝。</p>
<blockquote>
<p>值传递  	是把数据复制一份到队列中</p>
<p>引用传递  是把存放数据的地址 放到队列中</p>
</blockquote>
<p>采用值传递的话虽然会导致数据拷贝， 会浪费一点时间， 但是一旦将消息发送到队列中原始的数据缓冲区就可以删除掉或者覆写， 这样的话这些缓冲区就可以被重复的使用。 </p>
<p>FreeRTOS 中使用队列传递消息的话虽然使用的是数据拷贝，但是也可以使用引用来传递消息， 直接往队列中发送指向这个消息的地址指针就可以了！ 这样当要发送的消息数据太大的时候就可以直接发送消息缓冲区的地址指针， 比如在网络应用环境中， 网络的数据量往往都很大的， 采用数据拷贝的话就不现实</p>
<h3 id="消息队列阻塞机制"><a href="#消息队列阻塞机制" class="headerlink" title="消息队列阻塞机制"></a>消息队列阻塞机制</h3><h4 id="出队阻塞"><a href="#出队阻塞" class="headerlink" title="出队阻塞"></a>出队阻塞</h4><p>当任务尝试从一个队列中<strong>读取消息</strong>的时候可以指定一个阻塞时间， 这个阻塞时间就是<strong>当任务从队列中读取 消息 无效的时候任务阻塞的时</strong>间。</p>
<p>出队就是从队列中读取消息， 出队阻塞是针对从队列中读取消息的任务而言的。 </p>
<p>比如任务 A 用于处理串口接收到的数据， 串口接收到数据以后就会放到队列 Q 中， 任务 A 从队列 Q 中读取数据。 但是如果此时队列 Q 是空的， 说明还没有数据， 任务 A 这时候来读取的话肯定是获取不到任何东西， 那该怎么办呢？ </p>
<p>任务 A 现在有三种：<br>一： 二话不说扭头就走， </p>
<p>二： 要不我在等等吧， 等一会看看， 说不定一会就有数据了</p>
<p>三： 死等， 死也要等到你有数据！</p>
<p> 选哪一个就是由这个阻塞时间决定的， 这个阻塞时间单位是时钟节拍数。 </p>
<p>阻塞时间为 0 的话就是不阻塞， 没有数据的话就马上返回任务继续执行接下来的代码， 对应第一种选择。 </p>
<p>如果阻塞时间为 0~ portMAX_DELAY 之间， 当任务没有从队列中获取到消息的话就进入阻塞态， 阻塞时间指定了任务进入阻塞态的时间， 当阻塞时间到了以后还没有接收到数据的话就退出阻塞态， 返回任务接着运行下面的代码， 如果在阻塞时间内接收到了数据就立即返回， 执行任务中下面的代码， 这种情况对应第二种选择。 </p>
<p>当阻塞时间设置为 portMAX_DELAY 的话， 任务就会一直进入阻塞态等待， 直到接收到数据为止！ 这个就是第三种选择。  </p>
<h4 id="入队阻塞"><a href="#入队阻塞" class="headerlink" title="入队阻塞"></a>入队阻塞</h4><p>入队说的是向队列中发送消息， 将消息加入到队列中。 和出队阻塞一样， 当一个任务向队列发送消息的话也可以设置阻塞时间。 比如任务 B 向消息队列 Q发送消息， 但是此时队列 Q 是<strong>满</strong>的， 那肯定是发送失败的。 此时任务 B 就会遇到和上面任务 A 一样的问题， 这两种情况的处理过程是类似的， 只不过一个是向队列 Q 发送消息， 一个是从队列 Q 读取消息而已。  </p>
<h3 id="消息队列操作图示"><a href="#消息队列操作图示" class="headerlink" title="消息队列操作图示"></a>消息队列操作图示</h3><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627172634936.png" alt="image-20240627172634936"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627172650644.png" alt="image-20240627172650644"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627172711148.png" alt="image-20240627172711148"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627172730019.png" alt="image-20240627172730019"></p>
<p>图中任务 B 从队列中读取消息， 并将读取到的消息值赋值给 y， 这样 y 就等于 10 了。 任务 B 从队列中读取消息完成以后可以选择清除掉这个消息或者不清除。 当选择清除这个消息的话其他任务或中断就不能获取这个消息了， 而且队列剩余大小就会加一， 变成 3。 如果不清除的话其他任务或中断也可以获取这个消息， 而队列剩余大小依旧是 2  </p>
<h3 id="消息队列控制块"><a href="#消息队列控制块" class="headerlink" title="消息队列控制块"></a>消息队列控制块</h3><p>FreeRTOS 的消息队列控制块由多个元素组成， 当消息队列被创建时， 系统会为控制块分配对应的内存空间， 用于保存消息队列的一些信息如消息的存储位置， 头指针 pcHead、 尾指针 pcTail、 消息大小 uxItemSize 以及队列长度uxLength， 以及当前队列消息个数 uxMessagesWaiting 等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ypedef <span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int8_t</span> *pcHead; (<span class="number">1</span>)</span><br><span class="line">	<span class="type">int8_t</span> *pcTail; (<span class="number">2</span>)</span><br><span class="line">	<span class="type">int8_t</span> *pcWriteTo; (<span class="number">3</span>)</span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int8_t</span> *pcReadFrom; (<span class="number">4</span>)</span><br><span class="line">	UBaseType_t uxRecursiveCallCount; (<span class="number">5</span>)</span><br><span class="line">&#125; u;</span><br><span class="line">    </span><br><span class="line">	List_t xTasksWaitingToSend; (<span class="number">6</span>)</span><br><span class="line">	List_t xTasksWaitingToReceive; (<span class="number">7</span>)</span><br><span class="line">	<span class="keyword">volatile</span> UBaseType_t uxMessagesWaiting; (<span class="number">8</span>)</span><br><span class="line">	UBaseType_t uxLength; (<span class="number">9</span>)</span><br><span class="line">	UBaseType_t uxItemSize; (<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int8_t</span> cRxLock; (<span class="number">11</span>)</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int8_t</span> cTxLock; (<span class="number">12</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp;( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span></span><br><span class="line">	<span class="type">uint8_t</span> ucStaticallyAllocated;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span> *<span class="title">pxQueueSetContainer</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">	UBaseType_t uxQueueNumber;</span><br><span class="line">	<span class="type">uint8_t</span> ucQueueType;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; xQUEUE;</span><br><span class="line"><span class="keyword">typedef</span> xQUEUE Queue_t;</span><br></pre></td></tr></table></figure>

<p>代码(1)： pcHead 指向队列消息<strong>存储区起始位置</strong>， 即第一个消息空间。<br>代码(2)： pcTail 指向队列消息<strong>存储区结束位置</strong>地址。<br>代码(3)： pcWriteTo 指向队列消息存储区<strong>下一个可用消息</strong>空间。<br>代码(4)： pcReadFrom 与 uxRecursiveCallCount 是一<strong>对互斥变量</strong>， 使用联合体用来确保两个互斥的结构体成员不会同时出现。 当结构体用于队列时，pcReadFrom 指向出队消息空间的最后一个， 见文知义， 就是<strong>读取 消息 时候是从pcReadFrom 指向的空间读取消息内容</strong>。<br>代码(5)： 当结构体用于互斥量时， uxRecursiveCallCount 用于计数， <strong>记录递归互斥量被“调用” 的次数</strong>。<br>代码(6)： xTasksWaitingToSend 是一个<strong>发送消息阻塞列表</strong>， 用于<strong>保存阻塞在此队列的任务</strong>， 任务按照优先级进行排序</p>
<blockquote>
<p>阻塞：由于队列已满， 想要发送消息的任务无法发送消息</p>
</blockquote>
<p>代码(7)： xTasksWaitingToReceive 是一个<strong>获取消息阻塞列表</strong>， 用于<strong>保存阻塞在此队列的任务</strong>， 任务按照优先级进行排序，</p>
<blockquote>
<p>阻塞：队列是空的， 想要获取消息的任务无法获取到消息</p>
</blockquote>
<p>代码(8)： uxMessagesWaiting 用于记录<strong>当前消息队列的消息个数</strong>， 如果消息队列被用于信号量的时候， 这个值就表示有效信号量个数。<br>代码(9)： uxLength 表示<strong>队列的长度</strong>， 也就是能存放多少消息。<br>代码(10)： uxItemSize 表示<strong>单个消息的大小</strong>。<br>代码(11)： 队列上锁后， 储存从队列收到的列表项数目， 也就是出队的数量，如果队列没有上锁， 设置为 queueUNLOCKED。  </p>
<p>代码(12)： 队列上锁后， 储存发送到队列的列表项数目， 也就是入队的数量，如果队列没有上锁， 设置为 queueUNLOCKED。<br>这两个成员变量为 queueUNLOCKED 时， 表示队列未上锁； 当这两个成员变量为 queueLOCKED_UNMODIFIED 时， 表示队列上锁。  </p>
<h2 id="常用API函数"><a href="#常用API函数" class="headerlink" title="常用API函数"></a>常用API函数</h2><h3 id="消息队列创建函数"><a href="#消息队列创建函数" class="headerlink" title="消息队列创建函数"></a>消息队列创建函数</h3><p><strong>xQueueCreate</strong>()用于创建一个新的队列并返回可用于访问这个队列的队列句柄。</p>
<p> 队列句柄其实就是一个指向队列数据结构类型的指针。队列就是一个数据结构， 用于任务间的数据的传递。 每创建一个新的队列都<br>需要为其分配 RAM， 一部分用于存储队列的状态， 剩下的作为队列消息的存储区域。 </p>
<p>使用 xQueueCreate()创建队列时， 使用的是<strong>动态内存分配</strong>， 所以要想使用该函数必须在 FreeRTOSConfig.h 中把 configSUPPORT_DYNAMIC_ALLOCATION定义为 1 来使能， 这是个用于使能动态内存分配的宏， 通常情况下， 在 FreeRTOS<br>中， 凡是创建任务， 队列， 信号量和互斥量等内核对象都需要使用动态内存分配</p>
<p> 如果想使用静态内存， 则可以使用 <strong>xQueueCreateStatic</strong>() 函数来创建一个队列。 使用静态创建消息队列函数创建队列时需要的形参更多， 需要的内存由编译的时候预先分配好， 一般很少使用这种方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627183300024.png" alt="image-20240627183300024"></p>
<p>xQueueGenericCreate()  底层创建函数</p>
<p>prvInitialiseNewQueue()  初始化</p>
<p>xQueueGenericReset（）重置消息队列</p>
<p>创建完成的消息队列示意图  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240627191937299.png" alt="image-20240627191937299"></p>
<p>在创建消息队列的时候， 是需要用户自己<strong>定义消息队列的句柄</strong>的， 但是注意了， 定义了队列的句柄并不等于创建了队列， 创建队列必须是<strong>调用消息队列创建函数</strong>进行创建（可以是静态也可以是动态创建），创建完成会返回消息队列的句柄， 用户通过句柄就可使用消息队列进行发送与读取消息队列的操作， 如果返回的是NULL 则表示创建失败。  </p>
<h3 id="消息队列静态创建函数"><a href="#消息队列静态创建函数" class="headerlink" title="消息队列静态创建函数"></a>消息队列静态创建函数</h3><p>xQueueCreateStatic()用于创建一个新的队列并返回可用于访问这个队列的队列句柄。 队列句柄其实就是一个指向队列数据结构类型的指针。  </p>
<p>队列就是一个数据结构， 用于任务间的数据的传递。 每创建一个新的队列都需要为其分配 RAM， 一部分用于存储队列的状态， 剩下的作为队列的存储区。 使用 xQueueCreateStatic()创建队列时， 使用的是静态内存分配， 所以要想使用该函数必须在 FreeRTOSConfig.h 中把 configSUPPORT_STATIC_ALLOCATION 定义为 1 来使能。 这是个用于使能静态内存分配的宏， 需要的内存在程序编译的时候分配好， 由用户自己定义  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628162009349.png" alt="image-20240628162009349"></p>
<h3 id="消息队列删除函数"><a href="#消息队列删除函数" class="headerlink" title="消息队列删除函数"></a>消息队列删除函数</h3><p>队列删除函数是根据消息队列句柄直接删除的， 删除之后这个消息队列的所有信息都会被系统回收清空， 而且不能再次使用这个消息队列了， 但是需要注意的是， 如果某个消息队列没有被创建， 那也是无法被删除的。</p>
<p>xQueue 是 vQueueDelete()函数的形参， 是消息队列句柄， 表示的是要删除哪个想队列  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vQueueDelete</span><span class="params">( QueueHandle_t xQueue )</span></span><br></pre></td></tr></table></figure>

<h3 id="向消息队列发送消息函数"><a href="#向消息队列发送消息函数" class="headerlink" title="向消息队列发送消息函数"></a>向消息队列发送消息函数</h3><p><strong>任务</strong>或者<strong>中断服务程序</strong>都可以给消息队列发送消息， 当发送消息时， 如果队列未满或者允许覆盖入队， FreeRTOS 会将消息拷贝到消息队列队尾， <strong>否则， 会根据用户指定的阻塞超时时间进行阻塞</strong>， 在这段时间中， 如果队列一直不允许入队， 该任务将保持阻塞状态以等待队列允许入队。 <strong>当其它任务从其等待的队列中读取入了数据（队列未满） ， 该任务将自动由阻塞态转为就绪态</strong>。 当任务等待的时间超过了指定的阻塞时间， 即使队列中还不允许入队， 任务也会自动从阻塞态转移为就绪态， 此时发送消息的任务或者中断程序会收到一个错误码errQUEUE_FULL。</p>
<p>发送紧急消息的过程与发送消息几乎一样， 唯一的不同是， <strong>当发送紧急消息时， 发送的位置是消息队列队头而非队尾</strong>， 这样， 接收者就能够优先接收到紧急消息， 从而及时进行消息处理。</p>
<p>其实消息队列发送函数有好几个， 都是使用宏定义进行展开的， 有些只能在任务调用， 有些只能在中断中调用， 具体见下面讲解。  </p>
<p>（1）向队首发送消息（兼容）</p>
<p>（2）向队首发送消息的中断版本（兼容）</p>
<p>（3）向队尾发送消息</p>
<p>（4）向队尾发送消息的中断版本</p>
<h4 id="xQueueSend-与-xQueueSendToBack"><a href="#xQueueSend-与-xQueueSendToBack" class="headerlink" title="xQueueSend()与 xQueueSendToBack()"></a>xQueueSend()与 xQueueSendToBack()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xQueueSend( xQueue, pvItemToQueue, xTicksToWait )</span></span><br><span class="line">	xQueueGenericSend( ( xQueue ), ( pvItemToQueue ),( xTicksToWait ), queueSEND_TO_BACK )</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait )</span></span><br><span class="line">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ),( xTicksToWait ), queueSEND_TO_BACK )</span><br></pre></td></tr></table></figure>

<p>xQueueSend()是一个宏， 宏展开是调用函数 xQueueGenericSend()， 这个函数在后面会详细讲解其实现过程。 该宏是为了<strong>向后兼容</strong>没有包含xQueueSendToFront() 和 xQueueSendToBack() 这两个宏的 FreeRTOS 版本。</p>
<p><strong>xQueueSend()等同于 xQueueSendToBack()。</strong></p>
<p>xQueueSend()用于<strong>向队列尾部发送一个队列消息</strong>。 消息<strong>以拷贝的形式入队</strong>，而不是以引用的形式。 该函数<strong>绝对不能在中断服务程序</strong>里面被调用， 中断中必须使用带有中断保护功能的 xQueueSendFromISR()来代替。 </p>
<p>xQueueSend()函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628163648117.png" alt="image-20240628163648117"></p>
<h4 id="xQueueSendFromISR-与-xQueueSendToBackFromISR"><a href="#xQueueSendFromISR-与-xQueueSendToBackFromISR" class="headerlink" title="xQueueSendFromISR()与 xQueueSendToBackFromISR()"></a>xQueueSendFromISR()与 xQueueSendToBackFromISR()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xQueueSendToBackFromISR( xQueue, pvItemToQueue,pxHigherPriorityTaskWoken )</span></span><br><span class="line">	xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ),( pxHigherPriorityTaskWoken ),queueSEND_TO_BACK )</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xQueueSendFromISR( xQueue, pvItemToQueue,pxHigherPriorityTaskWoken )</span></span><br><span class="line">	xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ),( pxHigherPriorityTaskWoken ),queueSEND_TO_BACK )</span><br></pre></td></tr></table></figure>

<p>xQueueSendFromISR()是一个宏， 宏展开是调用函数xQueueGenericSendFromISR()。 <strong>该宏是 xQueueSend()的中断保护版本</strong>， 用于在中断服务程序中向队列尾部发送一个队列消息， 等价于xQueueSendToBackFromISR()。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628164007948.png" alt="image-20240628164007948"></p>
<h4 id="xQueueSendToFront"><a href="#xQueueSendToFront" class="headerlink" title="xQueueSendToFront()"></a>xQueueSendToFront()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait )</span></span><br><span class="line">xQueueGenericSend( ( xQueue ), ( pvItemToQueue ),( xTicksToWait ), queueSEND_TO_FRONT )</span><br></pre></td></tr></table></figure>

<p>xQueueSendToFron()是一个宏， 宏展开也是调用函数 xQueueGenericSend()。</p>
<p>xQueueSendToFront()用于<strong>向队列队首发送一个消</strong>息。 消息以<strong>拷贝的形式入队</strong>，而不是以引用的形式。 该函数绝<strong>不能在中断服务程序</strong>里面被调用， 而是必须使用带有中断保护功能的 xQueueSendToFrontFromISR ()来代替。 xQueueSendToFron()函数的使用方式与 xQueueSend()函数一致  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628164504270.png" alt="image-20240628164504270"></p>
<h4 id="xQueueSendToFrontFromISR"><a href="#xQueueSendToFrontFromISR" class="headerlink" title="xQueueSendToFrontFromISR()"></a>xQueueSendToFrontFromISR()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xQueueSendToFrontFromISR( xQueue, pvItemToQueue,pxHigherPriorityTaskWoken )</span></span><br><span class="line">	xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ),( pxHigherPriorityTaskWoken ),queueSEND_TO_FRONT )</span><br></pre></td></tr></table></figure>

<p>xQueueSendToFrontFromISR()是一个宏， 宏展开是调用函数xQueueGenericSendFromISR()。 该宏是 xQueueSendToFront()的<strong>中断保护版本</strong>，用于在中断服务程序中向消息队列队首发送一个消息。 </p>
<p>xQueueSendToFromISR()的 函数使用方式与 xQueueSendFromISR()函数一致 </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628165027686.png" alt="image-20240628165027686"> </p>
<h5 id="xQueueGenericSend"><a href="#xQueueGenericSend" class="headerlink" title="xQueueGenericSend()"></a>xQueueGenericSend()</h5><p>上面看到的那些在任务中发送消息的函数都是 xQueueGenericSend()展开的宏定义， 真正起作用的就是 xQueueGenericSend()函数， 根据指定的参数不一样， 发送消息的结果就不一样</p>
<p>具体实现 手册P183</p>
<h5 id="xQueueGenericSendFromISR"><a href="#xQueueGenericSendFromISR" class="headerlink" title="xQueueGenericSendFromISR()"></a>xQueueGenericSendFromISR()</h5><p>既然有任务中发送消息的函数， 当然也需要有在<strong>中断中发送消息函数</strong>， 其实这个函数跟 xQueueGenericSend() 函数很像， 只不过是 执行的上下文环境是不一样的， xQueueGenericSendFromISR()函数只能用于中断中执行， 是不带阻塞机制的  </p>
<p>具体实现 手册P186</p>
<h3 id="从消息队列取消消息函数"><a href="#从消息队列取消消息函数" class="headerlink" title="从消息队列取消消息函数"></a>从消息队列取消消息函数</h3><p>（1）取消息 并删除队列中的取出的消息  和  取消息 不删除队列中的消息</p>
<p>（2）中断保护版本</p>
<h4 id="xQueueReceive-与-xQueuePeek"><a href="#xQueueReceive-与-xQueuePeek" class="headerlink" title="xQueueReceive()与 xQueuePeek()"></a>xQueueReceive()与 xQueuePeek()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xQueueReceive( xQueue, pvBuffer, xTicksToWait )</span></span><br><span class="line">	xQueueGenericReceive( ( xQueue ), ( pvBuffer ),( xTicksToWait ), pdFALSE )</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xQueuePeek( xQueue, pvBuffer, xTicksToWait )</span></span><br><span class="line">	xQueueGenericReceive( ( xQueue ), ( pvBuffer ),( xTicksToWait ), pdTRUE )</span><br></pre></td></tr></table></figure>

<p>xQueueReceive() 是一个宏， 宏展开是调用函数 xQueueGenericReceive()。</p>
<p>xQueueReceive()用于从<strong>一个队列中接收消息并把消息从队列中删除</strong>。 接收的消息是以<strong>拷贝的形式进行</strong>的， 所以我们必须提供一个足够大空间的缓冲区。 具体能够拷贝多少数据到缓冲区， 这个在队列创建的时候已经设定。 该函数绝<strong>不能在中断服务程序里面被调用</strong>， 而是必须使用<strong>带有中断保护功能的xQueueReceiveFromISR ()来代替</strong>。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628165551469.png" alt="image-20240628165551469"></p>
<p>如果<strong>不想删除消息的话</strong>， 就调用 xQueuePeek()函数  </p>
<h4 id="xQueueReceiveFromISR-与-xQueuePeekFromISR"><a href="#xQueueReceiveFromISR-与-xQueuePeekFromISR" class="headerlink" title="xQueueReceiveFromISR()与 xQueuePeekFromISR()"></a>xQueueReceiveFromISR()与 xQueuePeekFromISR()</h4><p>xQueueReceiveFromISR()是 xQueueReceive ()的中断版本， 用于在中断服务程序中接收一个队列消息并把消息从队列中删除； </p>
<p>xQueuePeekFromISR()是xQueuePeek()的中断版本， 用于在中断中从一个队列中接收消息， 但并不会把消息从队列中移除。</p>
<p>说白了这两个函数只能用于中断， 是不带有阻塞机制的， 并且是在中断中可以安全调用.</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628165941361.png" alt="image-20240628165941361" style="zoom:80%;" />



<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628165955381.png" alt="image-20240628165955381" style="zoom:80%;" />

<h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><p>在使用 FreeRTOS 提供的消息队列函数的时候， 需要了解以下几点：<br>1.使用 xQueueSend()、 xQueueSendFromISR()、 xQueueReceive()等这些函数之前应先创建需消息队列， 并根据队列句柄进行操作。</p>
<p>2.队列读取采用的是先进先出（FIFO） 模式， 会先读取先存储在队列中的数据。 当然也 FreeRTOS 也支持后进先出（LIFO） 模式， 那么读取的时候就会读取到后进队列的数据。</p>
<p>3.在获取队列中的消息时候， 我们必须要定义一个存储读取数据的地方， 并且该数据区域大小不小于消息大小， 否则， 很可能引发地址非法的错误。</p>
<p>4.无论是发送或者是接收消息都是以拷贝的方式进行， 如果消息过于庞大，可以将消息的地址作为消息进行发送、 接收。</p>
<p>5.队列是具有自己独立权限的内核对象， 并不属于任何任务。 所有任务都可以向同一队列写入和读出。 一个队列由多任务或中断写入是经常的事， 但由多个任务读出倒是用的比较少。  </p>
<h2 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t Test_Queue =<span class="literal">NULL</span>;    <span class="comment">//消息队列的句柄  通过xQueueCreate()返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  QUEUE_LEN    4   <span class="comment">/* 队列的长度，最大可包含多少个消息 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  QUEUE_SIZE   4   <span class="comment">/* 队列中每个消息大小（字节） */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();           <span class="comment">//进入临界区</span></span><br><span class="line">     </span><br><span class="line">	<span class="comment">/* 创建Test_Queue */</span>  	<span class="comment">//返回句柄</span></span><br><span class="line">	Test_Queue = xQueueCreate((UBaseType_t ) QUEUE_LEN,<span class="comment">/* 消息队列的长度 */</span></span><br><span class="line">                            (UBaseType_t ) QUEUE_SIZE);<span class="comment">/* 消息的大小 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建接收任务</span></span><br><span class="line">    xTaskCreate((TaskFunction_t )receive_task,     </span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;receive_task&quot;</span>,   </span><br><span class="line">                (<span class="type">uint16_t</span>       )RECEIVE_STK_SIZE, </span><br><span class="line">                (<span class="type">void</span>*          )<span class="literal">NULL</span>,</span><br><span class="line">                (UBaseType_t    )RECEIVE_TASK_PRIO,</span><br><span class="line">                (TaskHandle_t*  )&amp;ReceiveTask_Handler);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建发送任务</span></span><br><span class="line">    xTaskCreate((TaskFunction_t )send_task,     </span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;send_task&quot;</span>,   </span><br><span class="line">                (<span class="type">uint16_t</span>       )SEND_STK_SIZE, </span><br><span class="line">                (<span class="type">void</span>*          )<span class="literal">NULL</span>,</span><br><span class="line">                (UBaseType_t    )SEND_TASK_PRIO,</span><br><span class="line">                (TaskHandle_t*  )&amp;SendTask_Handler);</span><br><span class="line">				</span><br><span class="line">    vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">    taskEXIT_CRITICAL();            <span class="comment">//退出临界区</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//接收任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">receive_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdTRUE;<span class="comment">/* 定义一个创建信息返回值，默认为pdTRUE */</span></span><br><span class="line">	<span class="type">uint32_t</span> r_queue;	<span class="comment">/* 定义一个接收消息的变量 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*如果接收 成功，则xQueueReceive 返回pdTRUE*/</span></span><br><span class="line">        xReturn = xQueueReceive( Test_Queue,    <span class="comment">/* 消息队列的句柄 */</span></span><br><span class="line">								&amp;r_queue,      <span class="comment">/* 发送的消息内容 */</span></span><br><span class="line">								portMAX_DELAY); <span class="comment">/* 等待时间 一直等 */</span></span><br><span class="line">		<span class="keyword">if</span>(xReturn == pdTRUE)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;本次接收到的数据是%d\n\n&quot;</span>,r_queue);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;数据接收出错,错误代码0x%lx\n&quot;</span>,xReturn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdPASS;<span class="comment">/* 定义一个创建信息返回值，默认为pdPASS */</span></span><br><span class="line">	<span class="type">uint32_t</span> send_data1 = <span class="number">1</span>;</span><br><span class="line">	<span class="type">uint32_t</span> send_data2 = <span class="number">2</span>;</span><br><span class="line">	u8 key=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY_UP_PRESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;发送消息send_data1！\n&quot;</span>);</span><br><span class="line">            <span class="comment">/*如果发送 成功，则xQueueSend 返回pdPASS*/</span></span><br><span class="line">			xReturn = xQueueSend( Test_Queue, <span class="comment">/* 消息队列的句柄 */</span></span><br><span class="line">								&amp;send_data1,<span class="comment">/* 发送的消息内容 */</span></span><br><span class="line">								<span class="number">0</span> );        <span class="comment">/* 等待时间 0 */</span></span><br><span class="line">			<span class="keyword">if</span>(xReturn == pdPASS)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;消息send_data1发送成功!\n\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(key==KEY1_PRESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;发送消息send_data2！\n&quot;</span>);</span><br><span class="line">			xReturn = xQueueSend( Test_Queue, <span class="comment">/* 消息队列的句柄 */</span></span><br><span class="line">								&amp;send_data2,<span class="comment">/* 发送的消息内容 */</span></span><br><span class="line">								<span class="number">0</span> );        <span class="comment">/* 等待时间 0 */</span></span><br><span class="line">			<span class="keyword">if</span>(pdPASS == xReturn)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;消息send_data2发送成功!\n\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		vTaskDelay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>操作系统保证多次运行进程后，都能获得相同的结果。</p>
<p>状态机</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204047048.png" alt="image-20240628204047048"></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204121336.png" alt="image-20240628204121336"></p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204144867.png" alt="image-20240628204144867" style="zoom:50%;" />

<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204212134.png" alt="image-20240628204212134"></p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628204230037.png" alt="image-20240628204230037" style="zoom:80%;" />

<h2 id="信号量简介"><a href="#信号量简介" class="headerlink" title="信号量简介"></a>信号量简介</h2><p>信号量是操作系统中重要的一部分， 信号量一般用来进行资源管理和任务同步， FreeRTOS 中信号量又分为二值信号量、 计数型信号量、 互斥信号量和递归互斥信号量。 不同的信号量其应用场景不同， 但有些应用场景是可以互换着使用。  </p>
<h3 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h3><p>二值信号量既可以用于<strong>临界资源访问</strong>也可以<strong>用于同步</strong>功能。</p>
<blockquote>
<p>临界资源：一次只能被一个进程使用的资源 ，譬如 打印机，键盘等</p>
<p>在微观上，操作系统执行程序具有并发性，如果没有信号量的限制，就会出现若干个进程 宏观上同时使用打印机的情况</p>
<p>具体表现就是  上一秒打印数学习题，下一秒打印英语习题</p>
</blockquote>
<p>二值信号量和互斥信号量（以下使用互斥量表示互斥信号量） 非常相似， 但是有一些细微差别： </p>
<p>互斥量有优先级继承机制， 二值信号量则没有这个机制。 这使得二值信号量更偏向应用于<strong>同步功能</strong>（任务与任务间的同步或任务和中断间同步） ，而互斥量更偏向应用于<strong>临界资源的访问</strong>。</p>
<blockquote>
<p>同步一般指主动请求并等待IO操作完成的方式。</p>
<p>异步则指主动请求数据后便可以继续处理其它任务，随后等待IO操作完毕的通知。</p>
<p>同步和异步最大的区别就在于：同步需要等待，异步不需要等待。</p>
</blockquote>
<p> <strong>用作同步时</strong>， 信号量在创建后应被置为空， 任务 1 获取信号量而进入阻塞，任务 2 在某种条件发生后， 释放信号量， 于是任务 1 获得信号量得以进入就绪态， 如果任务 1 的优先级是最高的， 那么就会立即切换任务， 从而达到了两个任务间的同步。 同样的，在中断服务函数中释放信号量， 任务 1 也会得到信号量， 从而达到任务与中断间的同步。还记得我们经常说的中断要快进快出吗， 在裸机开发中我们经常是在中断中做一个标记， 然后在退出的时候进行轮询处理， 这个就是类似我们使用信号量进行同步的， 当标记发生了， 我们再做其他事情。 在 FreeRTOS 中我们用信号量用于同步， 任务与任务的同步， 中断与任务的同步， 可以大大提高效率。  </p>
<p>可以将二值信号量看作只有一个消息的队列， 因此这个队列只能为空或满（因此称为二值） ， 我们在运用的时候只需要知道队列中是否有消息即可， 而无需关注消息是什么。  </p>
<h3 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h3><p>二进制信号量可以被认为是长度为 1 的队列， 而计数信号量则可以被认为长度大于 1 的队列，</p>
<p> 信号量使用者依然不必关心存储在队列中的消息， 只需关心队列是否有消息即可。</p>
<p>顾名思义， 计数信号量肯定是用于计数的， 在实际的使用中， 我们常将计数信号量用于<strong>事件计数与资源管理</strong>。 每当某个事件发生时， 任务或者中断将释放一个信号量（信号量计数值加 1） ， 当处理事件时（一般在任务中处理） ， 处理任务会取走该信号量（信号量计数值减 1） ， 信号量的计数值则表示还有多少个事件没被处理。</p>
<p> 此外， 系统还有很多资源， 我们也可以使用计数信号量进行资源管理， 信号量的计数值<strong>表示系统中可用的资源数目</strong>， 任务必须先获取到信号量才能获取资源访问权， 当信号量的计数值为零时表示系统没有可用的资源， 但是要注意， 在使用完资源的时候必须归还信号量， 否则当计数值为 0 的时候任务就无法访问该资源了。</p>
<p>计数型信号量允许多个任务对其进行操作， 但限制了任务的数量。 </p>
<p>比如有一个停车场， 里面只有 100 个车位， 那么能停的车只有 100 辆， 也相当于我们的信号量有 100 个， 假如一开始停车场的车位还有 100 个， 那么每进去一辆车就要消耗一个停车位， 车位的数量就要减一， 对应的， 我们的信号量在使用之后也需要减一， 当停车场停满了 100 辆车的时候， 此时的停车位为 0， 再来的车就不能停进去了， 否则将造成事故， 也相当于我们的信号量为 0， 后面的任务对这个停车场资源的访问也无法进行， 当有车从停车场离开的时候， 车位又空余出来了， 那么， 后面的车就能停进去了， 我们信号量的操作也是一样的， 当我们释放了这个资源， 后面的任务才能对这个资源进行访问。</p>
<blockquote>
<p>  PV操作</p>
</blockquote>
<h3 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h3><p>互斥信号量其实是特殊的二值信号量， 由于其特有的优先级继承机制从而使它更适用于<strong>简单互锁</strong>， 也就是保护临界资源（什么是优先级继承在后续详细讲解） 。</p>
<p>用作互斥时， 信号量创建后可用信号量个数应该是满的， 任务在需要使用临界资源时， （临界资源是指任何时刻只能被一个任务访问的资源） ， 先获取互斥信号量， 使其变空， 这样其他任务需要使用临界资源时就会因为无法获取信号量而进入阻塞， 从而保证了临界资源的安全。</p>
<blockquote>
<p>就是PV操作里面的  先V在P</p>
</blockquote>
<p>在操作系统中， 我们使用信号量的很多时候是为了给临界资源建立一个标志， 信号量表示了该临界资源被占用情况。 这样， 当一个任务在访问临界资源的时候， 就会先对这个资源信息进行查询， 从而在了解资源被占用的情况之后， 再做处理， 从而使得临界资源得到有效的保护。   </p>
<h3 id="递归信号量"><a href="#递归信号量" class="headerlink" title="递归信号量"></a>递归信号量</h3><p>递归信号量， 见文知义， 递归嘛， 就是可以重复获取调用的， 本来按照信号量的特性， 每获取一次可用信号量个数就会减少一个， 但是递归则不然， <strong>对于已经获取递归互斥量的任务可以重复获取该递归互斥量</strong>， 该任务拥有递归信号量的所有权。 任务成功获取几次递归互斥量， 就要返还几次， 在此之前递归互斥量都处于无效状态， 其他任务无法获取， 只有持有递归信号量的任务才能获取与释放。  </p>
<blockquote>
<p>好像是，对于某个任务 ，可以一直重复使用此信号量，而其他任务不能使用</p>
</blockquote>
<h3 id="二值信号量应用场景"><a href="#二值信号量应用场景" class="headerlink" title="二值信号量应用场景"></a>二值信号量应用场景</h3><p>嵌入式操作系统中二值信号量是<strong>任务间、 任务与中断间同步</strong>的重要手段，信号量使用最多的一般都是二值信号量与互斥信号量 。</p>
<blockquote>
<p>主要用于同步 </p>
</blockquote>
<p>为什么叫二值信号量呢？ 因为信号量资源被获取了， 信号量值就是 0， 信号量资源被释放， 信号量值就是 1， 把这种只有 0 和 1 两种情况的信号量称之为二值信号量。</p>
<p>在多任务系统中， 我们经常会使用这个二值信号量， 比如， 某个任务需要等待一个标记， 那么任务可以在轮询中查询这个标记有没有被置位， 但是这样子做，就会很消耗 CPU 资源并且妨碍其它任务执行， 更好的做法是任务的大部分时间处于阻塞状态（允许其它任务执行） ， 直到某些事件发生该任务才被唤醒去执行。</p>
<p>当任务取信号量时， 因为此时尚未发生特定事件，信号量为空， 任务会进入阻塞状态； 当事件的条件满足后， 任务&#x2F;中断便会释放信号量， 告知任务这个事件发生了， 任务取得信号量便被唤醒去执行对应的操作， 任务执行完毕并不需要归还信号量， 这样子的 CPU 的效率可以大大提高， 而且实时响应也是最快的。</p>
<p>再比如某个任务使用信号量在等中断的标记的发生， 在这之前任务已经进入了阻塞态， 在等待着中断的发生， 当在中断发生之后， 释放一个信号量， 也就是我们常说的标记， 当它退出中断之后， 操作系统会进行任务的调度， 如果这个任务能够运行， 系统就会把等待这个任务运行起来， 这样子就大大提高了我们的效率。</p>
<p><strong>二值信号量在任务与任务中同步的应用场景</strong>： 假设我们有一个温湿度的传感器， 假设是 1s 采集一次数据， 那么我们让它在液晶屏中显示数据出来， 这个周期也是要 1s 一次的， 如果液晶屏刷新的周期是 100ms 更新一次， 那么此时的温湿度的数据还没更新， 液晶屏根本无需刷新， 只需要在 1s 后温湿度数据更新的时候刷新即可， 否则 CPU 就是白白做了多次的无效数据更新， CPU 的资源就被刷新数据这个任务占用了大半， 造成 CPU 资源浪费， 如果液晶屏刷新的周期是 10s 更新一次， 那么温湿度的数据都变化了 10 次， 液晶屏才来更新数据，那拿这个产品有啥用， 根本就是不准确的， 所以， 还是需要同步协调工作， 在温湿度采集完毕之后， 进行液晶屏数据的刷新， 这样子， 才是最准确的， 并且不会浪费 CPU 的资源。</p>
<p>同理， 二值信号量在任务与中断同步的应用场景： 我们在串口接收中， 我们不知道啥时候有数据发送过来， 有一个任务是做接收这些数据处理， 总不能在任务中每时每刻都在任务查询有没有数据到来， 那样会浪费 CPU 资源， 所以在这种情况下使用二值信号量是很好的办法， 当没有数据到来的时候， 任务就进入阻塞态， 不参与任务的调度， 等到数据到来了， 释放一个二值信号量， 任务就立即从阻塞态中解除， 进入就绪态， 然后运行的时候处理数据， 这样子系统的资源就会很好的被利用起来。</p>
<blockquote>
<p>bit sign &#x3D; 0;</p>
<p>if ( sign)</p>
<p>{</p>
<p>​	就绪态 ，如果处理机空闲 则 执行任务</p>
<p>}  </p>
<p>else</p>
<p>{</p>
<p>​	进入阻塞态</p>
<p>}</p>
</blockquote>
<h3 id="二值信号量运作机制"><a href="#二值信号量运作机制" class="headerlink" title="二值信号量运作机制"></a>二值信号量运作机制</h3><p>创建信号量时， 系统会为创建的信号量对象分配内存， 并把可用信号量初始 化为用户自定义的个数， 二值信号量的最大可用信号量个数为 1。</p>
<p>二值信号量获取， 任何任务都可以从创建的二值信号量资源中获取一个二值信号量， 获取成功则返回正确， 否则任务会根据用户指定的阻塞超时时间来等待其它任务&#x2F;中断释放信号量。 在等待这段时间， 系统将任务变成阻塞态， 任务将被挂到该信号量的阻塞等待列表中。</p>
<p>在二值信号量无效的时候， 假如此时有任务获取该信号量的话， 那么任务将进入阻塞状态。  </p>
<p>假如某个时间中断&#x2F;任务释放了信号量， 那么， 由于获取无效信号量而进入阻塞态的任务将获得信号量并且恢复为就绪态。</p>
<h3 id="计数信号量运作机制"><a href="#计数信号量运作机制" class="headerlink" title="计数信号量运作机制"></a>计数信号量运作机制</h3><p>计数信号量可以用于资源管理， 允许多个任务获取信号量访问共享资源， 但会<strong>限制任务的最大数目</strong>。 访问的任务数达到可支持的最大数目时， 会阻塞其他试图获取该信号量的任务， <strong>直到有任务释放了信号量</strong>。 这就是计数型信号量的运作机制，</p>
<p> 虽然计数信号量允许多个任务访问同一个资源， 但是也有限定， 比如某个资源限定只能有 3 个任务访问， 那么第 4 个任务访问的时候， 会因为获取不到信号量而进入阻塞， 等到有任务<strong>（比如任务 1） 释放掉该资源的时候， 第 4 个任务才能获取到信号量从而进行资源的访问</strong></p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628211632904.png" alt="image-20240628211632904" style="zoom:80%;" />



<h3 id="信号量控制块"><a href="#信号量控制块" class="headerlink" title="信号量控制块"></a>信号量控制块</h3><p>信号量 API 函数实际上都是宏， 它使用现有的队列机制， 这些宏定义在semphr.h 文件中， 如果使用信号量或者互斥量， 需要包含 semphr.h 头文件。所以 FreeRTOS 的<strong>信号量控制块结构体</strong>与<strong>消息队列结构体</strong>是一模一样的， 只不过结构体中某些成员变量代表的含义不一样而已.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int8_t</span> *pcHead;</span><br><span class="line">	<span class="type">int8_t</span> *pcTail;</span><br><span class="line">	<span class="type">int8_t</span> *pcWriteTo;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="type">int8_t</span> *pcReadFrom;</span><br><span class="line">		UBaseType_t uxRecursiveCallCount;</span><br><span class="line">	&#125; u;</span><br><span class="line">	List_t xTasksWaitingToSend;</span><br><span class="line">	List_t xTasksWaitingToReceive;</span><br><span class="line">	<span class="keyword">volatile</span> UBaseType_t uxMessagesWaiting; (<span class="number">1</span>)</span><br><span class="line">	UBaseType_t uxLength; 					(<span class="number">2</span>)</span><br><span class="line">	UBaseType_t uxItemSize; 				(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int8_t</span> cRxLock;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int8_t</span> cTxLock;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp;( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span></span><br><span class="line">	<span class="type">uint8_t</span> ucStaticallyAllocated;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span> *<span class="title">pxQueueSetContainer</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">	UBaseType_t uxQueueNumber;</span><br><span class="line">	<span class="type">uint8_t</span> ucQueueType;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; xQUEUE;</span><br><span class="line"><span class="keyword">typedef</span> xQUEUE Queue_t;</span><br></pre></td></tr></table></figure>

<p>代码(1)： 如果控制块结构体是用于消息队列： uxMessagesWaiting 用来记录当前消息队列的消息个数； 如果控制块结构体被用于信号量的时候， 这个值就表示有效信号量个数， 有以下两种情况：</p>
<p>● 如果信号量是二值信号量、 互斥信号量， 这个值是 1 则表示有可用信号量， 如果是 0 则表示没有可用信号量。</p>
<p>● 如果是计数信号量， 这个值表示可用的信号量个数， 在创建计数信号量的时候会被初始化一个可用信号量个数 uxInitialCount， 最大不允许超过创建信号量的初始值 uxMaxCount。</p>
<p>代码(2)： 如果控制块结构体是用于消息队列： uxLength 表示队列的长度，也就是能存放多少消息； 如果控制块结构体被用于信号量的时候， uxLength 表示最大的信号量可用个数， 会有以下两种情况：</p>
<p>● 如果信号量是二值信号量、 互斥信号量， uxLength 最大为 1， 因为信号量要么是有效的， 要么是无效的。</p>
<p>● 如果是计数信号量， 这个值表示最大的信号量个数， 在创建计数信号量的时候将由用户指定这个值 uxMaxCount。</p>
<p>代码(3)： 如果控制块结构体是用于消息队列： uxItemSize 表示单个消息的大小； 如果控制块结构体被用于信号量的时候， 则无需存储空间， 为 0 即可。  </p>
<h2 id="常用信号量API函数"><a href="#常用信号量API函数" class="headerlink" title="常用信号量API函数"></a>常用信号量API函数</h2><h3 id="创建信号量函数"><a href="#创建信号量函数" class="headerlink" title="创建信号量函数"></a>创建信号量函数</h3><h4 id="创建二值信号量-xSemaphoreCreateBinary"><a href="#创建二值信号量-xSemaphoreCreateBinary" class="headerlink" title="创建二值信号量  xSemaphoreCreateBinary()"></a>创建二值信号量  xSemaphoreCreateBinary()</h4><p>xSemaphoreCreateBinary()用于创建一个二值信号量， 并返回一个句柄 ,要想使用该函数必须在 FreeRTOSConfig.h中把宏 configSUPPORT_DYNAMIC_ALLOCATION 定义为 1， 即开启动态内存分配。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( configSUPPORT_DYNAMIC_ALLOCATION == <span class="number">1</span> )</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xSemaphoreCreateBinary()</span></span><br><span class="line">	xQueueGenericCreate( ( UBaseType_t ) <span class="number">1</span>, 					(<span class="number">1</span>)</span><br><span class="line">							semSEMAPHORE_QUEUE_ITEM_LENGTH, 	(<span class="number">2</span>)</span><br><span class="line">							queueQUEUE_TYPE_BINARY_SEMAPHORE ) 	(<span class="number">3</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>从这个函数原型我们就可以知道二值信号量的创建实际使用的函数<strong>就是xQueueGenericCreate()函数，就是消息队列的创建使用的函数，</strong> 但是参数不一样 </p>
<p>代码(1)： uxQueueLength 为 1 表示创建的队列长度为 1， 其实用作信号量就表示信号量的最大可用个数， 从前面的知识点我们就知道， 二值信号量的非空即满， 长度为 1 不正是这样子的表示吗。</p>
<p>代码(2)： semSEMAPHORE_QUEUE_ITEM_LENGTH 其实是一个宏定义， 其值为 0， 它表示创建的消息空间（队列项） 大小为 0， 因为这个所谓的“消息  队列” 其实并不是用于存储消息的， 而是被用作二值信号量， 因为我们根本无需关注消息内容是什么， 只要知道有没有信号量就行了。</p>
<p>代码(3)： ucQueueType 表示的是创建消息队列的类型， 在 queue.h 中有定义:</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628213325503.png" alt="image-20240628213325503"></p>
<h4 id="创建计数信号量-xSemaphoreCreateCounting"><a href="#创建计数信号量-xSemaphoreCreateCounting" class="headerlink" title="创建计数信号量  xSemaphoreCreateCounting()"></a>创建计数信号量  xSemaphoreCreateCounting()</h4><p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628213506376.png" alt="image-20240628213506376"></p>
<h3 id="信号量删除函数"><a href="#信号量删除函数" class="headerlink" title="信号量删除函数"></a>信号量删除函数</h3><p>vSemaphoreDelete()用于删除一个信号量， 包括二值信号量， 计数信号量，互斥量和递归互斥量。 如果有任务阻塞在该信号量上， 那么不要删除该信号量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628213551938.png" alt="image-20240628213551938"></p>
<h3 id="信号量释放函数"><a href="#信号量释放函数" class="headerlink" title="信号量释放函数"></a>信号量释放函数</h3><p>与消息队列的操作一样， 信号量的释放可以在任务、 中断中使用， 所以需要有不一样的 API 函数在不一样的上下文环境中调用。<br>在前面的讲解中， 我们知道， 当信号量有效的时候， 任务才能获取信号量，那么， 是什么函数使得信号量变得有效？ </p>
<p>其实有两个方式，</p>
<p>一个是在创建的时候进行初始化， 将它可用的信号量个数设置一个初始值； </p>
<p>在二值信号量中， 该初始  值的范围是 0<del>1（旧版本的 FreeRTOS 中创建二值信号量默认是有效的， 而新版本则默认是无效） ， 假如初始值为 1 个可用的信号量的话， 被申请一次就变得无效了， 那就需要我们释放信号量， FreeRTOS 提供了信号量释放函数， 每调用一次该函数就释放一个信号量。 但是有个问题， 能不能一直释放？ 很显然， 这是不能的， 无论是你的信号量是二值信号量还是计数信号量， 都要注意可用信号量的范围， 当用作二值信号量的时候， 必须确保其可用值在 0</del>1 范围内； 而用作计数信号量的话， 其范围是由用户在创建时指定 uxMaxCount， 其最大可用信号量不允许超出 uxMaxCount， 这代表我们不能一直调用信号量释放函数来释放信<br>号量， 其实一直调用也是无法释放成功的。</p>
<blockquote>
<p>好像就是 PV操作中的 V操作</p>
</blockquote>
<h4 id="xSemaphoreGive"><a href="#xSemaphoreGive" class="headerlink" title="xSemaphoreGive()"></a>xSemaphoreGive()</h4><p>xSemaphoreGive()是一个用于释放信号量的宏， 真正的实现过程是调用消息队列通用发送函数。</p>
<p>释放的信号量对象必须是已经被创建的， 可以用于二值信号量、 计数信号量、 互斥量的释放， 但不能释放由函数 xSemaphoreCreateRecursiveMutex()创建的递归互斥量。 <strong>此外该函数不能在中断中使用</strong>。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xSemaphoreGive( xSemaphore )</span></span><br><span class="line">	xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ),</span><br><span class="line">						<span class="literal">NULL</span>,</span><br><span class="line">						semGIVE_BLOCK_TIME,</span><br><span class="line">						queueSEND_TO_BACK )</span><br></pre></td></tr></table></figure>

<p>从该宏定义可以看出释放信号量实际上是一次入队操作， 并且是不允许入队阻塞， 因为阻塞时间为 semGIVE_BLOCK_TIME， 该宏的值为 0。<br>通过消息队列入队过程分析， 我们可以将释放一个信号量的过程简化：</p>
<p> 如果信号量未满， 控制块结构体成员 uxMessageWaiting 就会加 1， 然后判断是否有阻塞的任务， 如果有的话就会恢复阻塞的任务， 然后返回成功信息（pdPASS） ；</p>
<p>如果信号量已满， 则返回错误代码（err_QUEUE_FULL） 。  </p>
<h4 id="xSemaphoreGiveFromISR"><a href="#xSemaphoreGiveFromISR" class="headerlink" title="xSemaphoreGiveFromISR()"></a>xSemaphoreGiveFromISR()</h4><p>用于释放一个信号量， <strong>带中断保护</strong>。 被释放的信号量可以是二进制信号量和计数信号量。 </p>
<p>和普通版本的释放信号量 API 函数有些许不同， 它不能释放互斥量， 这是因为<strong>互斥量不可以在中断中使用</strong>， 互斥量的优先级继承机制只能在任务中起作用， 而在中断中毫无意义。 带中断保护的信号量释放其实也是一个宏， 真正调用的函数是 xQueueGiveFromISR ().</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )</span></span><br><span class="line">		xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ),</span><br><span class="line">							( pxHigherPriorityTaskWoken ) )</span><br></pre></td></tr></table></figure>

<p>如果可用信号量未满， 控制块结构体成员 uxMessageWaiting 就会加 1， 然后判断是否有阻塞的任务， 如果有的话就会恢复阻塞的任务， 然后返回成功信息（pdPASS） ， 如果恢复的任务优先级比当前任务优先级高， 那么在退出中断要进行任务切换一次； 如果信号量满， 则返回错误代码（err_QUEUE_FULL） ， 表示信号量满。</p>
<p>一个或者多个任务有可能阻塞在同一个信号量上， 调用函数xSemaphoreGiveFromISR()可能会唤醒阻塞在该信号量上的任务， 如果被唤醒的任务的优先级大于当前任务的优先级， 那么形参 pxHigherPriorityTaskWoken就会被设置为 pdTRUE， 然后在中断退出前执行一次上下文切换。</p>
<h3 id="信号量获取函数"><a href="#信号量获取函数" class="headerlink" title="信号量获取函数"></a>信号量获取函数</h3><p>与消息队列的操作一样， 信号量的获取可以在任务、 中断（中断中使用并不常见） 中使用， 所以需要有不一样的 API 函数在不一样的上下文环境中调用。</p>
<p>与释放信号量对应的是获取信号量， 我们知道， 当信号量有效的时候， 任务才能获取信号量， 当任务获取了某个信号量的时候， 该信号量的可用个数就减一，当它减到 0 的时候， 任务就无法再获取了， 并且获取的任务会进入阻塞态（假如用户指定了阻塞超时时间的话） 。 如果某个信号量中当前拥有 1 个可用的信号量的话， 被获取一次就变得无效了， 那么此时另外一个任务获取该信号量的时<br>候， 就会无法获取成功， 该任务便会进入阻塞态， 阻塞时间由用户指定。  </p>
<blockquote>
<p>PV操作中的 P操作</p>
</blockquote>
<h4 id="xSemaphoreTake"><a href="#xSemaphoreTake" class="headerlink" title="xSemaphoreTake()"></a>xSemaphoreTake()</h4><p>xSemaphoreTake()函数用于获取信号量， <strong>不带中断保护</strong>。 获取的信号量对象可以是二值信号量、 计数信号量和互斥量， 但是递归互斥量并不能使用这个 API函数获取。 </p>
<p>其实获取信号量是一个宏， 真正调用的函数是 xQueueGenericReceive()。 该宏不能在中断使用， 而是必须由具体中断保护功能的<br>xQueueReceiveFromISR()版本代替。 </p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628215005019.png" alt="image-20240628215005019" style="zoom:80%;" />

<p>从该宏定义可以看出释放信号量实际上是一次消息出队操作， 阻塞时间由用户指定 xBlockTime， 当有任务试图获取信号量的时候， 当且仅当信号量有效的时候， 任务才能读获取到信号量。 如果信号量无效， 在用户指定的阻塞超时时间中， 该任务将保持阻塞状态以等待信号量有效。 当其它任务或中断释放了有效的信号量， 该任务将自动由阻塞态转移为就绪态。 当任务等待的时间超过了指定的阻塞间， 即使信号量中还是没有可用信号量， 任务也会自动从阻塞态转移为就绪态。</p>
<p>通过前面消息队列出队过程分析， 我们可以将获取一个信号量的过程简化：<br>如果有可用信号量， 控制块结构体成员 uxMessageWaiting 就会减 1， 然后返回获取成功信息（pdPASS） ； </p>
<p>如果信号量无效并且阻塞时间为 0， 则返回错误代码（errQUEUE_EMPTY） ； </p>
<p>如果信号量无效并且用户指定了阻塞时间， 则任务会因为  等待信号量而进入阻塞状态， 任务会被挂接到延时列表中  </p>
<h4 id="xSemaphoreTakeFromISR"><a href="#xSemaphoreTakeFromISR" class="headerlink" title="xSemaphoreTakeFromISR()"></a>xSemaphoreTakeFromISR()</h4><p>SemaphoreTakeFromISR()是函数 xSemaphoreTake()的中断版本， 用于获取信号量， 是<strong>一个不带阻塞机制获取信号量的函数</strong>， 获取对象必须由是已经创建的信号量， 信号量类型可以是二值信号量和计数信号量， 它与 xSemaphoreTake()函数不同， 它不能用于获取互斥量， 因为互斥量不可以在中断中使用， 并且互斥量特有的优先级继承机制只能在任务中起作用， 而在中断中毫无意义。</p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240628215301699.png" alt="image-20240628215301699" style="zoom:80%;" />

<h2 id="软件实现-1"><a href="#软件实现-1" class="headerlink" title="软件实现"></a>软件实现</h2><h3 id="二值信号量-1"><a href="#二值信号量-1" class="headerlink" title="二值信号量"></a>二值信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();           <span class="comment">//进入临界区</span></span><br><span class="line">     </span><br><span class="line">	<span class="comment">/* 创建 BinarySem */</span>   </span><br><span class="line">	BinarySem_Handle = xSemaphoreCreateBinary();	 </span><br><span class="line">	<span class="comment">//xSemaphoreCreateBinary  创建二值信号量 函数</span></span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">        </span><br><span class="line">    vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">    taskEXIT_CRITICAL();            <span class="comment">//退出临界区</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">receive_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdPASS;<span class="comment">/* 定义一个创建信息返回值，默认为pdPASS */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取二值信号量 xSemaphore,没获取到则一直等待</span></span><br><span class="line">        <span class="comment">//xSemaphoreTake 信号量 获取函数</span></span><br><span class="line">		xReturn = xSemaphoreTake(BinarySem_Handle,<span class="comment">/* 二值信号量句柄 */</span></span><br><span class="line">								portMAX_DELAY); <span class="comment">/* 等待时间 */</span></span><br><span class="line">		<span class="keyword">if</span>(pdTRUE == xReturn)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;BinarySem_Handle二值信号量获取成功!\n\n&quot;</span>);</span><br><span class="line">		LED2=!LED2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdPASS;<span class="comment">/* 定义一个创建信息返回值，默认为pdPASS */</span></span><br><span class="line">	u8 key=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY_UP_PRESS)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//xSemaphoreGive 信号量 释放函数</span></span><br><span class="line">			xReturn = xSemaphoreGive( BinarySem_Handle );<span class="comment">//给出二值信号量</span></span><br><span class="line">			<span class="keyword">if</span>( xReturn == pdTRUE )</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;BinarySem_Handle二值信号量释放成功!\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;BinarySem_Handle二值信号量释放失败!\r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(key==KEY1_PRESS)</span><br><span class="line">		&#123;</span><br><span class="line">			xReturn = xSemaphoreGive( BinarySem_Handle );<span class="comment">//给出二值信号量</span></span><br><span class="line">			<span class="keyword">if</span>( xReturn == pdTRUE )</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;BinarySem_Handle二值信号量释放成功!\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;BinarySem_Handle二值信号量释放失败!\r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		vTaskDelay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="计数信号量-1"><a href="#计数信号量-1" class="headerlink" title="计数信号量"></a>计数信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();           <span class="comment">//进入临界区</span></span><br><span class="line">     </span><br><span class="line">	<span class="comment">/* 创建 CountSem */</span></span><br><span class="line">    <span class="comment">// 创建 计数 信号量</span></span><br><span class="line">	CountSem_Handle = xSemaphoreCreateCounting(<span class="number">5</span>,<span class="number">5</span>); </span><br><span class="line">       </span><br><span class="line">    vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">    taskEXIT_CRITICAL();            <span class="comment">//退出临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">receive_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdPASS;<span class="comment">/* 定义一个创建信息返回值，默认为pdPASS */</span></span><br><span class="line">	u8 key=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY1_PRESS)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//xSemaphoreTake 信号量释放函数</span></span><br><span class="line">			xReturn = xSemaphoreTake( CountSem_Handle,<span class="number">0</span> );<span class="comment">//获取计数信号量</span></span><br><span class="line">			<span class="keyword">if</span>( xReturn == pdTRUE )</span><br><span class="line">				<span class="built_in">printf</span>( <span class="string">&quot;KEY1被按下，释放1个停车位。\r\n&quot;</span> );</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>( <span class="string">&quot;KEY1被按下，但已无车位可以释放！\r\n&quot;</span> );</span><br><span class="line">		&#125;</span><br><span class="line">		vTaskDelay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdPASS;<span class="comment">/* 定义一个创建信息返回值，默认为pdPASS */</span></span><br><span class="line">	u8 key=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY_UP_PRESS)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//xSemaphoreGive 信号量 获取函数</span></span><br><span class="line">			xReturn = xSemaphoreGive( CountSem_Handle );<span class="comment">//给出计数信号量</span></span><br><span class="line">			<span class="keyword">if</span>( xReturn == pdTRUE )</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;KEY_UP被按下，成功申请到停车位。\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;KEY_UP被按下，不好意思，现在停车场已满！\r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		vTaskDelay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><blockquote>
<p>互斥 夹紧</p>
</blockquote>
<p>互斥量又称互斥信号量（本质是信号量） ， 是<strong>一种特殊的二值信号量</strong>， 它和信号量不同的是， 它支持互斥量所有权、 递归访问以及防止优先级翻转的特性用于<strong>实现对临界资源的独占式处理。</strong> </p>
<p>本章要实现的功能是： 创建了 3 个任务与 1个二值信号量， 任务分别是高优先级任务， 中优先级任务， 低优先级任务， 用于<strong>模拟产生优先级翻转</strong>。 </p>
<p>低优先级任务在获取信号量的时候， 被中优先级打断， 中优先级的任务执行时间较长， 因为<strong>低优先级还未释放信号量， 那么高优先级任务就无法取得信号量继续运行</strong>， 此时就发生了优先级翻转， 任务在运行中， 使用串口打印出相关信息。</p>
<h2 id="互斥量简介"><a href="#互斥量简介" class="headerlink" title="互斥量简介"></a>互斥量简介</h2><p>互斥信号量其实就是一个<strong>拥有优先级继承的二值信号量</strong>， 在同步的应用中(任务与任务或中断与任务之间的同步)二值信号量最适合。 </p>
<p>互斥信号量适合用于那些<strong>需要互斥访问的应用</strong>中。 在互斥访问中互斥信号量相当于一个钥匙， 当任务想要使用资源的时候就必须先获得这个钥匙， 当使用完资源以后就必须归还这个钥匙， 这样其他的任务就可以拿着这个钥匙去使用资源。</p>
<p>互斥信号量使用和二值信号量相同的 API 操作函数， 所以互斥信号量也可以设置阻塞时间， 不同于二值信号量的是<strong>互斥信号量具有优先级继承的特性</strong>。</p>
<p> 当一个互斥信号量<strong>正在被一个低优先级的任务使用</strong>， 而此时有个<strong>高优先级的任务也尝试获取这个互斥信号量的话就会被阻塞</strong>。 不过这个<strong>高优先级的任务会将低优先级任务的优先级提升到与自己相同的优先级</strong>， 这个过程就是优先级继承。 优先级继承尽可能的降低了高优先级任务处于阻塞态的时间， 并且将已经出现的“优先级翻转” 的影响降到最低  </p>
<blockquote>
<p>互斥量有优先级继承机制， 二值信号量则没有这个机制。</p>
<p>这使得二值信号量更偏向应用于<strong>同步功能</strong>（任务与任务间的同步或任务和中断间同步） ，而互斥量更偏向应用于<strong>临界资源的访问</strong>。</p>
</blockquote>
<h3 id="优先级继承机制"><a href="#优先级继承机制" class="headerlink" title="优先级继承机制"></a>优先级继承机制</h3><p>在 FreeRTOS 操作系统中为了降低优先级翻转问题利用了优先级继承算法。</p>
<p>优先级继承算法是指， 暂时提高某个占有某种资源的低优先级任务的优先级， 使之与在所有等待该资源的任务中优先级最高那个任务的优先级相等， 而当这个低优先级任务执行完毕释放该资源时， 优先级重新回到初始设定值。 </p>
<p>因此， 继承优先级的任务<strong>避免了系统资源被任何中间优先级的任务抢占</strong>。</p>
<p>也就是说， 某个临界资源受到一个互斥量保护， 如果这个资源正在被一个低优先级任务使用， 那么此时的互斥量是闭锁状态， 也代表了没有任务能申请到这个互斥量， 如果此时一个高优先级任务想要对这个资源进行访问， 去申请这个互斥量， 那么高优先级任务会因为申请不到互斥量而进入阻塞态， 那么系统会<strong>将现在持有该互斥量的任务的优先级临时提升到与高优先级任务的优先级相同</strong>， 这个优先级提升的过程叫做优先级继承。 这个优先级继承机制<strong>确保高优先级任务进入阻塞状态的时间尽可能短</strong>， 以及将已经出现的“优先级翻转” 危害降低到最小。  </p>
<p>结合过程示意图再说一遍。 我们知道任务的优先级在创建的时候就已经是设置好的， <strong>高优先级的任务可以打断低优先级的任务， 抢占</strong><br><strong>CPU 的使用权</strong>。 但是在很多场合中， 某些资源只有一个， <strong>当低优先级任务正在占用该资源的时候， 即便高优先级任务也只能乖乖的等待低优先级任务使用完该资源后释放资源</strong>。 这里高优先级任务无法运行而低优先级任务可以运行的现象称为 <strong>“优先级翻转</strong>” 。</p>
<p>为什么说优先级翻转在操作系统中是危害很大？ 因为在我们一开始创造这个系统的时候， 我们就已经设置好了任务的优先级了， 越重要的任务优先级越高。但是发生优先级翻转， 对我们操作系统是致命的危害， <strong>会导致系统的高优先级任务阻塞时间过长</strong>。</p>
<p>举个例子， 现在有 3 个任务分别为 H 任务（High） 、 M 任务（Middle） 、L 任务（Low） ， 3 个任务的优先级顺序为 H 任务&gt;M 任务&gt;L 任务。 正常运行的时候 H 任务可以打断 M 任务与 L 任务， M 任务可以打断 L 任务</p>
<p>有一个资源被保护了， 此时该资源被 L 任务正在使用中， 某一刻， H 任务需要使用该资源， 但是 L 任务还没使用完， H 任务则因为申请不到资源而进入阻塞态， L 任务继续使用该资源， 此时已经出现了“优先级翻转” 现象， 高优先级任务在等着低优先级的任务执行， <strong>如果在 L 任务执行的时候刚好 M 任务被唤醒了， 由于 M 任务优先级比 L 任务优先级高， 那么会打断 L 任务， 抢占了 CPU 的</strong><br><strong>使用权</strong>， 直到 M 任务执行完， 再把 CUP 使用权归还给 L 任务， L 任务继续执行， 等到执行完毕之后释放该资源， H 任务此时才从阻塞态解除， 使用该资源。</p>
<blockquote>
<p>注意：M任务 不需要 使用某一资源（譬如 打印机），它只是 单纯的 高优先级抢占了低优先级的CPU使用权</p>
<p>​		而H任务 需要     使用某一资源，  它 需要 M任务 用完 （打印机）之后 ，才能 使用CPU ，因此进入阻塞态</p>
</blockquote>
<p>这个过程， 本来是最高优先级的 H 任务， 在等待了更低优先级的 L 任务与 M 任务， 其阻塞的时间是 M 任务运行时间+L 任务运行时间， </p>
<blockquote>
<p>继承优先级 机制 让 最高优先级的 H 任务阻塞的时间 &#x3D; L 任务运行时间</p>
</blockquote>
<p>这只是只有 3 个任务的系统， 假如很多个这样子的任务打断最低优先级的任务， 那这个系统最高优先级任务岂不是崩溃了， 这个现象是绝对不允许出现的， 高优先级的任务必须能及时响应。 所以， 没有优先级继承的情况下， 使用资源保护， 其危害极大。</p>
<p>但是使用互斥量的时候一定需要注意： <strong>在获得互斥量后， 请尽快释放互斥量</strong>，同时需要注意的是在任务持有互斥量的这段时间， 不得更改任务的优先级。FreeRTOS 的优先级继承机制不能解决优先级反转， 只能将这种情况的影响降低到最小， 硬实时系统在一开始设计时就要避免优先级反转发生。   </p>
<h3 id="互斥量应用场景"><a href="#互斥量应用场景" class="headerlink" title="互斥量应用场景"></a>互斥量应用场景</h3><p>互斥量的使用比较单一， 因为它是信号量的一种， 并且它是以锁的形式存在。在初始化的时候， 互斥量处于开锁的状态， 而被任务持有的时候则立刻转为闭锁的状态。 </p>
<p>互斥量更适合于：  </p>
<p>●可能会引起优先级翻转的情况。</p>
<p>递归互斥量更适用于：</p>
<p>●任务可能会多次获取互斥量的情况下。 这样可以避免同一任务多次递归持有而造成死锁的问题。</p>
<p>多任务环境下往往存在多个任务竞争同一临界资源的应用场景， 互斥量可被用于对临界资源的保护从而实现独占式访问。 另外， 互斥量可以降低信号量存在的优先级翻转问题带来的影响。</p>
<p>比如有两个任务需要对串口进行发送数据， 其硬件资源只有一个， 那么两个任务肯定不能同时发送啦， 不然导致数据错误， 那么， 就可以用互斥量对串口资源进行保护， 当一个任务正在使用串口的时候， 另一个任务则无法使用串口， 等到任务使用串口完毕之后， 另外一个任务才能获得串口的使用权。</p>
<p>另外需要注意的是<strong>互斥量不能在中断服务函数中使用</strong>， 因为其特有的优先级继承机制只在任务起作用， 在中断的上下文环境毫无意义  </p>
<h3 id="互斥量运作机制"><a href="#互斥量运作机制" class="headerlink" title="互斥量运作机制"></a>互斥量运作机制</h3><p>多任务环境下会存在多个任务访问同一临界资源的场景， 该资源会被任务独占处理。 其他任务在资源被占用的情况下不允许对该临界资源进行访问， 这个时候就需要用到 FreeRTOS 的互斥量来进行资源保护， 那么互斥量是怎样来避免这种冲突？</p>
<p>用互斥量处理不同任务对临界资源的同步访问时， 任务想要获得互斥量才能进行资源访问， 如果一旦有任务成功获得了互斥量， 则互斥量立即变为闭锁状态，此时其他任务会因为获取不到互斥量而不能访问这个资源， 任务会根据用户自定义的等待时间进行等待， 直到互斥量被持有的任务释放后， 其他任务才能获取互斥量从而得以访问该临界资源， 此时互斥量再次上锁， 如此一来就可以<strong>确保每个时刻只有一个任务正在访问这个临界资源</strong>， 保证了临界资源操作的安全性  </p>
<h3 id="互斥量控制块"><a href="#互斥量控制块" class="headerlink" title="互斥量控制块"></a>互斥量控制块</h3><p>互斥量的 API 函数实际上都是宏， 它使用现有的队列机制， 这些宏定义在semphr.h 文件中， 如果使用互斥量， 需要包含 semphr.h 头文件。 所以 FreeRTOS的<strong>互斥量控制块结构体与消息队列结构体是一模一样的</strong>， 只不过结构体中某些成员变量代表的含义不一样而已， </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int8_t</span> *pcHead;</span><br><span class="line">	<span class="type">int8_t</span> *pcTail;</span><br><span class="line">	<span class="type">int8_t</span> *pcWriteTo;</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">	<span class="type">int8_t</span> *pcReadFrom;</span><br><span class="line">	UBaseType_t uxRecursiveCallCount; 		(<span class="number">1</span>)</span><br><span class="line"> &#125; u;</span><br><span class="line">    </span><br><span class="line">List_t xTasksWaitingToSend;</span><br><span class="line">List_t xTasksWaitingToReceive;</span><br><span class="line"><span class="keyword">volatile</span> UBaseType_t uxMessagesWaiting; 	(<span class="number">2</span>)</span><br><span class="line">UBaseType_t uxLength; 						(<span class="number">3</span>)</span><br><span class="line">UBaseType_t uxItemSize; 					(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int8_t</span> cRxLock;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int8_t</span> cTxLock;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp;</span></span><br><span class="line">	( configSUPPORT_DYNAMIC_ALLOCATION == <span class="number">1</span> ) )</span><br><span class="line">    <span class="type">uint8_t</span> ucStaticallyAllocated;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span> *<span class="title">pxQueueSetContainer</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">	UBaseType_t uxQueueNumber;</span><br><span class="line">	<span class="type">uint8_t</span> ucQueueType;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; xQUEUE;</span><br><span class="line"><span class="keyword">typedef</span> xQUEUE Queue_t;</span><br></pre></td></tr></table></figure>

<p>代码(1)： pcReadFrom 与 uxRecursiveCallCount 是一对互斥变量， 使用联合体用来确保两个互斥的结构体成员不会同时出现。 当结构体用于队列时，pcReadFrom 指向出队消息空间的最后一个， 见文知义， 就是读取消息时候是从pcReadFrom 指向的空间读取消息内容。 当结构体用于互斥量时，uxRecursiveCallCount 用于计数， 记录递归互斥量被“调用” 的次数。</p>
<p>代码(2)： 如果控制块结构体是用于消息队列： uxMessagesWaiting 用来记录当前消息队列的消息个数； 如果控制块结构体被用于互斥量的时候， 这个值就表示有效互斥量个数， 这个值是 1 则表示互斥量有效， 如果是 0 则表示互斥量无效。</p>
<p>代码(3)： 如果控制块结构体是用于消息队列： uxLength 表示队列的长度，也就是能存放多少消息； 如果控制块结构体被用于互斥量的时候， uxLength 表示最大的信号量可用个数， uxLength 最大为 1， 因为信号量要么是有效的， 要么是无效的。</p>
<p>代码(4)： 如果控制块结构体是用于消息队列： uxItemSize 表示单个消息的大小； 如果控制块结构体被用于互斥量的时候， 则无需存储空间， 为 0 即可。  </p>
<h2 id="常用互斥量API"><a href="#常用互斥量API" class="headerlink" title="常用互斥量API"></a>常用互斥量API</h2><h3 id="互斥量创建函数"><a href="#互斥量创建函数" class="headerlink" title="互斥量创建函数"></a>互斥量创建函数</h3><h4 id="xSemaphoreCreateMutex"><a href="#xSemaphoreCreateMutex" class="headerlink" title="xSemaphoreCreateMutex()"></a>xSemaphoreCreateMutex()</h4><p>用于创建一个互斥量， 并返回一个互斥量句柄。该句柄的原型是一个 void 型的指针， 在使用之前必须先由用户定义一个互斥量句柄。</p>
<p> 要想使用该函数必须在 FreeRTOSConfig.h 中把宏configSUPPORT_DYNAMIC_ALLOCATION 定义为 1， 即开启动态内存分配， 其实该<br>宏在 FreeRTOS.h 中默认定义为 1， 即所有 FreeRTOS 的对象在创建的时候都默认使用动态内存分配方案，</p>
<p> 同时还需在FreeRTOSConfig.h 中把configUSE_MUTEXES 宏定义打开， 表示使用互斥量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> xSemaphoreCreateMutex()</span></span><br><span class="line">		xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="递归互斥量创建函数"><a href="#递归互斥量创建函数" class="headerlink" title="递归互斥量创建函数"></a>递归互斥量创建函数</h3><h4 id="xSemaphoreCreateRecursiveMutex"><a href="#xSemaphoreCreateRecursiveMutex" class="headerlink" title="xSemaphoreCreateRecursiveMutex()"></a>xSemaphoreCreateRecursiveMutex()</h4><p>xSemaphoreCreateRecursiveMutex()用于创建一个递归互斥量， 不是递归的互斥量由函数 xSemaphoreCreateMutex() 或 xSemaphoreCreateMutexStatic()创建（我们只讲解动态创建） ， 且只能被同一个任务获取一次， 如果同一个任务想再次获取则会失败。 递归信号量则相反， 它可以被同一个任务获取很多次， 获取多少次就需要释放多少次。 递归信号量与互斥量一样， 都实现了优先级继承机制， 可以降低优先级反转的危害。  </p>
<img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629155709426.png" alt="image-20240629155709426" style="zoom:80%;" />

<h3 id="互斥量删除函数"><a href="#互斥量删除函数" class="headerlink" title="互斥量删除函数"></a>互斥量删除函数</h3><h4 id="vSemaphoreDelete"><a href="#vSemaphoreDelete" class="headerlink" title="vSemaphoreDelete()"></a>vSemaphoreDelete()</h4><p>互斥量的本质是信号量， 直接调用 vSemaphoreDelete()函数进行删除即可。  </p>
<h3 id="互斥量获取函数"><a href="#互斥量获取函数" class="headerlink" title="互斥量获取函数"></a>互斥量获取函数</h3><h4 id="xSemaphoreTake-1"><a href="#xSemaphoreTake-1" class="headerlink" title="xSemaphoreTake()"></a>xSemaphoreTake()</h4><p>我们知道， 当互斥量处于开锁的状态， 任务才能获取互斥量成功， 当任务持有了某个互斥量的时候， 其它任务就无法获取这个互斥量， 需要等到持有互斥量的任务进行释放后， 其他任务才能获取成功， <strong>任务通过互斥量获取函数来获取互斥量的所有权</strong>。 <strong>任务对互斥量的所有权是独占的， 任意时刻互斥量只能被一个任务持有</strong>，</p>
<p>如果互斥量处于开锁状态， 那么获取该互斥量的任务将成功获得该互斥量， 并拥有互斥量的使用权； </p>
<p>如果互斥量处于闭锁状态， 获取该互斥量的任务将无法获得互斥量， 任务将被挂起， 在任务被挂起之前， 会进行优先级继承， 如果<br>当前任务优先级比持有互斥量的任务优先级高， 那么将会临时提升持有互斥量任务的优先级。 互斥量的获取函数是一个宏定义， 实际调用的函数就是xQueueGenericReceive()    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xSemaphoreTake( xSemaphore, xBlockTime )</span></span><br><span class="line">	xQueueGenericReceive( ( QueueHandle_t ) ( xSemaphore ),<span class="literal">NULL</span>,( xBlockTime ),pdFALSE )</span><br></pre></td></tr></table></figure>

<h3 id="递归互斥量获取函数"><a href="#递归互斥量获取函数" class="headerlink" title="递归互斥量获取函数"></a>递归互斥量获取函数</h3><h4 id="xSemaphoreTakeRecursive"><a href="#xSemaphoreTakeRecursive" class="headerlink" title="xSemaphoreTakeRecursive()"></a>xSemaphoreTakeRecursive()</h4><p>SemaphoreTakeRecursive()是一个用于获取递归互斥量的宏， 与互斥量的获取函数一样， xSemaphoreTakeRecursive()也是一个宏定义， 它最终使用现有的队列机制， 实际执行的函数是 xQueueTakeMutexRecursive()。 互斥量之前必须由 xSemaphoreCreateRecursiveMutex()这个函数创建。 要注意的是该函数不能用于获取由函数 xSemaphoreCreateMutex()创建的互斥量。 要想使用该函数必须在头文件 FreeRTOSConfig.h 中把宏 configUSE_RECURSIVE_MUTEXES 定义为1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629160521332.png" alt="image-20240629160521332">  </p>
<p>递归互斥量可以在一个任务中多次获取， 当第一次获取递归互斥量时， 队列结构体成员指针 pxMutexHolder 指向获取递归互斥量的任务控制块， 当任务再次尝试获取这个递归互斥量时， 如果任务就是拥有递归互斥量所有权的任务， 那么只需要将记录获取递归次数的成员变量 u.uxRecursiveCallCount 加 1 即可， 不需要再操作队列。  </p>
<h3 id="互斥量释放函数"><a href="#互斥量释放函数" class="headerlink" title="互斥量释放函数"></a>互斥量释放函数</h3><h4 id="xSemaphoreGive-1"><a href="#xSemaphoreGive-1" class="headerlink" title="xSemaphoreGive()"></a>xSemaphoreGive()</h4><p>任务想要访问某个资源的时候， 需要先获取互斥量， 然后进行资源访问， 在任务使用完该资源的时候， 必须要及时归还互斥量， 这样别的任务才能对资源进行访问。 互斥量的释放函数与信号量的释放函数一致， 都是调用 xSemaphoreGive()函数， 但是要注意的是， 互斥量的释放只能在任务中， <strong>不允许在中断中释放互斥量</strong>。</p>
<p>使用该函数接口时， 只有已持有互斥量所有权的任务才能释放它， 当任务调用 xSemaphoreGive()函数时会将<strong>互斥量变为开锁状态</strong>， 等待获取该互斥量的任务将被唤醒。 如果任务的优先级被互斥量的优先级翻转机制临时提升， 那么当互斥量被释放后， 任务的优先级将恢复为原本设定的优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xSemaphoreGive( xSemaphore )</span></span><br><span class="line">	xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ),<span class="literal">NULL</span>,semGIVE_BLOCK_TIME,queueSEND_TO_BACK )</span><br></pre></td></tr></table></figure>

<h3 id="递归互斥量释放函数"><a href="#递归互斥量释放函数" class="headerlink" title="递归互斥量释放函数"></a>递归互斥量释放函数</h3><h4 id="xSemaphoreGiveRecursive"><a href="#xSemaphoreGiveRecursive" class="headerlink" title="xSemaphoreGiveRecursive()"></a>xSemaphoreGiveRecursive()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( configUSE_RECURSIVE_MUTEXES == 1 )</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> xSemaphoreGiveRecursive( xMutex )</span></span><br><span class="line">		xQueueGiveMutexRecursive( ( xMutex ) )</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>xSemaphoreGiveRecursive()函数用于释放一个递归互斥量。 </p>
<p>已经获取递归互斥量的任务可以重复获取该递归互斥量。 使用 <strong>xSemaphoreTakeRecursive()函数成功获取</strong>几次递归互斥量， 就要使用 <strong>xSemaphoreGiveRecursive()函数返还几次</strong>， 在此之前递归互斥量都处于无效状态， 别的任务就无法获取该递归互斥量。</p>
<p>使用该函数接口时， 只有已持有互斥量所有权的任务才能释放它， 每释放一次该递归互斥量， 它的计数值就减 1。</p>
<p> 当该互斥量的计数值为 0 时（即持有任务已经释放所有的持有操作） ， 互斥量则变为开锁状态， 等待在该互斥量上的任务将被唤醒。 </p>
<p>如果任务的优先级被互斥量的优先级翻转机制临时提升， 那么当互斥量被释放后， 任务的优先级将恢复为原本设定的优先级。  </p>
<h2 id="软件实现-2"><a href="#软件实现-2" class="headerlink" title="软件实现"></a>软件实现</h2><h3 id="模拟优先级翻转"><a href="#模拟优先级翻转" class="headerlink" title="模拟优先级翻转"></a>模拟优先级翻转</h3><h3 id="互斥量-1"><a href="#互斥量-1" class="headerlink" title="互斥量"></a>互斥量</h3><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>事件是一种实现<strong>任务间通信的机制</strong>， 主要用于实现<strong>多任务间的同步</strong>， 但<strong>事件通信只能是事件类型的通信</strong>， 无数据传输。 与信号量不同的是， 它可以<strong>实现一对多， 多对多的同步</strong>。</p>
<p> 即一个任务可以等待多个事件的发生： 可以是任意一个事件发生时唤醒任务进行事件处理； 也可以是几个事件都发生后才唤醒任务进行事件处理。 同样， 也可以是多个任务同步多个事件。</p>
<p>每一个<strong>事件组</strong>只需要很少的 RAM 空间来<strong>保存事件组的状态</strong>。 </p>
<p>事件组存储在一个 EventBits_t 类型的变量中， 该变量在事件组结构体中定义。</p>
<p> 如果宏configUSE_16_BIT_TICKS 定义为 1， 那么变量 uxEventBits 就是 16 位的， 其中有 8 个位用来存储事件组； 而如果宏 configUSE_16_BIT_TICKS 定义为 0，那么变量 uxEventBits 就是 32 位的， 其中有 24 个位用来存储事件组。</p>
<p>在 STM32中， 我们一般将 configUSE_16_BIT_TICKS 定义为 0， 那么 uxEventBits 是 32位的， 有 24 个位用来实现事件标志组。 每一位代表一个事件， <strong>任务通过“逻辑与” 或“逻辑或” 与一个或多个事件建立关联， 形成一个事件组</strong>。</p>
<p> <strong>事件的“逻辑或”</strong> 也被称作是<strong>独立型同步</strong>， 指的是<strong>任务</strong>感兴趣的所有事件<strong>任一件发生即可被唤醒</strong>；</p>
<p> <strong>事件的“逻辑与”</strong> 则被称为是关联型同步， 指的是<strong>任务</strong>感兴趣的若干事件<strong>都发生时才被唤醒</strong>， 并且事件发生的时间可以不同步。</p>
<p>多任务环境下， 任务、 中断之间往往需要同步操作， 一个事件发生会告知等待中的任务， <strong>即形成一个任务与任务、 中断与任务间的同步</strong>。 事件可以提供一对多、 多对多的同步操作。</p>
<p> 一对多同步模型： 一个任务等待多个事件的触发， 这种情况是比较常见的；</p>
<p> 多对多同步模型： 多个任务等待多个事件的触发。任务可以通过设置事件位来实现事件的触发和等待操作。 </p>
<h3 id="FreeRTOS-提供的事件具有如下特点："><a href="#FreeRTOS-提供的事件具有如下特点：" class="headerlink" title="FreeRTOS 提供的事件具有如下特点："></a>FreeRTOS 提供的事件具有如下特点：</h3><p>●<strong>事件只与任务相关联</strong>， 事件相互独立， 一个 32 位的事件集合（EventBits_t 类型的变量， 实际可用与表示事件的只有 24 位） ， 用于标识该任务发生的事件类型， 其中每一位表示一种事件类型（0 表示该事件类型未发生、1 表示该事件类型已经发生） ， 一共 24 种事件类型。</p>
<p>●<strong>事件仅用于同步， 不提供数据传输功能。</strong>  </p>
<p>●事件<strong>无排队性</strong>， 即多次向任务设置同一事件(如果任务还未来得及读走)，等效于只设置一次。</p>
<p>●允许<strong>多个任务对同一事件进行读写操作</strong>。</p>
<p>●支持事件等待超时机制。在 FreeRTOS 事件中， 每个事件获取的时候， 用户可以选择感兴趣的事件，并且选择读取事件信息标记， 它有三个属性， 分别是逻辑与， 逻辑或以及是否清除标记。 <strong>当任务等待事件同步时</strong>， 可以<strong>通过</strong>任务感兴趣的<strong>事件位和事件信息标记</strong>来<strong>判断当前接收的事件是否满足要求</strong>， 如果满足则说明任务等待到对应的事件，系统将唤醒等待的任务； 否则， 任务会根据用户指定的阻塞超时时间继续等待下去  </p>
<h3 id="事件应用场景"><a href="#事件应用场景" class="headerlink" title="事件应用场景"></a>事件应用场景</h3><p>我们可以用事件来<strong>做标志位， 判断某些事件是否发生</strong>了， 然后根据结果做处理</p>
<p> 那很多人又会问了， 为什么我不直接用变量做标志呢， 岂不是更好更有效率？</p>
<p>若是在裸机编程中， 用全局变量是最为有效的方法， 这点我不否认， 但是在操作系统中， 使用全局变量就要考虑以下问题了：</p>
<p>●如何对全局变量进行保护呢， 如何处理多任务同时对它进行访问？</p>
<p>●如何让内核对事件进行有效管理呢？ <strong>使用全局变量的话， 就需要在任务中轮询查看事件是否发送</strong>， 这简直就是在浪费 CPU 资源啊，</p>
<p>在某些场合， 可能需要多个事件发生了才能进行下一步操作， 比如一些危险机器的启动， 需要检查各项指标， 当指标不达标的时候， 无法启动， 但是检查各个指标的时候， 不能一下子检测完毕， 所以， 需要事件来做统一的等待， 当所有的事件都完成了， 那么机器才允许启动， 这只是事件的其中一个应用。</p>
<p>事件可使用于多种场合， 它<strong>能够在一定程度上替代信号量</strong>， <strong>用于任务与任务间， 中断与任务间的同步</strong>。 一个任务或中断服务例程发送一个事件给事件对象  而后等待的任务被唤醒并对相应的事件进行处理。</p>
<p>但是它与信号量<strong>不同</strong>的是， 事件的发送操作是不可累计的， 而信号量的释放动作是可累计的。</p>
<p>事件另外一个特性是， 接收任务可等待多种事件， 即可以 <strong>多个事件对应一个任务或多个任务</strong>。 同时按照任务等待的参数， 可选择是“逻辑或” 触发还是“逻辑与” 触发。 这个特性也是信号量等所不具备的， 信号量只能识别单一同步动作， 而不能同时等待多个事件的同步。</p>
<p>各个事件可分别发送或一起发送给事件对象， 而任务可以等待多个事件， 任务仅对感兴趣的事件进行关注。 当有它们感兴趣的事件发生时并且符合感兴趣的条件， 任务将被唤醒并进行后续的处理动作  </p>
<h3 id="事件运作机制"><a href="#事件运作机制" class="headerlink" title="事件运作机制"></a>事件运作机制</h3><p>接收事件时， 可以根据感兴趣的事件类型接收事件的单个或者多个事件类型。 事件接收成功后， 必须使用 xClearOnExit 选项来清除已接收到的事件类型，否则不会清除已接收到的事件， 这样就需要用户显式清除事件位。 用户可以自定义通过传入参数 xWaitForAllBits 选择读取模式， 是等待所有感兴趣的事件还是等待感兴趣的任意一个事件。设置事件时， 对指定事件写入指定的事件类型， 设置事件集合的对应事件位为 1， 可以一次同时写多个事件类型， 设置事件成功可能会触发任务调度。清除事件时， 根据入参数事件句柄和待清除的事件类型， 对事件对应位进行清 0 操作。事件不与任务相关联， 事件相互独立， 一个 32 位的变量（事件集合， 实际用于表示事件的只有 24 位） ， 用于标识该任务发生的事件类型， 其中每一位表示一种事件类型（0 表示该事件类型未发生、 1 表示该事件类型已经发生） ， 一共 24 种事件类型具体如下  </p>
<p>事件唤醒机制， 当任务因为等待某个或者多个事件发生而进入阻塞态， 当事件发生的时候会被唤醒， 其过程具体如下。  </p>
<p>任务 1 对事件 3 或事件 5 感兴趣（逻辑或） ， 当发生其中的某一个事件都会被唤醒， 并且执行相应操作。 而任务 2 对事件 3 与事件 5 感兴趣（逻辑与） ， 当且仅当事件 3 与事件 5 都发生的时候， 任务 2 才会被唤醒， 如果只有一个其中一个事件发生， 那么任务还是会继续等待事件发生。 如果在接收事件函数中设置了清除事件位 xClearOnExit， 那么当任务唤醒后将把事件 3 和事件5 的事件标志清零， 否则事件标志将依然存在。  </p>
<h3 id="事件控制块"><a href="#事件控制块" class="headerlink" title="事件控制块"></a>事件控制块</h3><p>事件标志组存储在一个 EventBits_t 类型的变量中，  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xEventGroupDefinition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	EventBits_t uxEventBits;</span><br><span class="line">	List_t xTasksWaitingForBits;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">	UBaseType_t uxEventGroupNumber;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span></span><br><span class="line">	<span class="type">uint8_t</span> ucStaticallyAllocated;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; EventGroup_t;</span><br></pre></td></tr></table></figure>

<p>如果宏 configUSE_16_BIT_TICKS 定义为 1， 那么变量 uxEventBits 就是16 位的， 其中有 8 个位用来存储事件组， </p>
<p>如果宏 configUSE_16_BIT_TICKS 定义为 0， 那么变量 uxEventBits 就是 32 位的， 其中有 24 个位用来存储事件组，</p>
<p> 每一位代表一个事件的发生与否， 利用逻辑或、 逻辑与等实现不同事件的不同唤醒处理。 </p>
<p>在 STM32 中， uxEventBits 是 32 位的， 所以我们有 24 个位用来实现事件组。 </p>
<p>除了事件标志组变量之外， FreeRTOS 还使用了一个链表来记录等待事件的任务， 所有在等待此事件的任务均会被挂载在等待事件列表xTasksWaitingForBits。  </p>
<h2 id="常用事件API函数"><a href="#常用事件API函数" class="headerlink" title="常用事件API函数"></a>常用事件API函数</h2><h3 id="事件创建函数"><a href="#事件创建函数" class="headerlink" title="事件创建函数"></a>事件创建函数</h3><h4 id="xEventGroupCreate"><a href="#xEventGroupCreate" class="headerlink" title="xEventGroupCreate()"></a>xEventGroupCreate()</h4><p>当创建一个事件时， 系统会首先给我们分配事件控制块的内存空间， 然后对该事件控制块进行基本的初始化， 创建成功返回事件句柄；<br>创建失败返回 NULL。 所以， 在使用创建函数之前， 我们需要先定义有个事件的句柄。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventGroupHandle_t Event_Handle =<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 创建 Event_Handle */</span></span><br><span class="line">Event_Handle = xEventGroupCreate();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != Event_Handle)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Event_Handle 事件创建成功!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Event_Handle 事件创建失败\r\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="事件删除函数"><a href="#事件删除函数" class="headerlink" title="事件删除函数"></a>事件删除函数</h3><h4 id="vEventGroupDelete"><a href="#vEventGroupDelete" class="headerlink" title="vEventGroupDelete()"></a>vEventGroupDelete()</h4><p>很多场合， 某些事件只用一次的， 就好比在事件应用场景说的危险机器的启动， 假如各项指标都达到了， 并且机器启动成功了， 那这个事件之后可能就没用了， 那就可以进行销毁了。</p>
<p>vEventGroupDelete()用于删除由函数 xEventGroupCreate()创建的事件组， 只有被创建成功的事件才能被删除， 但是需要注意的是该函数<strong>不允许在中断里面使用</strong>。 当事件组被删除之后， 阻塞在该事件组上的任务都会被解锁， 并向等待事件的任务返回事件组的值为 0。   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EventGroupHandle_t Event_Handle =<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 创建 Event_Handle */</span></span><br><span class="line">Event_Handle = xEventGroupCreate();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Event_Handle!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Event_Handle 事件创建成功!\r\n&quot;</span>);</span><br><span class="line"><span class="comment">/* 创建成功， 可以删除 */</span></span><br><span class="line">xEventGroupCreate(Event_Handle);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Event_Handle 事件创建失败\r\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="事件组置位函数1"><a href="#事件组置位函数1" class="headerlink" title="事件组置位函数1"></a>事件组置位函数1</h3><h4 id="xEventGroupSetBits"><a href="#xEventGroupSetBits" class="headerlink" title="xEventGroupSetBits()"></a>xEventGroupSetBits()</h4><p>xEventGroupSetBits()用于<strong>置位事件组中指定的位</strong>， 当位被置位之后， 阻塞在该位上的任务将会被解锁。 使用该函数接口时， 通过参数指定的事件标志来设定事件的标志位， 然后遍历等待在事件对象上的事件等待列表， 判断是否有任务 的事件激活要求与当前事件对象标志值匹配， 如果有， 则唤醒该任务。</p>
<p> 简单来说，就是<strong>设置我们自己定义的事件标志位为 1， 并且看看有没有任务在等待这个事件， 有的话就唤醒它</strong>。<br>注意的是该函数<strong>不允许在中断中使用</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629182330948.png" alt="image-20240629182330948"></p>
<p>xEventGroupSetBits()的运用很简单， 举个例子， 比如我们要记录一个事件的发生， 这个事件在事件组的位置是 bit0， 当它还未发生的时候， 那么事件组bit0 的值也是 0， 当它发生的时候， 我们往事件集合 bit0 中写入这个事件也就是 0x01， 那这就表示事件已经发生了， 为了便于理解， 一般操作我们都是用宏定义来实现 #define EVENT (0x01 &lt;&lt; x)， “&lt;&lt; x” 表示写入事件集合的 bitx， 在使用该函数之前必须先创建事件  </p>
<h3 id="事件组置位函数2"><a href="#事件组置位函数2" class="headerlink" title="事件组置位函数2"></a>事件组置位函数2</h3><h4 id="xEventGroupSetBitsFromISR"><a href="#xEventGroupSetBitsFromISR" class="headerlink" title="xEventGroupSetBitsFromISR()"></a>xEventGroupSetBitsFromISR()</h4><p>置位事件组中的标志位是一个不确定的操作， 因为阻塞在事件组的标志位上的任务的个数是不确定的。 </p>
<p>FreeRTOS 是不允许不确定的操作在中断和临界段中发生的， 所以 xEventGroupSetBitsFromISR()给 FreeRTOS的<strong>守护任务</strong>发送一个消息， <strong>让置位事件组的操作在守护任务里面完成</strong>， </p>
<p><strong>守护任务是基于调度锁</strong>而非临界段的机制<strong>来实现</strong>的。  </p>
<p><strong>中断中事件标志的置位是在守护任务（也叫软件定时器服务任务） 中完成的</strong>。</p>
<p>因此 FreeRTOS 的守护任务与其他 任务一样， 都是系统调度器根据其优先级进行任务调度的， 但守护任务的优先级必须比任何任务的优先级都要高， 保证在需要的时候能立即切换任务从而达到快速处理的目的， 因为这是在中断中让事件标志位置位， 其优先级由<br>FreeRTOSConfig.h 中的宏 configTIMER_TASK_PRIORITY 来定义。</p>
<p>其实 xEventGroupSetBitsFromISR()函数真正调用的也是xEventGroupSetBits()函数， 只不过是<strong>在守护任务中进行调用</strong>的， 所以它实际上执行的上下文环境依旧是在任务中。要想使用该函数， 必须把 configUSE_TIMERS 和INCLUDE_xTimerPendFunctionCall 这些宏在 FreeRTOSConfig.h 中都定义为1， 并且把 FreeRTOS&#x2F;source&#x2F;event_groups.c 这个 C 文件添加到工程中编译  </p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629191423740.png" alt="image-20240629191423740"></p>
<h3 id="等待事件函数"><a href="#等待事件函数" class="headerlink" title="等待事件函数"></a>等待事件函数</h3><h4 id="xEventGroupWaitBits"><a href="#xEventGroupWaitBits" class="headerlink" title="xEventGroupWaitBits()"></a>xEventGroupWaitBits()</h4><p>既然标记了事件的发生， 那么我怎么知道他到底有没有发生， 这也是需要一个函数来获取事件是否已经发生， FreeRTOS 提供了一个等待指定事件的函数——xEventGroupWaitBits()， 通过这个函数， <strong>任务可以知道事件标志组中的哪些位， 有什么事件发生了</strong>， 然后过“逻辑与” 、 “逻辑或” 等操作对感兴趣的事 件进行获取， 并且这个函数<strong>实现了等待超时机制</strong>， 当且仅当任务等待的事件发生时， 任务才能获取到事件信息。 在这段时间中， <strong>如果事件一直没发生， 该任务将保持阻塞状态以等待事件发生</strong>。 </p>
<p>当其它任务或中断服务程序往其等待的事件设置对应的标志位， 该任务将自动由阻塞态转为就绪态。 </p>
<p>当任务等待的时间超过了指定的阻塞时间， 即使事件还未发生， 任务也会自动从阻塞态转移为就绪态。 </p>
<p>这样子很有效的体现了操作系统的实时性， 如果事件正确获取（等待到） 则返回对应的事件标志位， 由用户判断再做处理， 因为在事件超时的时候也会返回一个不能确定的事件值， 所以需要判断任务所等待的事件是否真的发生。</p>
<p>EventGroupWaitBits()用于获取事件组中的一个或多个事件发生标志， 当要读取的事件标志位没有被置位时任务将进入阻塞等待状态。 要想使用该函数必须把 FreeRTOS&#x2F;source&#x2F;event_groups.c 这个 C 文件添加到工程中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629191648789.png" alt="image-20240629191648789"></p>
<h3 id="清除事件组指定的位"><a href="#清除事件组指定的位" class="headerlink" title="清除事件组指定的位"></a>清除事件组指定的位</h3><h4 id="xEventGroupClearBits"><a href="#xEventGroupClearBits" class="headerlink" title="xEventGroupClearBits()"></a><strong>xEventGroupClearBits()</strong></h4><h4 id="xEventGroupClearBitsFromISR"><a href="#xEventGroupClearBitsFromISR" class="headerlink" title="xEventGroupClearBitsFromISR()"></a><strong>xEventGroupClearBitsFromISR()</strong></h4><p>如果在获取事件的时候没有将对应的标志位清除， 那么就需要用这个函数来进行显式清除， xEventGroupClearBits()函数不能在中断中使用， 而是由具有中断保护功能的 xEventGroupClearBitsFromISR()来代替， 中断清除事件标志位的操作在守护任务（也叫定时器服务任务） 里面完成。</p>
<p>守护进程的优先级由 FreeRTOSConfig.h 中的宏 configTIMER_TASK_PRIORITY 来定义。 要想使用该函数必须把 FreeRTOS&#x2F;source&#x2F;event_groups.c 这个 C 文件添加到工程中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/dmyuena/yuena_blog_imgs/image-20240629192337074.png" alt="image-20240629192337074"></p>
<h2 id="软件实现-3"><a href="#软件实现-3" class="headerlink" title="软件实现"></a>软件实现</h2><h1 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h1><p>FreeRTOS 也提供了定时器功能，不过是软件定时器， 软件定时器的精度肯定是没有硬件定时器那么高， 但对于普通的精度要求不高的周期性处理的任务来说够了。 当 MCU 的硬件定时器不够的时候就可以考虑使用 FreeRTOS 的软件定时器。  </p>
<h1 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h1><p>从 V8.2.0 版本开始， FreeRTOS 新增了任务通知这个功能， 可以使用任务通知来代替信号量、 消息队列、 事件组等这些东西。 使用任务通知的话效率会更高。  </p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h1 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h1><h1 id="CPU利用率统计"><a href="#CPU利用率统计" class="headerlink" title="CPU利用率统计"></a>CPU利用率统计</h1>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/yuena.blog/images/IMG_4653.PNG">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
      </div>
  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/yuena.blog/2024/04/18/%E5%98%89%E7%AB%8B%E5%88%9BEDA-PCB%E8%AE%BE%E8%AE%A1/" rel="prev" title="嘉立创EDA_PCB设计">
                  <i class="fa fa-angle-left"></i> 嘉立创EDA_PCB设计
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/yuena.blog/2024/06/30/%E7%AE%80%E5%8E%86%E4%B8%8E%E5%BA%94%E8%81%98%E6%9D%90%E6%96%99/" rel="next" title="简历与应聘材料">
                  简历与应聘材料 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">chouzhen</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">219k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:19</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/yuena.blog/js/comments.js"></script><script src="/yuena.blog/js/utils.js"></script><script src="/yuena.blog/js/motion.js"></script><script src="/yuena.blog/js/next-boot.js"></script>

  




  <script src="/yuena.blog/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






<!--页面点击小桃心-->

  <script type="text/javascript" src="/js/love.js"></script>





<script src="/yuena.blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/yuena.blog/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
